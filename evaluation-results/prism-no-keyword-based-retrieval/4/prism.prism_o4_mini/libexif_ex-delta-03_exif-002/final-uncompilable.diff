--- a/libexif/exif-data.c
+++ b/libexif/exif-data.c
@@ -163,7 +163,8 @@
 static int
 exif_data_load_data_entry (ExifData *data, ExifEntry *entry,
 			   const unsigned char *d,
-			   unsigned int size, unsigned int offset)
+			   unsigned int size, unsigned int offset,
+			   unsigned int total_ds)
 {
 	unsigned int s, doff;
 
@@ -194,16 +195,15 @@
 	else
 		doff = offset + 8;
 
-	/* Sanity checks */
-	if (doff >= size) {
+	/* Sanity check: doff within total buffer and no overflow */
+	if (doff >= total_ds) {
 		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-				  "Tag starts past end of buffer (%u > %u)", doff, size);
+			  "Tag starts past end of buffer (%u > %u)", doff, total_ds);
 		return 0;
 	}
-
-	if (s > size - doff) {
+	if (CHECKOVERFLOW(doff, total_ds, s)) {
 		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-				  "Tag data goes past end of buffer (%u > %u)", doff+s, size);
+			  "Tag data goes past end of buffer (%u > %u)", doff + s, total_ds);
 		return 0;
 	}
 
@@ -390,7 +390,8 @@
 static void
 exif_data_load_data_content (ExifData *data, ExifIfd ifd,
 			     const unsigned char *d,
-			     unsigned int ds, unsigned int offset, unsigned int recursion_cost)
+			     unsigned int dir_ds, unsigned int total_ds,
+			     unsigned int offset, unsigned int recursion_cost)
 {
 	ExifLong o, thumbnail_offset = 0, thumbnail_length = 0;
 	ExifShort n;
@@ -423,9 +424,9 @@
 	}
 
 	/* Read the number of entries */
-	if (CHECKOVERFLOW(offset, ds, 2)) {
+	if (CHECKOVERFLOW(offset, dir_ds, 2)) {
 		exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, "ExifData",
-			  "Tag data past end of buffer (%u+2 > %u)", offset, ds);
+			  "Tag data past end of buffer (%u+2 > %u)", offset, dir_ds);
 		return;
 	}
 	n = exif_get_short (d + offset, data->priv->order);
@@ -434,10 +435,10 @@
 	offset += 2;
 
 	/* Check if we have enough data. */
-	if (CHECKOVERFLOW(offset, ds, 12*n)) {
-		n = (ds - offset) / 12;
+	if (CHECKOVERFLOW(offset, dir_ds, 12*n)) {
+		n = (dir_ds - offset) / 12;
 		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-				  "Short data; only loading %hu entries...", n);
+			  "Short data; only loading %hu entries...", n);
 	}
 
 	for (i = 0; i < n; i++) {
@@ -465,18 +466,33 @@
 			switch (tag) {
 			case EXIF_TAG_EXIF_IFD_POINTER:
 				CHECK_REC (EXIF_IFD_EXIF);
-				exif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,
-					recursion_cost + level_cost(n));
+				exif_data_load_data_content (data,
+							     EXIF_IFD_EXIF,
+							     d,
+							     dir_ds,
+							     total_ds,
+							     o,
+							     recursion_cost + level_cost(n));
 				break;
 			case EXIF_TAG_GPS_INFO_IFD_POINTER:
 				CHECK_REC (EXIF_IFD_GPS);
-				exif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,
-					recursion_cost + level_cost(n));
+				exif_data_load_data_content (data,
+							     EXIF_IFD_GPS,
+							     d,
+							     dir_ds,
+							     total_ds,
+							     o,
+							     recursion_cost + level_cost(n));
 				break;
 			case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:
 				CHECK_REC (EXIF_IFD_INTEROPERABILITY);
-				exif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,
-					recursion_cost + level_cost(n));
+				exif_data_load_data_content (data,
+							     EXIF_IFD_INTEROPERABILITY,
+							     d,
+							     dir_ds,
+							     total_ds,
+							     o,
+							     recursion_cost + level_cost(n));
 				break;
 			case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:
 				thumbnail_offset = o;
@@ -528,8 +544,8 @@
                                           "Could not allocate memory");
 				  return;
 			}
-			if (exif_data_load_data_entry (data, entry, d, ds,
-						   offset + 12 * i))
+			if (exif_data_load_data_entry (data, entry, d, dir_ds,
+						       offset + 12 * i, total_ds))
 				exif_content_add_entry (data->ifd[ifd], entry);
 			exif_entry_unref (entry);
 			break;
@@ -844,8 +860,8 @@
 exif_data_load_data (ExifData *data, const unsigned char *d_orig,
 		     unsigned int ds)
 {
-	unsigned int l;
-	ExifLong offset;
+	unsigned int l, ds_cap;
+	ExifLong offset, offset1;
 	ExifShort n;
 	const unsigned char *d = d_orig;
 	unsigned int len, fullds;
@@ -953,8 +969,7 @@
 	   16-bit length), so cap the data length to protect against overflow
 	   in future offset calculations */
 	fullds = ds;
-	if (ds > 0xfffe)
-		ds = 0xfffe;
+	ds_cap = (ds > 0xfffe) ? 0xfffe : ds;
 
 	/* Byte order (offset 6, length 2) */
 	if (!memcmp (d + 6, "II", 2))
@@ -981,27 +996,40 @@
 		return;
 
 	/* Parse the actual exif data (usually offset 14 from start) */
-	exif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);
+	exif_data_load_data_content (data,
+				     EXIF_IFD_0,
+				     d + 6,
+				     ds_cap - 6,
+				     fullds - 6,
+				     offset,
+				     0);
 
 	/* IFD 1 offset */
 	n = exif_get_short (d + 6 + offset, data->priv->order);
 	/* offset < 2<<16, n is 16 bit at most, so this op will not overflow */
-	if (offset + 6 + 2 + 12 * n + 4 > ds)
-		return;
-
-	offset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);
-	if (offset) {
-		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-			  "IFD 1 at %i.", (int) offset);
-
-		/* Sanity check. ds is ensured to be above 6 above, offset is 16bit */
-		if (offset > ds - 6) {
-			exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
-				  "ExifData", "Bogus offset of IFD1.");
-		} else {
-		   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);
-		}
-	}
+	if (offset + 6 + 2 + 12 * n + 4 > ds_cap)
+		return;
+
+	/* IFD 1 offset */
+	offset1 = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);
+	if (!offset1)
+		return;
+
+	if ((unsigned int)offset1 + 6 > fullds) {
+		exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, "ExifData",
+			  "Bogus offset of IFD1 (%u > %u)", (unsigned int)offset1 + 6, fullds);
+		return;
+	}
+
+	exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
+		  "IFD 1 at %u.", (unsigned int)offset1);
+	exif_data_load_data_content (data,
+				     EXIF_IFD_1,
+				     d + 6,
+				     ds_cap - 6,
+				     fullds - 6,
+				     offset1,
+				     0);
 
 	/*
 	 * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some
