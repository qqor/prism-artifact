{
  "project_name": "wireshark",
  "vulnerability_identifier": "wireshark_ws-delta-07_vuln_013",
  "source_directory": "/home/qqor/crete/.cache/official-afc-wireshark",
  "llm_usage": {
    "total_cost": 0.7597568000000001,
    "prompt_tokens": 558576,
    "completion_tokens": 33028
  },
  "variant": "sound",
  "diff": "--- a/epan/dissectors/packet-gvcp.c\n+++ b/epan/dissectors/packet-gvcp.c\n@@ -550,6 +550,7 @@\n static int ett_gvcp_bootstrap_fields;\n \n static expert_field ei_gvcp_privileged_register;\n+static expert_field ei_gvcp_excessive_register_count;\n \n static dissector_handle_t gvcp_handle;\n static dissector_handle_t gvsp_handle;\n@@ -978,12 +979,18 @@\n \n static int dissect_register(uint32_t addr, proto_tree *branch, tvbuff_t *tvb, int offset, int length)\n {\n-\tuint32_t value = 0;\n-\t\n-\tvalue = tvb_get_letohl(tvb, offset);\n-\tgvcp_register_number[gvcp_register_count] = addr;\n-\tgvcp_register_value[gvcp_register_count++] = value;\n-\n+    uint32_t value = 0;\n+    \n+    value = tvb_get_letohl(tvb, offset);\n+\n+    /* Defensive: ensure we don't exceed our fixed buffer */\n+    if (gvcp_register_count >= GVCP_MAX_REGISTER_COUNT) {\n+        /* Skip storing further registers */\n+        return 0;\n+    }\n+\n+    gvcp_register_number[gvcp_register_count] = addr;\n+    gvcp_register_value[gvcp_register_count++] = value;\n \tswitch (addr)\n \t{\n \tcase GVCP_VERSION:\n@@ -1808,17 +1815,29 @@\n \t\t/* XXX For now we simply (always) add ports. Maybe we should remove when the dissector gets unloaded? */\n \t\tdissector_add_uint(\"udp.port\", value, gvcp_handle);\n \t}\n-\n-\tif (num_registers > 1)\n-\t{\n-\t\tcol_append_str(pinfo->cinfo, COL_INFO, \"[Multiple Register Write Command]\");\n-\t}\n-\telse\n-\t{\n-\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \"%s Value=0x%08X\", address_string, value);\n-\t}\n-\n-\tif (gvcp_telegram_tree != NULL)\n+    /* Reset global count for each WRITEREG_CMD */\n+    gvcp_register_count = 0;\n+\n+    /* Sanity-check the number of registers against our fixed array capacity */\n+    if (num_registers > GVCP_MAX_REGISTER_COUNT) {\n+        proto_tree_add_expert_format(\n+            gvcp_telegram_tree, NULL, &ei_gvcp_excessive_register_count,\n+            tvb, offset, 4,\n+            \"Too many registers in Write Register command (%u > %u); truncating\",\n+            num_registers, GVCP_MAX_REGISTER_COUNT);\n+        num_registers = GVCP_MAX_REGISTER_COUNT;\n+    }\n+\n+    if (num_registers > 1)\n+    {\n+        col_append_str(pinfo->cinfo, COL_INFO, \"[Multiple Register Write Command]\");\n+    }\n+    else\n+    {\n+        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s Value=0x%08X\", address_string, value);\n+    }\n+\n+    if (gvcp_telegram_tree != NULL)\n \t{\n \t\tif (num_registers > 1)\n \t\t{\n@@ -2863,9 +2882,10 @@\n \n void proto_register_gvcp(void)\n {\n-\tstatic ei_register_info ei[] = {\n-\t\t{ &ei_gvcp_privileged_register, { \"gvcp.privileged_register\", PI_UNDECODED, PI_WARN, \"Privileged GVCP Register\", EXPFILL }},\n-\t};\n+    static ei_register_info ei[] = {\n+        { &ei_gvcp_privileged_register, { \"gvcp.privileged_register\", PI_UNDECODED, PI_WARN, \"Privileged GVCP Register\", EXPFILL }},\n+        { &ei_gvcp_excessive_register_count, { \"gvcp.excessive_register_count\", PI_UNDECODED, PI_WARN, \"Excessive GVCP Register count\", EXPFILL }},\n+    };\n \n \tstatic hf_register_info hf[] =\n \t{\n",
  "stdout": "",
  "stderr": ""
}