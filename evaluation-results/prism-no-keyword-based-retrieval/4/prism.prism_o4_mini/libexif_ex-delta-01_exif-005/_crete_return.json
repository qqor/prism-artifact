{
  "project_name": "libexif",
  "vulnerability_identifier": "libexif_ex-delta-01_exif-005",
  "source_directory": "/home/qqor/crete/.cache/official-afc-libexif",
  "llm_usage": {
    "total_cost": 0.1947869,
    "prompt_tokens": 84547,
    "completion_tokens": 23133
  },
  "variant": "sound",
  "diff": "--- a/libexif/apple/exif-mnote-data-apple.c\n+++ b/libexif/apple/exif-mnote-data-apple.c\n@@ -62,7 +62,7 @@\n \n     /*printf(\"%s\\n\", __FUNCTION__);*/\n \n-    if (!d || !buf || (buf_size < 6 + 16)) {\n+    if (!d || !buf || buf_size < 6 + 16) {\n         exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n                  \"ExifMnoteDataApple\", \"Short MakerNote\");\n         return;\n@@ -70,6 +70,13 @@\n \n     /* Start of interesting data */\n     ofs = d->offset + 6;\n+\n+    /* Need at least 16 bytes after ofs for byte order and entry count */\n+    if (buf_size < ofs + 16) {\n+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+                 \"ExifMnoteDataApple\", \"Short MakerNote\");\n+        return;\n+    }\n \n     if ((buf[ofs + 12] == 'M') && (buf[ofs + 13] == 'M')) {\n         d->order = EXIF_BYTE_ORDER_MOTOROLA;\n@@ -78,17 +85,20 @@\n     } else {\n         exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n                 \"ExifMnoteDataApple\", \"Unrecognized byte order\");\n-        /*printf(\"%s(%d)\\n\", __FUNCTION__, __LINE__);*/\n-        return;\n-    }\n-\n+        return;\n+    }\n+\n+    /* Read number of entries */\n     tcount = (unsigned int) exif_get_short(buf + ofs + 14, d->order);\n \n-    /* Sanity check the offset */\n-    if (buf_size < 6 + 16 + tcount * 6 + 4) {\n+    /* Define entry layout and check total size: header + entries + trailing */\n+    const size_t ENTRY_SIZE = 12;\n+    const size_t header_size = 6 + 16;\n+    const size_t entries_offset = ofs + 16;\n+    const size_t trailing = 4;\n+    if (buf_size < header_size + (size_t)tcount * ENTRY_SIZE + trailing) {\n         exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n                  \"ExifMnoteDataApple\", \"Short MakerNote\");\n-        /*printf(\"%s(%d)\\n\", __FUNCTION__, __LINE__);*/\n         return;\n     }\n \n@@ -107,13 +117,21 @@\n     }\n \n     for (i = 0; i < tcount; i++) {\n-        d->entries[i].tag = exif_get_short(buf + ofs, d->order);\n-        d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);\n-        d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);\n+        /* Bounds-check each 12-byte entry */\n+        size_t this_entry_end = entries_offset + (i + 1) * ENTRY_SIZE;\n+        if (this_entry_end > buf_size) {\n+            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+                     \"ExifMnoteDataApple\", \"Corrupt MakerNote entry\");\n+            return;\n+        }\n+        unsigned char *p = buf + entries_offset + i * ENTRY_SIZE;\n+        d->entries[i].tag = exif_get_short(p + 0, d->order);\n+        d->entries[i].format = exif_get_short(p + 2, d->order);\n+        d->entries[i].components = exif_get_long(p + 4, d->order);\n         d->entries[i].order = d->order;\n         dsize = exif_format_get_size(d->entries[i].format) * d->entries[i].components;\n         if (dsize > 4) {\n-            dofs = d->offset + exif_get_long(buf + ofs + 8, d->order);\n+            dofs = d->offset + exif_get_long(p + 8, d->order);\n         } else {\n             dofs = ofs + 8;\n         }\n",
  "stdout": "",
  "stderr": ""
}