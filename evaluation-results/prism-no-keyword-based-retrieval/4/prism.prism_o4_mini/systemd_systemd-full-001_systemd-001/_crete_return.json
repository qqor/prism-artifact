{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd_systemd-full-001_systemd-001",
  "source_directory": "/home/qqor/crete/.cache/official-afc-systemd",
  "llm_usage": {
    "total_cost": 1.4792404000000001,
    "prompt_tokens": 656812,
    "completion_tokens": 171988
  },
  "variant": "sound",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -1184,7 +1184,7 @@\n                  * The return value must be terminated by two subsequent NULs\n                  * so it could be safely interpreted as nulstr.\n                  */\n-                if (is_prefix_match){\n+                if (is_prefix_match) {\n                         j[0] = '*';\n                         j[1] = '\\0';\n                         j[2] = '\\0';\n@@ -1192,10 +1192,12 @@\n                         j[0] = '\\0';\n                         j[1] = '\\0';\n                 }\n-                str = m;            \n+                str = m;\n         } else {\n                 _cleanup_free_ char *unescaped = NULL;\n                 ssize_t l;\n+                char *write_ptr, *end;\n+                size_t available, need;\n \n                 /* find the end position of value */\n                 for (i = m + 1; *i != '\"'; i++) {\n@@ -1205,31 +1207,33 @@\n                                 return -EINVAL;\n                 }\n \n+                /* unescape into temporary buffer */\n                 l = cunescape_length(m + 1, i - (m + 1), 0, &unescaped);\n                 if (l < 0)\n                         return l;\n \n-                assert(l <= i - (m + 1));\n-\n-                /*\n-                * The return value must be terminated by two subsequent NULs\n-                * so it could be safely interpreted as nulstr.\n-                */\n-                if (is_prefix_match){\n-                        /* need more room to make rule glob match */\n-                        memcpy(str + pos - 1, unescaped, l + 1);\n-                        str[pos + l - 1] = '*';\n-                        str[pos + l] = '\\0';\n-                        str[pos + l + 1] = '\\0';\n-                        m = str + pos - 1;\n-\n+                /* prepare for in-place write */\n+                write_ptr = m;\n+                end = write_ptr + strlen(write_ptr);\n+                available = (size_t)(end - write_ptr);\n+                need = (size_t)l + (is_prefix_match ? 3 : 2);\n+                if (available < need)\n+                        return -EINVAL;\n+\n+                /* copy unescaped data in-place */\n+                memmove(write_ptr, unescaped, l);\n+\n+                /* append suffix */\n+                if (is_prefix_match) {\n+                        write_ptr[l]     = '*';\n+                        write_ptr[l + 1] = '\\0';\n+                        write_ptr[l + 2] = '\\0';\n                 } else {\n-                        memcpy(m, unescaped, l + 1);\n-                        m[l] = '\\0';\n-                        m[l + 1] = '\\0';\n-                }\n+                        write_ptr[l]     = '\\0';\n+                        write_ptr[l + 1] = '\\0';\n+                }\n+\n                 str = m;\n-\n         }\n \n         *ret_value = str;\n",
  "stdout": "",
  "stderr": ""
}