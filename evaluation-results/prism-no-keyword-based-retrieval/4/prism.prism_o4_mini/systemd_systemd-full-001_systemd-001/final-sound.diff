--- a/src/udev/udev-rules.c
+++ b/src/udev/udev-rules.c
@@ -1184,7 +1184,7 @@
                  * The return value must be terminated by two subsequent NULs
                  * so it could be safely interpreted as nulstr.
                  */
-                if (is_prefix_match){
+                if (is_prefix_match) {
                         j[0] = '*';
                         j[1] = '\0';
                         j[2] = '\0';
@@ -1192,10 +1192,12 @@
                         j[0] = '\0';
                         j[1] = '\0';
                 }
-                str = m;            
+                str = m;
         } else {
                 _cleanup_free_ char *unescaped = NULL;
                 ssize_t l;
+                char *write_ptr, *end;
+                size_t available, need;
 
                 /* find the end position of value */
                 for (i = m + 1; *i != '"'; i++) {
@@ -1205,31 +1207,33 @@
                                 return -EINVAL;
                 }
 
+                /* unescape into temporary buffer */
                 l = cunescape_length(m + 1, i - (m + 1), 0, &unescaped);
                 if (l < 0)
                         return l;
 
-                assert(l <= i - (m + 1));
-
-                /*
-                * The return value must be terminated by two subsequent NULs
-                * so it could be safely interpreted as nulstr.
-                */
-                if (is_prefix_match){
-                        /* need more room to make rule glob match */
-                        memcpy(str + pos - 1, unescaped, l + 1);
-                        str[pos + l - 1] = '*';
-                        str[pos + l] = '\0';
-                        str[pos + l + 1] = '\0';
-                        m = str + pos - 1;
-
+                /* prepare for in-place write */
+                write_ptr = m;
+                end = write_ptr + strlen(write_ptr);
+                available = (size_t)(end - write_ptr);
+                need = (size_t)l + (is_prefix_match ? 3 : 2);
+                if (available < need)
+                        return -EINVAL;
+
+                /* copy unescaped data in-place */
+                memmove(write_ptr, unescaped, l);
+
+                /* append suffix */
+                if (is_prefix_match) {
+                        write_ptr[l]     = '*';
+                        write_ptr[l + 1] = '\0';
+                        write_ptr[l + 2] = '\0';
                 } else {
-                        memcpy(m, unescaped, l + 1);
-                        m[l] = '\0';
-                        m[l + 1] = '\0';
-                }
+                        write_ptr[l]     = '\0';
+                        write_ptr[l + 1] = '\0';
+                }
+
                 str = m;
-
         }
 
         *ret_value = str;
