{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_6",
  "source_directory": "/home/qqor/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 0.5511165000000001,
    "prompt_tokens": 229635,
    "completion_tokens": 67845
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n@@ -66,6 +66,16 @@\n     private static final int EOF_MARKER = 0x03;\n \n     /**\n+     * Carriage return (CR) byte value.\n+     */\n+    private static final int CARRIAGE_RETURN = 0x0D;\n+\n+    /**\n+     * Line feed (LF) byte value.\n+     */\n+    private static final int LINE_FEED = 0x0A;\n+\n+    /**\n      * Heuristically chosen max length to buffer a Type1 font\n      */\n     private static final long MAX_LENGTH = 100_000_000;\n@@ -100,10 +110,12 @@\n      * @param in   The input.\n      * @throws IOException if an IO-error occurs.\n      */\n-    public PfbParser(final InputStream in) throws IOException \n-    {\n-        byte[] pfb = in.readAllBytes();\n-        parsePfb(pfb);\n+    public PfbParser(final java.io.InputStream in) throws IOException\n+    {\n+        try (java.io.BufferedInputStream bin = new java.io.BufferedInputStream(in))\n+        {\n+            parsePfbStream(bin);\n+        }\n     }\n \n     /**\n@@ -113,33 +125,44 @@\n      */\n     public PfbParser(final byte[] bytes) throws IOException\n     {\n-        parsePfb(bytes);\n-    }\n-\n-    /**\n-     * Parse the pfb-array.\n-     * @param pfb   The pfb-Array\n-     * @throws IOException in an IO-error occurs.\n-     */\n-    private void parsePfb(final byte[] pfb) throws IOException \n-    {\n-        if (pfb.length < PFB_HEADER_LENGTH)\n+        try (java.io.ByteArrayInputStream bais = new java.io.ByteArrayInputStream(bytes))\n+        {\n+            parsePfbStream(bais);\n+        }\n+    }\n+\n+    /**\n+     * Stream-based PFB parser that enforces MAX_LENGTH and processes segments inline.\n+     * @param in InputStream of PFB data.\n+     * @throws IOException if an IO-error occurs.\n+     */\n+    private void parsePfbStream(java.io.InputStream in) throws IOException\n+    {\n+        // ensure minimal header bytes are present\n+        if (!in.markSupported())\n+        {\n+            in = new java.io.BufferedInputStream(in);\n+        }\n+        in.mark(PFB_HEADER_LENGTH);\n+        byte[] header = new byte[PFB_HEADER_LENGTH];\n+        int h = in.read(header);\n+        if (h < PFB_HEADER_LENGTH)\n         {\n             throw new IOException(\"PFB header missing\");\n         }\n-        // read into segments and keep them\n-        List<Integer> typeList = new ArrayList<>(3);\n-        List<byte[]> barrList = new ArrayList<>(3);\n-        ByteArrayInputStream in = new ByteArrayInputStream(pfb);\n-        int total = 0;\n-        do\n-        {\n-            int r = in.read();\n-            if (r == -1 && total > 0)\n-            {\n-                break; // EOF\n-            }\n-            if (r != START_MARKER) \n+        in.reset();\n+\n+        long total = 0;\n+        java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream((int)Math.min(MAX_LENGTH, Integer.MAX_VALUE));\n+        byte[] buf = new byte[8192];\n+        while (true)\n+        {\n+            int marker = in.read();\n+            if (marker == -1)\n+            {\n+                break;\n+            }\n+            if (marker != START_MARKER)\n             {\n                 throw new IOException(\"Start marker missing\");\n             }\n@@ -152,72 +175,86 @@\n             {\n                 throw new IOException(\"Incorrect record type: \" + recordType);\n             }\n-\n-            int size = in.read();\n-            size += in.read() << 8;\n-            size += in.read() << 16;\n-            size += in.read() << 24;\n-            LOG.debug(\"record type: {}, segment size: {}\", recordType, size);\n+            long size = readUint32LE(in);\n             long newTotal = total + size;\n-            if (newTotal > MAX_LENGTH) {\n-                throw new IOException(\"record size would be too large: \" + newTotal);\n-            }\n-\n-            byte[] ar = new byte[size];\n-            int got = in.read(ar);\n-            if (got != size)\n-            {\n-                throw new EOFException(\"EOF while reading PFB font\");\n-            }\n-            total += size;\n-            typeList.add(recordType);\n-            barrList.add(ar);\n-        }\n-        while (true);\n-        \n-        // We now have ASCII and binary segments. Lets arrange these so that the ASCII segments\n-        // come first, then the binary segments, then the last ASCII segment if it is\n-        // 0000... cleartomark\n-        \n-        pfbdata = new byte[total];\n-        byte[] cleartomarkSegment = null;\n-        int dstPos = 0;\n-        \n-        // copy the ASCII segments\n-        for (int i = 0; i < typeList.size(); ++i)\n-        {\n-            if (typeList.get(i) != ASCII_MARKER)\n-            {\n-                continue;\n-            }\n-            byte[] ar = barrList.get(i);\n-            if (i == typeList.size() - 1 && ar.length < 600 && new String(ar).contains(\"cleartomark\"))\n-            {\n-                cleartomarkSegment = ar;\n-                continue;\n-            }\n-            System.arraycopy(ar, 0, pfbdata, dstPos, ar.length);\n-            dstPos += ar.length;\n-        }\n-        lengths[0] = dstPos;\n-\n-        // copy the binary segments\n-        for (int i = 0; i < typeList.size(); ++i)\n-        {\n-            if (typeList.get(i) != BINARY_MARKER)\n-            {\n-                continue;\n-            }\n-            byte[] ar = barrList.get(i);\n-            System.arraycopy(ar, 0, pfbdata, dstPos, ar.length);\n-            dstPos += ar.length;\n-        }\n-        lengths[1] = dstPos - lengths[0];\n-        \n-        if (cleartomarkSegment != null)\n-        {\n-            System.arraycopy(cleartomarkSegment, 0, pfbdata, dstPos, cleartomarkSegment.length);\n-            lengths[2] = cleartomarkSegment.length;\n+            if (newTotal > MAX_LENGTH)\n+            {\n+                throw new IOException(\"PFB data exceeds maximum allowed length: \" + newTotal);\n+            }\n+            if (recordType == BINARY_MARKER)\n+            {\n+                copyFully(in, out, size, buf);\n+            }\n+            else\n+            {\n+                clearToMarkStream(in, out, size, buf);\n+            }\n+            total = newTotal;\n+        }\n+        this.pfbdata = out.toByteArray();\n+        // populate lengths: ascii=0, binary=data length, trailing ascii=0\n+        this.lengths[0] = 0;\n+        this.lengths[1] = (int) total;\n+        this.lengths[2] = 0;\n+    }\n+\n+    private static long readUint32LE(java.io.InputStream in) throws IOException\n+    {\n+        int b0 = in.read();\n+        int b1 = in.read();\n+        int b2 = in.read();\n+        int b3 = in.read();\n+        if ((b0 | b1 | b2 | b3) < 0)\n+        {\n+            throw new IOException(\"Unable to read PFB segment size\");\n+        }\n+        return ((long)b0 & 0xFFL)\n+             | (((long)b1 & 0xFFL) << 8)\n+             | (((long)b2 & 0xFFL) << 16)\n+             | (((long)b3 & 0xFFL) << 24);\n+    }\n+\n+    private static void copyFully(java.io.InputStream in, java.io.ByteArrayOutputStream out, long size, byte[] buf) throws IOException\n+    {\n+        long remaining = size;\n+        while (remaining > 0)\n+        {\n+            int toRead = (int)Math.min(buf.length, remaining);\n+            int n = in.read(buf, 0, toRead);\n+            if (n == -1)\n+            {\n+                throw new IOException(\"Unexpected EOF in binary segment\");\n+            }\n+            out.write(buf, 0, n);\n+            remaining -= n;\n+        }\n+    }\n+\n+    private static void clearToMarkStream(java.io.InputStream in, java.io.ByteArrayOutputStream out, long size, byte[] buf) throws IOException\n+    {\n+        long remaining = size;\n+        while (remaining > 0)\n+        {\n+            int toRead = (int)Math.min(buf.length, remaining);\n+            int n = in.read(buf, 0, toRead);\n+            if (n == -1)\n+            {\n+                throw new IOException(\"Unexpected EOF in ASCII segment\");\n+            }\n+            for (int i = 0; i < n; ++i)\n+            {\n+                byte b = buf[i];\n+                if (b != CARRIAGE_RETURN && b != LINE_FEED)\n+                {\n+                    out.write(b);\n+                }\n+            }\n+            remaining -= n;\n+        }\n+        int mark = in.read();\n+        if (mark != ASCII_MARKER)\n+        {\n+            throw new IOException(\"Missing end-of-ASCII marker\");\n         }\n     }\n \n",
  "stdout": "",
  "stderr": ""
}