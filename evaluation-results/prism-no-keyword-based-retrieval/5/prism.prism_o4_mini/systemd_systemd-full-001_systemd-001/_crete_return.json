{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd_systemd-full-001_systemd-001",
  "source_directory": "/home/qqor/crete/.cache/official-afc-systemd",
  "llm_usage": {
    "total_cost": 1.31109,
    "prompt_tokens": 568884,
    "completion_tokens": 155754
  },
  "variant": "vulnerable",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -1171,68 +1171,45 @@\n         \n         m = str + is_escaped + is_case_insensitive + is_prefix_match;\n \n-        if (!is_escaped) {\n-                /* unescape double quotation '\\\"'->'\"' */\n-                for (j = m, i = m + 1; *i != '\"'; i++, j++) {\n-                        if (*i == '\\0')\n-                                return -EINVAL;\n-                        if (i[0] == '\\\\' && i[1] == '\"')\n-                                i++;\n-                        *j = *i;\n-                }\n-                /*\n-                 * The return value must be terminated by two subsequent NULs\n-                 * so it could be safely interpreted as nulstr.\n-                 */\n-                if (is_prefix_match){\n-                        j[0] = '*';\n-                        j[1] = '\\0';\n-                        j[2] = '\\0';\n-                } else {\n-                        j[0] = '\\0';\n-                        j[1] = '\\0';\n-                }\n-                str = m;            \n-        } else {\n-                _cleanup_free_ char *unescaped = NULL;\n-                ssize_t l;\n-\n-                /* find the end position of value */\n-                for (i = m + 1; *i != '\"'; i++) {\n-                        if (i[0] == '\\\\')\n-                                i++;\n-                        if (*i == '\\0')\n-                                return -EINVAL;\n-                }\n-\n-                l = cunescape_length(m + 1, i - (m + 1), 0, &unescaped);\n-                if (l < 0)\n-                        return l;\n-\n-                assert(l <= i - (m + 1));\n-\n-                /*\n-                * The return value must be terminated by two subsequent NULs\n-                * so it could be safely interpreted as nulstr.\n-                */\n-                if (is_prefix_match){\n-                        /* need more room to make rule glob match */\n-                        memcpy(str + pos - 1, unescaped, l + 1);\n-                        str[pos + l - 1] = '*';\n-                        str[pos + l] = '\\0';\n-                        str[pos + l + 1] = '\\0';\n-                        m = str + pos - 1;\n-\n-                } else {\n-                        memcpy(m, unescaped, l + 1);\n-                        m[l] = '\\0';\n-                        m[l + 1] = '\\0';\n-                }\n-                str = m;\n-\n-        }\n-\n-        *ret_value = str;\n+        /* find the end of the quoted value */\n+        for (i = m + 1; ; ) {\n+            if (*i == '\\0')\n+                return -EINVAL;\n+            if (i[0] == '\\\\' && i[1] == '\"') {\n+                i += 2;\n+                continue;\n+            }\n+            if (*i == '\"')\n+                break;\n+            i++;\n+        }\n+\n+        /* compute unescaped length */\n+        _cleanup_free_ char *unescaped = NULL;\n+        ssize_t l = cunescape_length(m + 1,\n+                                     i - (m + 1),\n+                                     is_escaped ? UNESCAPE_RELAX : 0,\n+                                     &unescaped);\n+        if (l < 0)\n+            return (int)l;\n+\n+        /* allocate output buffer */\n+        size_t extra = is_prefix_match ? 3U : 2U;\n+        size_t out_size = (size_t)l + extra;\n+        char *out_buf = malloc(out_size);\n+        if (!out_buf)\n+            return -ENOMEM;\n+\n+        /* copy unescaped data */\n+        memcpy(out_buf, unescaped, (size_t)l);\n+        if (is_prefix_match)\n+            out_buf[l++] = '*';\n+\n+        /* append two NUL terminators */\n+        out_buf[l++] = '\\0';\n+        out_buf[l++] = '\\0';\n+\n+        *ret_value = out_buf;\n         *ret_endpos = i + 1;\n         *ret_is_case_insensitive = is_case_insensitive;\n         return 0;\n",
  "stdout": "+ FUZZER=fuzz-udev-rule-parse-value\r\n+ shift\r\n+ '[' '!' -v TESTCASE ']'\r\n+ TESTCASE=/testcase\r\n+ '[' '!' -f /testcase ']'\r\n+ export RUN_FUZZER_MODE=interactive\r\n+ RUN_FUZZER_MODE=interactive\r\n+ export FUZZING_ENGINE=libfuzzer\r\n+ FUZZING_ENGINE=libfuzzer\r\n+ export SKIP_SEED_CORPUS=1\r\n+ SKIP_SEED_CORPUS=1\r\n+ run_fuzzer fuzz-udev-rule-parse-value -runs=100 /testcase\r\nvm.mmap_rnd_bits = 28\r\n/out/fuzz-udev-rule-parse-value -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\r\nINFO: Running with entropic power schedule (0xFF, 100).\r\nINFO: Seed: 2339452723\r\nINFO: Loaded 2 modules   (100216 inline 8-bit counters): 94611 [0x7f93e07dd920, 0x7f93e07f4ab3), 5605 [0x55b03c2f84e8, 0x55b03c2f9acd), \r\nINFO: Loaded 2 PC tables (100216 PCs): 94611 [0x7f93e07f4ab8,0x7f93e09663e8), 5605 [0x55b03c2f9ad0,0x55b03c30f920), \r\n/out/fuzz-udev-rule-parse-value: Running 1 inputs 100 time(s) each.\r\nRunning: /testcase\r\n\r\n=================================================================\r\n==18==ERROR: LeakSanitizer: detected memory leaks\r\n\r\nDirect leak of 4 byte(s) in 1 object(s) allocated from:\r\n    #0 0x55b03c1178cf in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:68:3\r\n    #1 0x55b03c157c12 in udev_rule_parse_value /work/build/../../src/systemd/src/udev/udev-rules.c:1199:25\r\n    #2 0x55b03c1570fe in LLVMFuzzerTestOneInput /work/build/../../src/systemd/src/udev/fuzz-udev-rule-parse-value.c:22:13\r\n    #3 0x55b03c1ce720 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\r\n    #4 0x55b03c1b9995 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\r\n    #5 0x55b03c1bf42f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\r\n    #6 0x55b03c1ea6d2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\r\n    #7 0x7f93dfa17082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\r\n\r\nDEDUP_TOKEN: __interceptor_malloc--udev_rule_parse_value--LLVMFuzzerTestOneInput\r\nSUMMARY: AddressSanitizer: 4 byte(s) leaked in 1 allocation(s).\r\n\r\nINFO: a leak has been found in the initial corpus.\r\n\r\nINFO: to ignore leaks on libFuzzer side use -detect_leaks=0.\r\n\r\nsubprocess command returned a non-zero exit status: 77\n",
  "stderr": "INFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -i -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/crete/packages/python_oss_fuzz/.oss_fuzz/build/out/systemd:/out -v /tmp/tmpovck2_yt:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce fuzz-udev-rule-parse-value -runs=100.\n"
}