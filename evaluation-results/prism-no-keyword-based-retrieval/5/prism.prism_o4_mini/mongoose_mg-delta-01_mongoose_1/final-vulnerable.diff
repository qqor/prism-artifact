--- a/src/printf.c
+++ b/src/printf.c
@@ -25,12 +25,17 @@
 
 static void mg_pfn_iobuf_private(char ch, void *param, bool expand) {
   struct mg_iobuf *io = (struct mg_iobuf *) param;
-  if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);
-  if (io->len + 2 <= io->size) {
+  /* Ensure space for ch and terminating '\0' */
+  if (expand && io->len + 2 > io->size) {
+    mg_iobuf_resize(io, io->len + 2);
+  }
+  /* Write one character if there is room for ch and terminating '\0' */
+  if (io->len + 1 < io->size) {
     io->buf[io->len++] = (uint8_t) ch;
-    io->buf[io->len] = 0;
+    io->buf[io->len] = '\0';
   } else if (io->len < io->size) {
-    io->buf[io->len++] = 0;  // Guarantee to 0-terminate
+    /* Just zero-terminate if only room for '\0' */
+    io->buf[io->len] = '\0';
   }
 }
 

--- a/src/fmt.c
+++ b/src/fmt.c
@@ -315,17 +315,18 @@
         for (j = 0; minus && pr < w && j + pr < w; j++)
           n += scpy(out, param, &pad, 1);
       } else if (c == 'e' || c == 'E') {
-		  char tmp[8];
+          char mant[64];
+          char expbuf[16];
           double d = va_arg(*ap, double);
-          int64_t exponent = (int64_t)log10(my_fabs(d));
+          int64_t exponent = (int64_t) log10(my_fabs(d));
           double mantissa = d / power(10, exponent);
-          k = mg_dtoa(tmp, 10, mantissa, 8, c == 'e');
-          n += scpy(out, param, tmp, k);
+          k = mg_dtoa(mant, sizeof(mant), mantissa, pr >= 0 ? pr : 6, c == 'e');
+          n += scpy(out, param, mant, k);
           out(c, param);
           n++;
-		  k = mg_lld(tmp, exponent, 1, 0);
-          n += scpy(out, param, tmp, k);
-	  } else if (c == '%') {
+          k = mg_lld(expbuf, exponent, true, false);
+          n += scpy(out, param, expbuf, k);
+      } else if (c == '%') {
         out('%', param);
         n++;
       } else {
