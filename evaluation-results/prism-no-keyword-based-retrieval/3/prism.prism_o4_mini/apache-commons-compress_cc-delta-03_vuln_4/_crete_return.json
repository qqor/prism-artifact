{
  "project_name": "apache-commons-compress",
  "vulnerability_identifier": "apache-commons-compress_cc-delta-03_vuln_4",
  "source_directory": "/home/qqor/crete/.cache/official-afc-commons-compress",
  "llm_usage": {
    "total_cost": 0.6736906000000001,
    "prompt_tokens": 466834,
    "completion_tokens": 36403
  },
  "variant": "sound",
  "diff": "--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -49,6 +49,9 @@\n \n     static final ZipEncoding DEFAULT_ENCODING = ZipEncodingHelper.getZipEncoding(Charset.defaultCharset());\n \n+    /** Maximum allowed length of a single PAX header record (length field) in bytes */\n+    private static final int MAX_PAX_HEADER_LENGTH = 10 * 1024; // 10 KiB\n+\n     /**\n      * Encapsulates the algorithms used up to Commons Compress 1.3 as ZipEncoding.\n      */\n@@ -657,6 +660,10 @@\n                     break;\n                 }\n                 if (ch == ' ') { // End of length string\n+                    if (len < 3 || len > MAX_PAX_HEADER_LENGTH) {\n+                        throw new IOException(\"PAX header record length \" + len +\n+                            \" is invalid or exceeds maximum of \" + MAX_PAX_HEADER_LENGTH);\n+                    }\n                     // Get keyword\n                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                     while ((ch = inputStream.read()) != -1) {\n\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -219,7 +219,10 @@\n      * </p>\n      */\n     private static final Pattern PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN =\n-            Pattern.compile(\"-?\\\\d{1,19}(?:\\\\.\\\\d*)?\");\n+            Pattern.compile(\"-?\\\\d{1,19}(?:\\\\.\\\\d{0,9})?\");\n+\n+    /** Maximum allowed length of timestamp string: sign + 19 digits + dot + 9 digits = 30 */\n+    private static final int MAX_TIMESTAMP_LENGTH = 30;\n \n     private static FileTime fileTimeFromOptionalSeconds(final long seconds) {\n         return seconds <= 0 ? null : FileTimes.fromUnixTime(seconds);\n@@ -268,8 +271,9 @@\n \n     private static Instant parseInstantFromDecimalSeconds(final String value) throws IOException {\n         // Validate field values to prevent denial of service attacks with BigDecimal values (see JDK-6560193)\n-        if (!PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN.matcher(value).matches()) {\n-            throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\");\n+        if (value.length() > MAX_TIMESTAMP_LENGTH\n+                || !PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN.matcher(value).matches()) {\n+            throw new IOException(\"Corrupted PAX header. Time field is invalid or too long: '\" + value + \"'\");\n         }\n \n         final BigDecimal epochSeconds = new BigDecimal(value);\n",
  "stdout": "",
  "stderr": ""
}