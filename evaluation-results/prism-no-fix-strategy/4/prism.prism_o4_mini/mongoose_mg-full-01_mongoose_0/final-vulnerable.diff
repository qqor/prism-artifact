--- a/src/json.c
+++ b/src/json.c
@@ -127,7 +127,7 @@
   const char *s = json.buf;
   int len = (int) json.len;
   enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;
-  unsigned char nesting[MG_JSON_MAX_DEPTH];
+  unsigned char nesting[MG_JSON_MAX_NESTING];
   int i = 0;             // Current offset in `s`
   int j = 0;             // Offset in `s` we're looking for (return value)
   int depth = 0;         // Current depth (nesting level)
@@ -165,7 +165,7 @@
         if (depth == ed) j = i;
         if (c == '{') {
           if (depth > MG_JSON_MAX_NESTING) return MG_JSON_TOO_DEEP;
-          if (depth == ed && path[pos] == '.' && ci == ei) {
+          if (depth >= MG_JSON_MAX_NESTING)
             // If we start the object, reset array indices
             ed++, pos++, ci = ei = -1;
           }
@@ -176,7 +176,7 @@
           if (depth > MG_JSON_MAX_NESTING) return MG_JSON_TOO_DEEP;
           if (depth == ed && path[pos] == '[' && ei == ci) {
             ed++, pos++, ci = 0;
-            for (ei = 0; path[pos] != ']' && path[pos] != '\0'; pos++) {
+          if (depth >= MG_JSON_MAX_NESTING)
               ei *= 10;
               ei += path[pos] - '0';
             }

--- a/test/tls_multirec/patched_mongoose.c
+++ b/test/tls_multirec/patched_mongoose.c
@@ -2723,7 +2723,7 @@
   const char *s = json.buf;
   int len = (int) json.len;
   enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;
-  unsigned char nesting[MG_JSON_MAX_DEPTH];
+  unsigned char nesting[MG_JSON_MAX_NESTING];
   int i = 0;             // Current offset in `s`
   int j = 0;             // Offset in `s` we're looking for (return value)
   int depth = 0;         // Current depth (nesting level)
@@ -2760,7 +2760,8 @@
         // p("V %s [%.*s] %d %d %d %d\n", path, pos, path, depth, ed, ci, ei);
         if (depth == ed) j = i;
         if (c == '{') {
-          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;
+          if (depth >= MG_JSON_MAX_NESTING)
+            return MG_JSON_TOO_DEEP;
           if (depth == ed && path[pos] == '.' && ci == ei) {
             // If we start the object, reset array indices
             ed++, pos++, ci = ei = -1;
@@ -2769,7 +2770,8 @@
           expecting = S_KEY;
           break;
         } else if (c == '[') {
-          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;
+          if (depth >= MG_JSON_MAX_NESTING)
+            return MG_JSON_TOO_DEEP;
           if (depth == ed && path[pos] == '[' && ei == ci) {
             ed++, pos++, ci = 0;
             for (ei = 0; path[pos] != ']' && path[pos] != '\0'; pos++) {
