--- a/src/json.c
+++ b/src/json.c
@@ -266,8 +266,7 @@
 
    for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)
    {
-      json_uchar uchar;
-      unsigned char uc_b1, uc_b2, uc_b3, uc_b4;
+        /* removed legacy Unicode escape parsing variables */
       json_char * string = 0;
       unsigned int string_length = 0;
 
@@ -302,81 +301,88 @@
                   case 'r':  string_add ('\r');  break;
                   case 't':  string_add ('\t');  break;
                   case 'u':
-
-                    if (end - state.ptr < 4 || 
-                        (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||
-                        (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||
-                        (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||
-                        (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)
+                    
                     {
-                        sprintf (error, "Invalid character value `%c` (at %d:%d)", b, line_and_col);
-                        goto e_failed;
-                    }
-
-                    uc_b1 = (uc_b1 << 4) | uc_b2;
-                    uc_b2 = (uc_b3 << 4) | uc_b4;
-                    uchar = (uc_b1 << 8) | uc_b2;
-
-                    if ((uchar & 0xF800) == 0xD800) {
-                        json_uchar uchar2;
-                        
-                        if (end - state.ptr < 6 || (*++ state.ptr) != '\\' || (*++ state.ptr) != 'u' ||
-                            (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||
-                            (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||
-                            (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||
-                            (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)
-                        {
-                            sprintf (error, "Invalid character value `%c` (at %d:%d)", b, line_and_col);
+                        /* decode Unicode escape (single code unit or surrogate pair) */
+                        const char *p = state.ptr;
+                        /* require '\u' + 4 hex digits */
+                        if (end - p < 5) {
+                            sprintf(error, "Invalid or incomplete '\\u' escape at %d:%d", line_and_col);
                             goto e_failed;
                         }
-
-                        uc_b1 = (uc_b1 << 4) | uc_b2;
-                        uc_b2 = (uc_b3 << 4) | uc_b4;
-                        uchar2 = (uc_b1 << 8) | uc_b2;
-                        
-                        uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);
-                    }
-
-                    if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))
-                    {
-                       string_add ((json_char) uchar);
-                       break;
-                    }
-
-                    if (uchar <= 0x7FF)
-                    {
-                        if (state.first_pass)
-                           string_length += 2;
-                        else
-                        {  string [string_length ++] = 0xC0 | (uchar >> 6);
-                           string [string_length ++] = 0x80 | (uchar & 0x3F);
+                        /* parse first code unit */
+                        unsigned char d1 = hex_value(*(p + 1));
+                        unsigned char d2 = hex_value(*(p + 2));
+                        unsigned char d3 = hex_value(*(p + 3));
+                        unsigned char d4 = hex_value(*(p + 4));
+                        if (d1 == 0xFF || d2 == 0xFF || d3 == 0xFF || d4 == 0xFF) {
+                            sprintf(error, "Invalid character value at %d:%d", line_and_col);
+                            goto e_failed;
                         }
-
+                        /* advance past the four hex digits */
+                        state.ptr = p + 4;
+                        /* assemble code point */
+                        json_uchar code = ((json_uchar)d1 << 12) |
+                                          ((json_uchar)d2 <<  8) |
+                                          ((json_uchar)d3 <<  4) |
+                                          (json_uchar)d4;
+                        /* handle UTF-16 surrogate pair */
+                        if ((code & 0xF800) == 0xD800) {
+                            const char *q = state.ptr;
+                            /* require '\u' + 4 hex digits */
+                            if (end - q < 7 || *(q + 1) != '\\' || *(q + 2) != 'u') {
+                                sprintf(error, "Invalid or incomplete surrogate '\\u' at %d:%d", line_and_col);
+                                goto e_failed;
+                            }
+                            unsigned char e1 = hex_value(*(q + 3));
+                            unsigned char e2 = hex_value(*(q + 4));
+                            unsigned char e3 = hex_value(*(q + 5));
+                            unsigned char e4 = hex_value(*(q + 6));
+                            if (e1 == 0xFF || e2 == 0xFF || e3 == 0xFF || e4 == 0xFF) {
+                                sprintf(error, "Invalid surrogate hex at %d:%d", line_and_col);
+                                goto e_failed;
+                            }
+                            state.ptr = q + 6;
+                            json_uchar low = ((json_uchar)e1 << 12) |
+                                             ((json_uchar)e2 <<  8) |
+                                             ((json_uchar)e3 <<  4) |
+                                             (json_uchar)e4;
+                            code = 0x10000 + (((code & 0x3FF) << 10) | (low & 0x3FF));
+                        }
+                        /* UTF-8 emit with two-pass length counting */
+                        if (code <= 0x7F) {
+                            if (state.first_pass) {
+                                string_length++;
+                            } else {
+                                string_add((json_char)code);
+                            }
+                        } else if (code <= 0x7FF) {
+                            if (state.first_pass) {
+                                string_length += 2;
+                            } else {
+                                string_add((json_char)(0xC0 | (code >> 6)));
+                                string_add((json_char)(0x80 | (code & 0x3F)));
+                            }
+                        } else if (code <= 0xFFFF) {
+                            if (state.first_pass) {
+                                string_length += 3;
+                            } else {
+                                string_add((json_char)(0xE0 | (code >> 12)));
+                                string_add((json_char)(0x80 | ((code >> 6) & 0x3F)));
+                                string_add((json_char)(0x80 | (code & 0x3F)));
+                            }
+                        } else {
+                            if (state.first_pass) {
+                                string_length += 4;
+                            } else {
+                                string_add((json_char)(0xF0 | (code >> 18)));
+                                string_add((json_char)(0x80 | ((code >> 12) & 0x3F)));
+                                string_add((json_char)(0x80 | ((code >> 6) & 0x3F)));
+                                string_add((json_char)(0x80 | (code & 0x3F)));
+                            }
+                        }
                         break;
                     }
-
-                    if (uchar <= 0xFFFF) {
-                        if (state.first_pass)
-                           string_length += 3;
-                        else
-                        {  string [string_length ++] = 0xE0 | (uchar >> 12);
-                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);
-                           string [string_length ++] = 0x80 | (uchar & 0x3F);
-                        }
-                        
-                        break;
-                    }
-
-                    if (state.first_pass)
-                       string_length += 4;
-                    else
-                    {  string [string_length ++] = 0xF0 | (uchar >> 18);
-                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);
-                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);
-                       string [string_length ++] = 0x80 | (uchar & 0x3F);
-                    }
-
-                    break;
 
                   default:
                      string_add (b);
