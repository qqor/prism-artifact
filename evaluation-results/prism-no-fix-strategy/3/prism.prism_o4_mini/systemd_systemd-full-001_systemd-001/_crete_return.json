{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd_systemd-full-001_systemd-001",
  "source_directory": "/home/qqor/aixcc/crete/.cache/official-afc-systemd",
  "llm_usage": {
    "total_cost": 0.35739550000000003,
    "prompt_tokens": 220685,
    "completion_tokens": 26055
  },
  "variant": "sound",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -5,6 +5,8 @@\n #include \"alloc-util.h\"\n #include \"architecture.h\"\n #include \"conf-files.h\"\n+#include <string.h>\n+#include <errno.h>\n #include \"conf-parser.h\"\n #include \"confidential-virt.h\"\n #include \"constants.h\"\n@@ -1140,7 +1142,8 @@\n int udev_rule_parse_value(char *str, char **ret_value, char **ret_endpos, bool *ret_is_case_insensitive) {\n         char *i, *j, *m;\n         bool is_escaped = false, is_case_insensitive = false, is_prefix_match = false;\n-        int pos = 0;\n+    int pos = 0;\n+    size_t orig_len = strlen(str);\n \n         assert(str);\n         assert(ret_value);\n@@ -1215,13 +1218,16 @@\n                 * The return value must be terminated by two subsequent NULs\n                 * so it could be safely interpreted as nulstr.\n                 */\n-                if (is_prefix_match){\n-                        /* need more room to make rule glob match */\n-                        memcpy(str + pos - 1, unescaped, l + 1);\n-                        str[pos + l - 1] = '*';\n-                        str[pos + l] = '\\0';\n-                        str[pos + l + 1] = '\\0';\n-                        m = str + pos - 1;\n+    if (is_prefix_match) {\n+        /* need more room to make rule glob match */\n+        /* ensure enough room for '*' and two terminating NUL bytes */\n+        if (pos + l + 2 > orig_len)\n+            return -EINVAL;\n+        memcpy(str + pos - 1, unescaped, l + 1);\n+        str[pos + l - 1] = '*';\n+        str[pos + l]     = '\\0';\n+        str[pos + l + 1] = '\\0';\n+        m = str + pos - 1;\n \n                 } else {\n                         memcpy(m, unescaped, l + 1);\n",
  "stdout": "",
  "stderr": ""
}