{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd_systemd-full-001_systemd-001",
  "source_directory": "/home/user/aixcc/crete/.cache/official-afc-systemd",
  "llm_usage": {
    "total_cost": 2.0688349,
    "prompt_tokens": 1700395,
    "completion_tokens": 45091
  },
  "variant": "sound",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -1,6 +1,16 @@\n /* SPDX-License-Identifier: GPL-2.0-or-later */\n \n-#include <ctype.h>\n+ #include \"udev-util.h\"\n+ \n+ /* Thread-local buffer to avoid per-call malloc and prevent leaks */\n+ static __thread char *udev_tls_buf = NULL;\n+ static __thread size_t udev_tls_buf_size = 0;\n+ static void udev_rule_free_tls_buf(void) __attribute__((destructor));\n+ static void udev_rule_free_tls_buf(void) {\n+     free(udev_tls_buf);\n+     udev_tls_buf = NULL;\n+     udev_tls_buf_size = 0;\n+ }\n \n #include \"alloc-util.h\"\n #include \"architecture.h\"\n@@ -1217,16 +1227,41 @@\n                 */\n                 if (is_prefix_match){\n                         /* need more room to make rule glob match */\n-                        memcpy(str + pos - 1, unescaped, l + 1);\n-                        str[pos + l - 1] = '*';\n-                        str[pos + l] = '\\0';\n-                        str[pos + l + 1] = '\\0';\n-                        m = str + pos - 1;\n+                        {\n+                                size_t out_len = l + 3; /* star + data + two NULs */\n+                                char *buf;\n+                                if (udev_tls_buf_size < out_len) {\n+                                        char *new_buf = realloc(udev_tls_buf, out_len);\n+                                        if (!new_buf)\n+                                                return -ENOMEM;\n+                                        udev_tls_buf = new_buf;\n+                                        udev_tls_buf_size = out_len;\n+                                }\n+                                buf = udev_tls_buf;\n+                                buf[0] = '*';\n+                                memcpy(buf + 1, unescaped, l);\n+                                buf[l + 1] = '\\0';\n+                                buf[l + 2] = '\\0';\n+                                m = buf;\n+                        }\n \n                 } else {\n-                        memcpy(m, unescaped, l + 1);\n-                        m[l] = '\\0';\n-                        m[l + 1] = '\\0';\n+                        {\n+                                size_t out_len = l + 2; /* data + two NULs */\n+                                char *buf;\n+                                if (udev_tls_buf_size < out_len) {\n+                                        char *new_buf = realloc(udev_tls_buf, out_len);\n+                                        if (!new_buf)\n+                                                return -ENOMEM;\n+                                        udev_tls_buf = new_buf;\n+                                        udev_tls_buf_size = out_len;\n+                                }\n+                                buf = udev_tls_buf;\n+                                memcpy(buf, unescaped, l);\n+                                buf[l] = '\\0';\n+                                buf[l + 1] = '\\0';\n+                                m = buf;\n+                        }\n                 }\n                 str = m;\n \n",
  "stdout": "",
  "stderr": ""
}