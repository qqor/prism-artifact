{
  "project_name": "apache-commons-compress",
  "vulnerability_identifier": "apache-commons-compress_cc-delta-03_vuln_4",
  "source_directory": "/home/qqor/aixcc/crete/.cache/official-afc-commons-compress",
  "llm_usage": {
    "total_cost": 1.5883460999999996,
    "prompt_tokens": 1273779,
    "completion_tokens": 42543
  },
  "variant": "sound",
  "diff": "--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -1075,7 +1075,9 @@\n      */\n     private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n         int read = 0;\n-        do {\n+        final int MAX_INFLATE_ATTEMPTS = 5;\n+        int attempts = 0;\n+        while (true) {\n             if (inf.needsInput()) {\n                 final int l = fill();\n                 if (l > 0) {\n@@ -1091,7 +1093,15 @@\n             } catch (final DataFormatException e) {\n                 throw (IOException) new ZipException(e.getMessage()).initCause(e);\n             }\n-        } while (read == 0 && inf.needsInput());\n+            if (read != 0 || inf.finished() || inf.needsInput()) {\n+                break;\n+            }\n+            if (++attempts > MAX_INFLATE_ATTEMPTS) {\n+                throw new IOException(\"Exceeded max inflate attempts (\"\n+                                      + MAX_INFLATE_ATTEMPTS\n+                                      + \"), aborting to prevent hang\");\n+            }\n+        }\n         return read;\n     }\n \n\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -271,15 +271,30 @@\n         if (!PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN.matcher(value).matches()) {\n             throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\");\n         }\n-\n-        final BigDecimal epochSeconds = new BigDecimal(value);\n-        final long seconds = epochSeconds.longValue();\n-        final long nanos = epochSeconds.remainder(BigDecimal.ONE).movePointRight(9).longValue();\n+        int dotIndex = value.indexOf('.');\n+        String secondsPart = (dotIndex < 0) ? value : value.substring(0, dotIndex);\n+        String nanosPart = (dotIndex < 0) ? \"\" : value.substring(dotIndex + 1);\n+        long seconds;\n+        try {\n+            seconds = Long.parseLong(secondsPart);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\", e);\n+        }\n+        int nanos = 0;\n+        if (!nanosPart.isEmpty()) {\n+            String frac = nanosPart.length() > 9 ? nanosPart.substring(0, 9) : nanosPart;\n+            while (frac.length() < 9) {\n+                frac += '0';\n+            }\n+            try {\n+                nanos = Integer.parseInt(frac);\n+            } catch (NumberFormatException e) {\n+                throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\", e);\n+            }\n+        }\n         try {\n             return Instant.ofEpochSecond(seconds, nanos);\n         } catch (DateTimeException | ArithmeticException e) {\n-            // DateTimeException: Thrown if the instant exceeds the maximum or minimum instant.\n-            // ArithmeticException: Thrown if numeric overflow occurs.\n             throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\", e);\n         }\n     }\n",
  "stdout": "",
  "stderr": ""
}