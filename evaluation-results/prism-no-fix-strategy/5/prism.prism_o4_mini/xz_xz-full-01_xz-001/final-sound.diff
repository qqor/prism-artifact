--- a/src/liblzma/check/treeck.c
+++ b/src/liblzma/check/treeck.c
@@ -86,10 +86,27 @@
   }
 
   // Free the node and edges
-  free(node->edges);
-  free(node);
+      // free(node->edges);  // deferred freeing removed to prevent use-after-free
+      // free(node);         // deferred freeing removed to prevent use-after-free
 
   return sum;
+} /* compute_tree_checksum */
+
+/* Recursively free the tree structure, skipping cycles via parent pointer */
+static void
+free_tree(TreeNode *node, TreeNode *parent)
+{
+    if (!node)
+        return;
+
+    for (size_t i = 0; i < node->edge_count; ++i) {
+        TreeNode *child = node->edges[i];
+        if (child && child != parent)
+            free_tree(child, node);
+    }
+
+    free(node->edges);
+    free(node);
 }
 
 extern LZMA_API(uint32_t)
@@ -98,6 +115,7 @@
   unsigned long seed = hash_data(buf, size);
   TreeNode *root = create_tree(buf, size, 0, 16, seed, NULL);
   checksum ^= compute_tree_checksum(root, 0);
+  free_tree(root, NULL);
   return checksum;
 }
 
