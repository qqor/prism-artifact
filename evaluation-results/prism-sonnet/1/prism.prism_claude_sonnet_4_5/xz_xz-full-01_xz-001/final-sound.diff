--- a/src/liblzma/check/treeck.h
+++ b/src/liblzma/check/treeck.h
@@ -14,6 +14,7 @@
 #define STATE_CLEAR   0
 #define STATE_VISITED 1
 #define STATE_HASHED  2
+#define STATE_FREED   3
 
 #define MAX_BLOCK_WIDTH  0x7fffffffull
 #define MAX_BLOCK_HEIGHT 0x7fffffffull

--- a/src/liblzma/check/treeck.c
+++ b/src/liblzma/check/treeck.c
@@ -85,11 +85,31 @@
     node->state = STATE_HASHED;
   }
 
-  // Free the node and edges
+  return sum;
+}
+
+// Free the tree nodes in post-order traversal
+static void free_tree_node(TreeNode *node)
+{
+  // Skip if already freed or NULL
+  if (!node || node->state == STATE_FREED) {
+    return;
+  }
+
+  // Mark as freed to prevent double-free in cyclic structures
+  node->state = STATE_FREED;
+
+  // Free all child nodes first
+  for (size_t i = 0; i < node->edge_count; ++i) {
+    TreeNode *child = node->edges[i];
+    if (child) {
+      free_tree_node(child);
+    }
+  }
+
+  // Free the edges array and the node itself
   free(node->edges);
   free(node);
-
-  return sum;
 }
 
 extern LZMA_API(uint32_t)
@@ -97,7 +117,12 @@
 {
   unsigned long seed = hash_data(buf, size);
   TreeNode *root = create_tree(buf, size, 0, 16, seed, NULL);
-  checksum ^= compute_tree_checksum(root, 0);
+  
+  if (root != NULL) {
+    checksum ^= compute_tree_checksum(root, 0);
+    free_tree_node(root);
+  }
+  
   return checksum;
 }
 
