{
  "project_name": "apache-poi",
  "vulnerability_identifier": "apache-poi_poi-delta-01_vuln_6",
  "source_directory": "/home/qqor/crete/.cache/official-afc-poi",
  "llm_usage": {
    "total_cost": 10.274504999999996,
    "prompt_tokens": 2940055,
    "completion_tokens": 96956
  },
  "variant": "sound",
  "diff": "--- a/poi/src/main/java/org/apache/poi/ss/formula/functions/Countif.java\n+++ b/poi/src/main/java/org/apache/poi/ss/formula/functions/Countif.java\n@@ -355,6 +355,15 @@\n                 return false;\n             }\n             String testedValue = ((StringEval) x).getStringValue();\n+            \n+            // Validate input length to prevent excessive resource consumption\n+            if (testedValue.length() > 10000) {\n+                throw new IllegalArgumentException(\n+                    \"Input text too long for pattern matching: \" + testedValue.length() + \n+                    \" characters (max 10000)\"\n+                );\n+            }\n+            \n             if (testedValue.length() < 1 && _value.length() < 1) {\n                 // odd case: criteria '=' behaves differently to criteria ''\n \n@@ -366,7 +375,16 @@\n                 return false;\n             }\n             if (_pattern != null) {\n-                return evaluate(_pattern.matcher(testedValue).matches());\n+                try {\n+                    return evaluate(_pattern.matcher(testedValue).matches());\n+                } catch (StackOverflowError e) {\n+                    throw new IllegalStateException(\n+                        \"Wildcard pattern caused stack overflow during matching. \" +\n+                        \"Pattern: '\" + _value + \"', input length: \" + testedValue.length() + \". \" +\n+                        \"Try simplifying the pattern or increase Java stack size with -Xss.\",\n+                        e\n+                    );\n+                }\n             }\n             // String criteria in COUNTIF are case insensitive:\n             // for example, the string \"apples\" and the string \"APPLES\" will match the same cells.\n@@ -378,20 +396,55 @@\n          */\n         public static Pattern getWildCardPattern(String value) {\n             int len = value.length();\n+            \n+            // Validate pattern length to prevent excessive resource consumption\n+            if (len > 1000) {\n+                throw new IllegalArgumentException(\n+                    \"Wildcard pattern too long: \" + len + \" characters (max 1000)\"\n+                );\n+            }\n+            \n             StringBuilder sb = new StringBuilder(len);\n             boolean hasWildCard = false;\n+            int wildcardCount = 0;\n+            boolean lastWasWildcardStar = false;\n+            \n             for(int i=0; i<len; i++) {\n                 char ch = value.charAt(i);\n                 switch(ch) {\n                     case '?':  //Any single character\n+                        if (lastWasWildcardStar) {\n+                            // Skip: .*+ already matches any single character\n+                            // This prevents patterns like .*+. which are redundant\n+                            continue;\n+                        }\n                         hasWildCard = true;\n+                        wildcardCount++;\n+                        if (wildcardCount > 50) {\n+                            throw new IllegalArgumentException(\n+                                \"Wildcard pattern too complex: more than 50 wildcards\"\n+                            );\n+                        }\n                         // match exactly one character\n                         sb.append('.');\n+                        lastWasWildcardStar = false;\n                         continue;\n                     case '*': //Zero or more characters\n+                        if (lastWasWildcardStar) {\n+                            // Skip: consecutive * wildcards are redundant\n+                            // This prevents patterns like .*+.*+ which cause deep recursion\n+                            continue;\n+                        }\n                         hasWildCard = true;\n-                        // match one or more occurrences of any character\n-                        sb.append(\".*\");\n+                        wildcardCount++;\n+                        if (wildcardCount > 50) {\n+                            throw new IllegalArgumentException(\n+                                \"Wildcard pattern too complex: more than 50 wildcards\"\n+                            );\n+                        }\n+                        // Use possessive quantifier to prevent backtracking\n+                        sb.append(\".*+\");\n+                        lastWasWildcardStar = true;\n                         continue;\n                     case '~':\n                         if (i+1<len) {\n@@ -399,14 +452,17 @@\n                             switch (ch) {\n                                 case '?':\n                                 case '*':\n-                                    hasWildCard = true;\n+                                    // DON'T set hasWildCard = true here!\n+                                    // Escaped wildcards are literal characters, not wildcards\n                                     sb.append('[').append(ch).append(']');\n                                     i++; // Note - incrementing loop variable here\n+                                    lastWasWildcardStar = false;\n                                     continue;\n                             }\n                         }\n                         // else not '~?' or '~*'\n                         sb.append('~'); // just plain '~'\n+                        lastWasWildcardStar = false;\n                         continue;\n                     case '.':\n                     case '$':\n@@ -417,9 +473,11 @@\n                     case ')':\n                         // escape literal characters that would have special meaning in regex\n                         sb.append(\"\\\\\").append(ch);\n+                        lastWasWildcardStar = false;\n                         continue;\n                 }\n                 sb.append(ch);\n+                lastWasWildcardStar = false;\n             }\n             if (hasWildCard) {\n                 return Pattern.compile(sb.toString(), Pattern.CASE_INSENSITIVE);\n\n--- a/poi-ooxml/src/main/java/org/apache/poi/xssf/extractor/XSSFEventBasedExcelExtractor.java\n+++ b/poi-ooxml/src/main/java/org/apache/poi/xssf/extractor/XSSFEventBasedExcelExtractor.java\n@@ -73,7 +73,7 @@\n     implements POIXMLTextExtractor, ExcelExtractor {\n \n     private static final Logger LOGGER = PoiLogManager.getLogger(XSSFEventBasedExcelExtractor.class);\n-    private static final Pattern MAJOR_VERSION_PATTERN = Pattern.compile(\"(-?(?:\\\\d{1,30})*)(?:\\\\.(\\\\dc?)*)\");\n+    private static final Pattern MAJOR_VERSION_PATTERN = Pattern.compile(\"^(-?\\\\d+)(?:\\\\.(\\\\d+))?\");\n     protected final OPCPackage container;\n     protected final POIXMLProperties properties;\n \n@@ -316,6 +316,10 @@\n             parser.parse(is, new ExtendedPropertiesHandler(text));\n         } catch (ParserConfigurationException | SAXException | IOException e) {\n             //swallow\n+        } catch (StackOverflowError e) {\n+            // Catch stack overflow from regex matching in ExtendedPropertiesHandler\n+            // Log warning and continue processing (extended properties are optional)\n+            LOGGER.atWarn().withThrowable(e).log(\"Failed to parse extended properties due to stack overflow\");\n         }\n     }\n \n@@ -526,9 +530,21 @@\n             if (appVersionString.isEmpty()) {\n                 return;\n             }\n-            Matcher m = MAJOR_VERSION_PATTERN.matcher(appVersionString);\n-            if (m.find()) {\n-                text.append(\"MajorVersion: \").append(m.group(1)).append(\"\\n\");\n+            // Validate length to prevent excessive resource consumption\n+            if (appVersionString.length() > 200) {\n+                // Just append the raw string without parsing if too long\n+                text.append(\"AppVersion (unparsed): \").append(appVersionString.substring(0, 200)).append(\"...\\n\");\n+                appVersionBuffer.setLength(0);\n+                return;\n+            }\n+            try {\n+                Matcher m = MAJOR_VERSION_PATTERN.matcher(appVersionString);\n+                if (m.find()) {\n+                    text.append(\"MajorVersion: \").append(m.group(1)).append(\"\\n\");\n+                }\n+            } catch (StackOverflowError e) {\n+                // If regex still causes issues, just output the raw version string\n+                text.append(\"AppVersion: \").append(appVersionString).append(\"\\n\");\n             }\n             appVersionBuffer.setLength(0);\n         }\n",
  "stdout": "",
  "stderr": ""
}