{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_8",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 3.2084070000000002,
    "prompt_tokens": 936329,
    "completion_tokens": 26628
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -219,7 +219,10 @@\n                             || lexer.peekToken().getText().equals(\"readonly\")\n                             || lexer.peekToken().getText().equals(\"def\"))))\n             {\n-                lexer.nextToken();\n+                if (lexer.nextToken() == null)\n+                {\n+                    throw new IOException(\"Unexpected EOF while looking for dup, readonly or def\");\n+                }\n             }\n             \n             Map<Integer, String> codeToName = new HashMap<>();\n@@ -640,7 +643,10 @@\n         while (!(lexer.peekKind(Token.LITERAL)\n                 && lexer.peekToken().getText().equals(\"CharStrings\")))\n         {\n-            lexer.nextToken();\n+            if (lexer.nextToken() == null)\n+            {\n+                throw new IOException(\"Unexpected EOF while looking for CharStrings\");\n+            }\n         }\n \n         // CharStrings dict\n@@ -707,6 +713,11 @@\n     {\n         // allocate size (array indexes may not be in-order)\n         int length = read(Token.INTEGER).intValue();\n+        if (length < 0 || length > 65535)\n+        {\n+            throw new IOException(\"Invalid Subrs array size: \" + length + \n+                    \". Must be between 0 and 65535\");\n+        }\n         for (int i = 0; i < length; i++)\n         {\n             font.subrs.add(null);\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n+import org.apache.fontbox.type1.DamagedFontException;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.LogManager;\n /**\n@@ -48,6 +49,7 @@\n      * Log instance.\n      */\n     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);\n+    private static final int MAX_CHAR_STRING_SIZE = 1_000_000;\n     \n     private final ByteBuffer buffer;\n     private Token aheadToken;\n@@ -501,6 +503,11 @@\n      */\n     private Token readCharString(int length) throws IOException\n     {\n+        if (length > MAX_CHAR_STRING_SIZE)\n+        {\n+            throw new DamagedFontException(\"char string is too long. length=\" +\n+                    length + \" max_length=\" + MAX_CHAR_STRING_SIZE);\n+        }\n         try\n         {\n             buffer.get(); // space\n\n--- a/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n@@ -158,7 +158,7 @@\n             size += in.read() << 16;\n             size += in.read() << 24;\n             LOG.debug(\"record type: {}, segment size: {}\", recordType, size);\n-            long newTotal = total + size;\n+            long newTotal = (long)total + (long)size;\n             if (newTotal > MAX_LENGTH) {\n                 throw new IOException(\"record size would be too large: \" + newTotal);\n             }\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n@@ -180,6 +180,7 @@\n     private final class PageIterator implements Iterator<PDPage>\n     {\n         private final Queue<COSDictionary> queue = new ArrayDeque<>();\n+        private final Set<COSDictionary> seen = new HashSet<>();\n \n         private PageIterator(COSDictionary node)\n         {\n@@ -205,6 +206,12 @@\n          */\n         private List<COSDictionary> enqueueKids(COSDictionary node)\n         {\n+            if (seen.contains(node))\n+            {\n+                LOG.warn(\"Found an infinite loop in the page tree\");\n+                return Collections.EMPTY_LIST;\n+            }\n+            seen.add(node);\n             if (isPageTreeNode(node))\n             {\n                 return getKids(node);\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n@@ -23,6 +23,7 @@\n import java.util.Map;\n import java.util.Optional;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n@@ -98,17 +99,19 @@\n         }\n         document.setStartXref(startXrefOffset);\n         long prev = startXrefOffset;\n-        //lastPrev prevents potential infinite loops in crafted files\n-        long lastPrev = -1;\n         // ---- parse whole chain of xref tables/object streams using PREV reference\n+        Set<Long> prevSet = new HashSet<>();\n         COSDictionary trailer = null;\n-        while (prev > 0 && prev != lastPrev)\n-        {\n-            lastPrev = prev;\n+        while (prev > 0)\n+        {\n+            // save expected position for loop detection\n+            prevSet.add(prev);\n             // seek to xref table\n             source.seek(prev);\n             // skip white spaces\n             parser.skipSpaces();\n+            // save current position as well due to skipped spaces\n+            prevSet.add(source.getPosition());\n             // -- parse xref\n             if (source.peek() == X)\n             {\n@@ -170,9 +173,9 @@\n                     trailer.setLong(COSName.PREV, prev);\n                 }\n             }\n-            if (prev == lastPrev)\n-            {\n-                throw new IOException(\"/Prev loop at offset \" + prev);\n+            if (prevSet.contains(prev))\n+            {\n+                throw new IOException(\"/Prev loop detected at offset \" + prev);\n             }\n         }\n         // ---- build valid xrefs out of the xref chain\n",
  "stdout": "",
  "stderr": ""
}