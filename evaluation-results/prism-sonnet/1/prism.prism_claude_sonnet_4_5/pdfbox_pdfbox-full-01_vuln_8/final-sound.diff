--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
@@ -219,7 +219,10 @@
                             || lexer.peekToken().getText().equals("readonly")
                             || lexer.peekToken().getText().equals("def"))))
             {
-                lexer.nextToken();
+                if (lexer.nextToken() == null)
+                {
+                    throw new IOException("Unexpected EOF while looking for dup, readonly or def");
+                }
             }
             
             Map<Integer, String> codeToName = new HashMap<>();
@@ -640,7 +643,10 @@
         while (!(lexer.peekKind(Token.LITERAL)
                 && lexer.peekToken().getText().equals("CharStrings")))
         {
-            lexer.nextToken();
+            if (lexer.nextToken() == null)
+            {
+                throw new IOException("Unexpected EOF while looking for CharStrings");
+            }
         }
 
         // CharStrings dict
@@ -707,6 +713,11 @@
     {
         // allocate size (array indexes may not be in-order)
         int length = read(Token.INTEGER).intValue();
+        if (length < 0 || length > 65535)
+        {
+            throw new IOException("Invalid Subrs array size: " + length + 
+                    ". Must be between 0 and 65535");
+        }
         for (int i = 0; i < length; i++)
         {
             font.subrs.add(null);

--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
+import org.apache.fontbox.type1.DamagedFontException;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.LogManager;
 /**
@@ -48,6 +49,7 @@
      * Log instance.
      */
     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);
+    private static final int MAX_CHAR_STRING_SIZE = 1_000_000;
     
     private final ByteBuffer buffer;
     private Token aheadToken;
@@ -501,6 +503,11 @@
      */
     private Token readCharString(int length) throws IOException
     {
+        if (length > MAX_CHAR_STRING_SIZE)
+        {
+            throw new DamagedFontException("char string is too long. length=" +
+                    length + " max_length=" + MAX_CHAR_STRING_SIZE);
+        }
         try
         {
             buffer.get(); // space

--- a/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java
@@ -158,7 +158,7 @@
             size += in.read() << 16;
             size += in.read() << 24;
             LOG.debug("record type: {}, segment size: {}", recordType, size);
-            long newTotal = total + size;
+            long newTotal = (long)total + (long)size;
             if (newTotal > MAX_LENGTH) {
                 throw new IOException("record size would be too large: " + newTotal);
             }

--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java
@@ -180,6 +180,7 @@
     private final class PageIterator implements Iterator<PDPage>
     {
         private final Queue<COSDictionary> queue = new ArrayDeque<>();
+        private final Set<COSDictionary> seen = new HashSet<>();
 
         private PageIterator(COSDictionary node)
         {
@@ -205,6 +206,12 @@
          */
         private List<COSDictionary> enqueueKids(COSDictionary node)
         {
+            if (seen.contains(node))
+            {
+                LOG.warn("Found an infinite loop in the page tree");
+                return Collections.EMPTY_LIST;
+            }
+            seen.add(node);
             if (isPageTreeNode(node))
             {
                 return getKids(node);

--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java
@@ -23,6 +23,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Map.Entry;
+import java.util.Set;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -98,17 +99,19 @@
         }
         document.setStartXref(startXrefOffset);
         long prev = startXrefOffset;
-        //lastPrev prevents potential infinite loops in crafted files
-        long lastPrev = -1;
         // ---- parse whole chain of xref tables/object streams using PREV reference
+        Set<Long> prevSet = new HashSet<>();
         COSDictionary trailer = null;
-        while (prev > 0 && prev != lastPrev)
-        {
-            lastPrev = prev;
+        while (prev > 0)
+        {
+            // save expected position for loop detection
+            prevSet.add(prev);
             // seek to xref table
             source.seek(prev);
             // skip white spaces
             parser.skipSpaces();
+            // save current position as well due to skipped spaces
+            prevSet.add(source.getPosition());
             // -- parse xref
             if (source.peek() == X)
             {
@@ -170,9 +173,9 @@
                     trailer.setLong(COSName.PREV, prev);
                 }
             }
-            if (prev == lastPrev)
-            {
-                throw new IOException("/Prev loop at offset " + prev);
+            if (prevSet.contains(prev))
+            {
+                throw new IOException("/Prev loop detected at offset " + prev);
             }
         }
         // ---- build valid xrefs out of the xref chain
