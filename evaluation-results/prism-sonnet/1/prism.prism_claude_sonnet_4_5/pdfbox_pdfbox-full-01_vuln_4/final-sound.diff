--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java
@@ -22,6 +22,7 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Optional;
+import java.util.Set;
 import java.util.Map.Entry;
 
 import org.apache.logging.log4j.LogManager;
@@ -98,13 +99,13 @@
         }
         document.setStartXref(startXrefOffset);
         long prev = startXrefOffset;
-        //lastPrev prevents potential infinite loops in crafted files
-        long lastPrev = -1;
+        // Track all visited offsets to prevent infinite loops in crafted files
+        Set<Long> visitedOffsets = new HashSet<>();
+        visitedOffsets.add(prev);
         // ---- parse whole chain of xref tables/object streams using PREV reference
         COSDictionary trailer = null;
-        while (prev > 0 && prev != lastPrev)
-        {
-            lastPrev = prev;
+        while (prev > 0)
+        {
             // seek to xref table
             source.seek(prev);
             // skip white spaces
@@ -169,10 +170,11 @@
                     prev = fixedOffset;
                     trailer.setLong(COSName.PREV, prev);
                 }
-            }
-            if (prev == lastPrev)
-            {
-                throw new IOException("/Prev loop at offset " + prev);
+                
+                if (!visitedOffsets.add(prev))
+                {
+                    throw new IOException("/Prev loop detected at offset " + prev);
+                }
             }
         }
         // ---- build valid xrefs out of the xref chain

--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
@@ -23,8 +23,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * Parses an Adobe Type 1 (.pfb) font. It is used exclusively by Type1Font.
@@ -219,7 +221,10 @@
                             || lexer.peekToken().getText().equals("readonly")
                             || lexer.peekToken().getText().equals("def"))))
             {
-                lexer.nextToken();
+                if (lexer.nextToken() == null)
+                {
+                    throw new IOException("Unexpected end of file while reading encoding");
+                }
             }
             
             Map<Integer, String> codeToName = new HashMap<>();
@@ -640,7 +645,10 @@
         while (!(lexer.peekKind(Token.LITERAL)
                 && lexer.peekToken().getText().equals("CharStrings")))
         {
-            lexer.nextToken();
+            if (lexer.nextToken() == null)
+            {
+                throw new IOException("Unexpected end of file while searching for CharStrings");
+            }
         }
 
         // CharStrings dict

--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java
@@ -183,14 +183,21 @@
 
         private PageIterator(COSDictionary node)
         {
+            Set<COSDictionary> visited = new HashSet<>();
             List<COSDictionary> kids = enqueueKids(node);
+            visited.add(node);
+            
             while (!kids.isEmpty())
             {
                 List<COSDictionary> newKids = new ArrayList<>();
 
                 for (COSDictionary kid : kids)
                 {
-                    newKids.addAll(enqueueKids(kid));
+                    if (kid != null && !visited.contains(kid))
+                    {
+                        visited.add(kid);
+                        newKids.addAll(enqueueKids(kid));
+                    }
                 }
                 kids = newKids;
             }

--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
+import org.apache.fontbox.type1.DamagedFontException;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.LogManager;
 /**
@@ -48,6 +49,11 @@
      * Log instance.
      */
     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);
+    
+    /**
+     * Maximum size for a single CharString in bytes (1 MB).
+     */
+    private static final int MAX_CHAR_STRING_SIZE = 1_000_000;
     
     private final ByteBuffer buffer;
     private Token aheadToken;
