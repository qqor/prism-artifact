{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_7",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 4.922766000000001,
    "prompt_tokens": 1359807,
    "completion_tokens": 56223
  },
  "variant": "sound",
  "diff": "--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n@@ -22,6 +22,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n import java.util.Map.Entry;\n \n import org.apache.logging.log4j.LogManager;\n@@ -98,17 +99,32 @@\n         }\n         document.setStartXref(startXrefOffset);\n         long prev = startXrefOffset;\n-        //lastPrev prevents potential infinite loops in crafted files\n-        long lastPrev = -1;\n+        // prevSet prevents potential infinite loops in crafted files\n+        Set<Long> prevSet = new HashSet<>();\n         // ---- parse whole chain of xref tables/object streams using PREV reference\n         COSDictionary trailer = null;\n-        while (prev > 0 && prev != lastPrev)\n-        {\n-            lastPrev = prev;\n+        while (prev > 0)\n+        {\n+            // Check for cycle\n+            if (prevSet.contains(prev))\n+            {\n+                throw new IOException(\"Circular reference detected in xref chain at offset \" + prev);\n+            }\n+            prevSet.add(prev);\n+            \n             // seek to xref table\n             source.seek(prev);\n             // skip white spaces\n             parser.skipSpaces();\n+            \n+            // Also track position after skipping spaces to detect subtle loops\n+            long currentPos = source.getPosition();\n+            if (prevSet.contains(currentPos))\n+            {\n+                throw new IOException(\"Circular reference detected at position \" + currentPos);\n+            }\n+            prevSet.add(currentPos);\n+            \n             // -- parse xref\n             if (source.peek() == X)\n             {\n@@ -170,10 +186,6 @@\n                     trailer.setLong(COSName.PREV, prev);\n                 }\n             }\n-            if (prev == lastPrev)\n-            {\n-                throw new IOException(\"/Prev loop at offset \" + prev);\n-            }\n         }\n         // ---- build valid xrefs out of the xref chain\n         xrefTrailerResolver.setStartxref(startXrefOffset);\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -43,6 +43,11 @@\n     // constants for encryption\n     private static final int EEXEC_KEY = 55665;\n     private static final int CHARSTRING_KEY = 4330;\n+    \n+    /**\n+     * Maximum number of subroutines allowed.\n+     */\n+    private static final int MAX_SUBRS_COUNT = 10_000;\n \n     // state\n     private Type1Lexer lexer;\n@@ -219,7 +224,10 @@\n                             || lexer.peekToken().getText().equals(\"readonly\")\n                             || lexer.peekToken().getText().equals(\"def\"))))\n             {\n-                lexer.nextToken();\n+                if (lexer.nextToken() == null)\n+                {\n+                    throw new IOException(\"Premature EOF: expected dup, readonly, or def\");\n+                }\n             }\n             \n             Map<Integer, String> codeToName = new HashMap<>();\n@@ -559,7 +567,10 @@\n             // for a more thorough validation, the presence of \"begin\" before Private\n             // determines how code before and following charstrings should look\n             // it is not currently checked anyway\n-            lexer.nextToken();\n+            if (lexer.nextToken() == null)\n+            {\n+                throw new IOException(\"Premature EOF: expected Private token\");\n+            }\n             peekToken = lexer.peekToken();\n         }\n         if (peekToken == null)\n@@ -640,7 +651,10 @@\n         while (!(lexer.peekKind(Token.LITERAL)\n                 && lexer.peekToken().getText().equals(\"CharStrings\")))\n         {\n-            lexer.nextToken();\n+            if (lexer.nextToken() == null)\n+            {\n+                throw new IOException(\"Premature EOF: expected CharStrings token\");\n+            }\n         }\n \n         // CharStrings dict\n@@ -707,6 +721,13 @@\n     {\n         // allocate size (array indexes may not be in-order)\n         int length = read(Token.INTEGER).intValue();\n+        \n+        if (length < 0 || length > MAX_SUBRS_COUNT)\n+        {\n+            throw new IOException(\"Invalid subrs count: \" + length + \n+                    \" (max: \" + MAX_SUBRS_COUNT + \")\");\n+        }\n+        \n         for (int i = 0; i < length; i++)\n         {\n             font.subrs.add(null);\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n@@ -48,6 +48,11 @@\n      * Log instance.\n      */\n     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);\n+    \n+    /**\n+     * Maximum size for a CharString in bytes.\n+     */\n+    private static final int MAX_CHAR_STRING_SIZE = 1_000_000;\n     \n     private final ByteBuffer buffer;\n     private Token aheadToken;\n@@ -501,6 +506,11 @@\n      */\n     private Token readCharString(int length) throws IOException\n     {\n+        if (length < 0 || length > MAX_CHAR_STRING_SIZE)\n+        {\n+            throw new DamagedFontException(\"CharString length is invalid: \" + length + \n+                    \" (max: \" + MAX_CHAR_STRING_SIZE + \")\");\n+        }\n         try\n         {\n             buffer.get(); // space\n\n--- a/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n@@ -158,9 +158,9 @@\n             size += in.read() << 16;\n             size += in.read() << 24;\n             LOG.debug(\"record type: {}, segment size: {}\", recordType, size);\n-            long newTotal = total + size;\n+            long newTotal = (long)total + (long)size;\n             if (newTotal > MAX_LENGTH) {\n-                throw new IOException(\"record size would be too large: \" + newTotal);\n+                throw new IOException(\"Record size would exceed maximum: \" + newTotal);\n             }\n \n             byte[] ar = new byte[size];\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n@@ -180,6 +180,7 @@\n     private final class PageIterator implements Iterator<PDPage>\n     {\n         private final Queue<COSDictionary> queue = new ArrayDeque<>();\n+        private final Set<COSDictionary> seen = new HashSet<>();\n \n         private PageIterator(COSDictionary node)\n         {\n",
  "stdout": "",
  "stderr": ""
}