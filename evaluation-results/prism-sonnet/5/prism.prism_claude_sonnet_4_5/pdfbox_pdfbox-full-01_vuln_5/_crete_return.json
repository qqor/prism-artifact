{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_5",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 1.8843839999999998,
    "prompt_tokens": 539558,
    "completion_tokens": 17714
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n@@ -48,6 +48,14 @@\n      * Log instance.\n      */\n     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);\n+    \n+    /**\n+     * Maximum allowed length for a single CharString to prevent OutOfMemoryError.\n+     * Legitimate CharStrings are typically very small (a few bytes to a few KB).\n+     * This generous 10MB limit prevents resource exhaustion attacks while supporting\n+     * any reasonable legitimate font.\n+     */\n+    private static final int MAX_CHARSTRING_LENGTH = 10_000_000;\n     \n     private final ByteBuffer buffer;\n     private Token aheadToken;\n@@ -501,6 +509,13 @@\n      */\n     private Token readCharString(int length) throws IOException\n     {\n+        // Validate length before allocation to prevent OutOfMemoryError from malicious fonts\n+        if (length < 0 || length > MAX_CHARSTRING_LENGTH)\n+        {\n+            throw new DamagedFontException(\"CharString length \" + length + \n+                \" is invalid or exceeds maximum allowed length of \" + MAX_CHARSTRING_LENGTH);\n+        }\n+        \n         try\n         {\n             buffer.get(); // space\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -43,6 +43,17 @@\n     // constants for encryption\n     private static final int EEXEC_KEY = 55665;\n     private static final int CHARSTRING_KEY = 4330;\n+    \n+    /**\n+     * Maximum number of subroutines to prevent resource exhaustion.\n+     * Legitimate Type1 fonts rarely have more than a few thousand subrs.\n+     */\n+    private static final int MAX_SUBRS_COUNT = 65536;\n+    \n+    /**\n+     * Maximum number of character strings to prevent resource exhaustion.\n+     */\n+    private static final int MAX_CHARSTRINGS_COUNT = 65536;\n \n     // state\n     private Type1Lexer lexer;\n@@ -707,6 +718,14 @@\n     {\n         // allocate size (array indexes may not be in-order)\n         int length = read(Token.INTEGER).intValue();\n+        \n+        // Validate subrs count to prevent resource exhaustion\n+        if (length < 0 || length > MAX_SUBRS_COUNT)\n+        {\n+            throw new IOException(\"Subrs count \" + length + \n+                \" is invalid or exceeds maximum allowed count of \" + MAX_SUBRS_COUNT);\n+        }\n+        \n         for (int i = 0; i < length; i++)\n         {\n             font.subrs.add(null);\n@@ -777,6 +796,14 @@\n     private void readCharStrings(int lenIV) throws IOException\n     {\n         int length = read(Token.INTEGER).intValue();\n+        \n+        // Validate charstrings count to prevent excessive iteration\n+        if (length < 0 || length > MAX_CHARSTRINGS_COUNT)\n+        {\n+            throw new IOException(\"CharStrings count \" + length + \n+                \" is invalid or exceeds maximum allowed count of \" + MAX_CHARSTRINGS_COUNT);\n+        }\n+        \n         read(Token.NAME, \"dict\");\n         // could actually be a sequence ending in \"CharStrings begin\", too\n         // instead of the \"dup begin\"\n",
  "stdout": "",
  "stderr": ""
}