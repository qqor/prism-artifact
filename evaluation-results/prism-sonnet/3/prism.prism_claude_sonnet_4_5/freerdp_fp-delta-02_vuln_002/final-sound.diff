--- a/libfreerdp/crypto/x509_utils.c
+++ b/libfreerdp/crypto/x509_utils.c
@@ -431,46 +431,30 @@
 }
 
 BOOL x509_validate_subject_aternative_names(const X509* cert) {
-    STACK_OF(GENERAL_NAME) *san_names = NULL;
-    int i, count;
-    char *dns_name = NULL;
 	BOOL result = TRUE;
-
-    // Get Subject Alternative Names (SAN)
-    san_names = X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
-    if (!san_names) {
-        goto end;
-    }
-
-    count = sk_GENERAL_NAME_num(san_names);
-
-    for (i = 0; i < count; i++) {
-        GENERAL_NAME *gen_name = sk_GENERAL_NAME_value(san_names, i);
-
-        if (gen_name->type == GEN_DNS) {
-			// Allocate string length + 1 for security
-			dns_name = malloc( strlen((char *)ASN1_STRING_get0_data(gen_name->d.dNSName)) + 1);
-
-			if (dns_name == NULL)
-				goto end;
-			
-			memcpy(dns_name, (char *)ASN1_STRING_get0_data(gen_name->d.dNSName),  
-				ASN1_STRING_length(gen_name->d.dNSName)) ;
-			
-            if (!verify_san(dns_name)) {
-				free(dns_name);
-				result = FALSE;
-				goto end;
-            } else {
-				free(dns_name);
-            }
-        }
-    }
-
-end:
-    sk_GENERAL_NAME_pop_free(san_names, GENERAL_NAME_free);
-
-	return TRUE;
+	size_t count = 0;
+	size_t* lengths = NULL;
+
+	// Use existing function to extract DNS names correctly
+	char** dns_names = x509_utils_get_dns_names(cert, &count, &lengths);
+
+	// No DNS names is a valid case (certificate may not have SAN extension)
+	if (!dns_names) {
+		return TRUE;
+	}
+
+	// Validate each DNS name
+	for (size_t i = 0; i < count; i++) {
+		if (!verify_san(dns_names[i])) {
+			result = FALSE;
+			break;  // Stop on first invalid DNS name
+		}
+	}
+
+	// Proper cleanup with correct free functions
+	x509_utils_dns_names_free(count, lengths, dns_names);
+
+	return result;
 }
 
 char* x509_utils_get_email(const X509* x509)
