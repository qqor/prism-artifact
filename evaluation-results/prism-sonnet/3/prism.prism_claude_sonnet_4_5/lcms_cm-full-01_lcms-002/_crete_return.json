{
  "project_name": "lcms",
  "vulnerability_identifier": "lcms_cm-full-01_lcms-002",
  "source_directory": "/home/qqor/crete/.cache/official-afc-little-cms",
  "llm_usage": {
    "total_cost": 10.162928999999998,
    "prompt_tokens": 3189208,
    "completion_tokens": 39687
  },
  "variant": "sound",
  "diff": "--- a/src/cmsvirt.c\n+++ b/src/cmsvirt.c\n@@ -1094,14 +1094,70 @@\n     nc2 ->ColorantCount = cmsPipelineOutputChannels(v ->Lut);\n \n     // Make sure we have proper formatters\n-    cmsChangeBuffersFormat(xform, TYPE_NAMED_COLOR_INDEX,\n+    cmsBool formatChanged;\n+    cmsUInt32Number inputBytesPerPixel;\n+    cmsUInt8Number* inputBuffer = NULL;\n+\n+    formatChanged = cmsChangeBuffersFormat(xform, TYPE_NAMED_COLOR_INDEX,\n         FLOAT_SH(0) | COLORSPACE_SH(_cmsLCMScolorSpace(v ->ExitColorSpace))\n         | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOfColorSpace(v ->ExitColorSpace)));\n \n-    // Apply the transfor to colorants.\n+    // Calculate required input buffer size\n+    if (formatChanged) {\n+        // TYPE_NAMED_COLOR_INDEX expects 2 bytes (cmsUInt16Number)\n+        inputBytesPerPixel = 2;\n+    } else {\n+        // Use existing format's requirements\n+        cmsUInt32Number nChan = T_CHANNELS(v->InputFormat);\n+        cmsUInt32Number bytesPerSample = T_BYTES(v->InputFormat);\n+        \n+        // Handle special case for double (BYTES=0)\n+        if (bytesPerSample == 0) bytesPerSample = sizeof(cmsUInt64Number);\n+        \n+        inputBytesPerPixel = nChan * bytesPerSample;\n+    }\n+\n+    // Allocate input buffer\n+    inputBuffer = (cmsUInt8Number*)_cmsMalloc(v->ContextID, inputBytesPerPixel);\n+    if (inputBuffer == NULL) goto Error;\n+\n+    // Apply the transform to colorants.\n     for (i=0; i < nColors; i++) {\n-        cmsDoTransform(xform, &i, nc2 ->List[i].DeviceColorant, 1);\n-    }\n+        \n+        // Populate input buffer based on whether format changed\n+        if (formatChanged) {\n+            // Write as cmsUInt16Number for TYPE_NAMED_COLOR_INDEX\n+            *(cmsUInt16Number*)inputBuffer = (cmsUInt16Number)i;\n+        } else {\n+            // Populate all channels with the index value in the original format\n+            cmsUInt32Number ch, nChan = T_CHANNELS(v->InputFormat);\n+            cmsUInt32Number bytesPerSample = T_BYTES(v->InputFormat);\n+            \n+            if (bytesPerSample == 0) bytesPerSample = sizeof(cmsUInt64Number);\n+            \n+            for (ch = 0; ch < nChan; ch++) {\n+                switch (bytesPerSample) {\n+                    case 1:\n+                        inputBuffer[ch] = (cmsUInt8Number)(i & 0xFF);\n+                        break;\n+                    case 2:\n+                        ((cmsUInt16Number*)inputBuffer)[ch] = (cmsUInt16Number)(i & 0xFFFF);\n+                        break;\n+                    case 4:\n+                        ((cmsUInt32Number*)inputBuffer)[ch] = i;\n+                        break;\n+                    case 8:\n+                        ((cmsUInt64Number*)inputBuffer)[ch] = (cmsUInt64Number)i;\n+                        break;\n+                }\n+            }\n+        }\n+        \n+        cmsDoTransform(xform, inputBuffer, nc2 ->List[i].DeviceColorant, 1);\n+    }\n+\n+    // Free the allocated buffer\n+    _cmsFree(v->ContextID, inputBuffer);\n \n     if (!cmsWriteTag(hICC, cmsSigNamedColor2Tag, (void*) nc2)) goto Error;\n     cmsFreeNamedColorList(nc2);\n@@ -1109,6 +1165,9 @@\n     return hICC;\n \n Error:\n+    if (inputBuffer != NULL) {\n+        _cmsFree(v->ContextID, inputBuffer);\n+    }\n     if (hICC != NULL) cmsCloseProfile(hICC);\n     return NULL;\n }\n",
  "stdout": "",
  "stderr": ""
}