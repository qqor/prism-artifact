{
  "project_name": "tika",
  "vulnerability_identifier": "tika_tk-delta-01_vuln_9",
  "source_directory": "/home/user/crete/.cache/official-afc-tika",
  "llm_usage": {
    "total_cost": 6.970211999999998,
    "prompt_tokens": 1822339,
    "completion_tokens": 100213
  },
  "variant": "sound",
  "diff": "--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-html-module/src/main/java/org/apache/tika/parser/html/HtmlHandler.java\n+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-html-module/src/main/java/org/apache/tika/parser/html/HtmlHandler.java\n@@ -20,6 +20,9 @@\n import java.net.MalformedURLException;\n import java.net.URL;\n import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n@@ -35,6 +38,8 @@\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.AttributesImpl;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.apache.tika.extractor.EmbeddedDocumentExtractor;\n import org.apache.tika.extractor.EmbeddedDocumentUtil;\n import org.apache.tika.io.TikaInputStream;\n@@ -53,6 +58,8 @@\n import org.apache.tika.utils.StringUtils;\n \n class HtmlHandler extends TextContentHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(HtmlHandler.class);\n \n     // List of attributes that need to be resolved.\n     private static final Set<String> URI_ATTRIBUTES =\n@@ -360,8 +367,15 @@\n             return;\n         }\n         int added = 0;\n+        // Security fix: Block document-controlled exiftool_path to prevent OS command injection\n         if (metadata.get(\"html_meta:exiftool_path\") != null) {\n-            added = configureExifTool(metadata.get(\"html_meta:exiftool_path\"));\n+            LOG.warn(\"Ignoring exiftool_path from document metadata for security reasons. \" +\n+                     \"Use system property -Dtika.exiftool.path to configure exiftool.\");\n+        }\n+        // Only use system property (trusted source) for exiftool configuration\n+        String exiftoolPath = System.getProperty(\"tika.exiftool.path\");\n+        if (exiftoolPath != null && !exiftoolPath.trim().isEmpty()) {\n+            added = configureExifTool(exiftoolPath);\n         }\n         //do anything with attrs?\n         Metadata m = new Metadata();\n@@ -384,6 +398,58 @@\n     }\n \n     private int configureExifTool(String path) {\n+        // Security validation: Prevent OS command injection through path validation\n+        if (path == null || path.trim().isEmpty()) {\n+            LOG.warn(\"Exiftool path is null or empty, configuration skipped\");\n+            return 2;\n+        }\n+        \n+        try {\n+            // Resolve to absolute normalized path to prevent directory traversal\n+            Path exiftoolPath = Paths.get(path).toAbsolutePath().normalize();\n+            \n+            // Security: path must be absolute\n+            if (!exiftoolPath.isAbsolute()) {\n+                LOG.warn(\"Exiftool path must be absolute, rejecting: {}\", path);\n+                return 2;\n+            }\n+            \n+            // Security: file must exist\n+            if (!Files.exists(exiftoolPath)) {\n+                LOG.warn(\"Exiftool path does not exist: {}\", exiftoolPath);\n+                return 2;\n+            }\n+            \n+            // Security: file must be executable\n+            if (!Files.isExecutable(exiftoolPath)) {\n+                LOG.warn(\"Exiftool path is not executable: {}\", exiftoolPath);\n+                return 2;\n+            }\n+            \n+            // Security: must be a regular file\n+            if (!Files.isRegularFile(exiftoolPath)) {\n+                LOG.warn(\"Exiftool path is not a regular file: {}\", exiftoolPath);\n+                return 2;\n+            }\n+            \n+            // Security: filename must contain \"exiftool\" to prevent arbitrary executables\n+            String fileName = exiftoolPath.getFileName().toString().toLowerCase(Locale.US);\n+            if (!fileName.contains(\"exiftool\")) {\n+                LOG.warn(\"Path does not appear to be exiftool executable: {}\", exiftoolPath);\n+                return 2;\n+            }\n+            \n+            // Use the validated absolute path\n+            path = exiftoolPath.toString();\n+            \n+        } catch (SecurityException se) {\n+            LOG.warn(\"Security manager denied access to path: {}\", path, se);\n+            return 2;\n+        } catch (Exception e) {\n+            LOG.warn(\"Error validating exiftool path: {}\", path, e);\n+            return 2;\n+        }\n+        \n         ExternalParser exifToolParser = getExistingExifToolParser();\n         int retVal = 0;\n         if (exifToolParser == null) {\n@@ -435,7 +501,7 @@\n         }\n         exifToolParser.setCommand(\"exiftool\", \"${INPUT}\");\n         exifToolParser.setSupportedTypes(newSupported);\n-        metadata.remove(\"exiftool_path\");\n+        metadata.remove(\"html_meta:exiftool_path\");\n         Map<MediaType, Parser> updated = new HashMap<>();\n         for (Map.Entry<MediaType, Parser> e : exParser.getParsers().entrySet()) {\n             if (e.getValue() instanceof ExternalParser) {\n\n--- a/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java\n+++ b/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java\n@@ -277,6 +277,43 @@\n         }\n     }\n \n+    /**\n+     * Validates file paths before using them in external commands to prevent injection attacks.\n+     *\n+     * @param path the file path to validate\n+     * @throws TikaException if path contains unsafe characters or is invalid\n+     */\n+    private void validateFilePath(String path) throws TikaException {\n+        if (path == null || path.isEmpty()) {\n+            throw new TikaException(\"File path cannot be null or empty\");\n+        }\n+        \n+        File file = new File(path);\n+        if (!file.isAbsolute()) {\n+            throw new TikaException(\"File path must be absolute: \" + path);\n+        }\n+        \n+        // Check for shell metacharacters and control characters\n+        for (int i = 0; i < path.length(); i++) {\n+            char c = path.charAt(i);\n+            \n+            if (Character.isISOControl(c)) {\n+                throw new TikaException(\n+                    \"File path contains control character at position \" + i);\n+            }\n+            \n+            // Reject shell metacharacters that could enable command injection\n+            if (\";|&$`()<>*?[]{}\\'\\\"\".indexOf(c) >= 0) {\n+                throw new TikaException(\n+                    \"File path contains unsafe character '\" + c + \"' at position \" + i);\n+            }\n+        }\n+        \n+        if (path.length() > 4096) {\n+            throw new TikaException(\"File path exceeds maximum length\");\n+        }\n+    }\n+\n     private void parse(TikaInputStream stream, XHTMLContentHandler xhtml, Metadata metadata,\n                        TemporaryResources tmp) throws IOException, SAXException, TikaException {\n         boolean inputToStdIn = true;\n@@ -288,20 +325,25 @@\n         // Build our command\n         String[] cmd;\n         if (command.length == 1) {\n-            cmd = command[0].split(\" \");\n+            // Security: Do not split by space to prevent argument injection\n+            cmd = new String[] { command[0] };\n         } else {\n             cmd = new String[command.length];\n             System.arraycopy(command, 0, cmd, 0, command.length);\n         }\n         for (int i = 0; i < cmd.length; i++) {\n             if (cmd[i].contains(INPUT_FILE_TOKEN)) {\n-                cmd[i] = cmd[i].replace(INPUT_FILE_TOKEN, stream.getFile().getPath());\n+                String inputPath = stream.getFile().getPath();\n+                validateFilePath(inputPath);\n+                cmd[i] = cmd[i].replace(INPUT_FILE_TOKEN, inputPath);\n                 inputToStdIn = false;\n             }\n             if (cmd[i].contains(OUTPUT_FILE_TOKEN)) {\n                 output = tmp.createTemporaryFile();\n+                String outputPath = output.getPath();\n+                validateFilePath(outputPath);\n                 outputFromStdOut = false;\n-                cmd[i] = cmd[i].replace(OUTPUT_FILE_TOKEN, output.getPath());\n+                cmd[i] = cmd[i].replace(OUTPUT_FILE_TOKEN, outputPath);\n             }\n         }\n \n",
  "stdout": "",
  "stderr": ""
}