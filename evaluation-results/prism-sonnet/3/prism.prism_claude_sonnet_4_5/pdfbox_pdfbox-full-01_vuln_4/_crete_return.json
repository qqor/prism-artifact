{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_4",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 10.889679000000005,
    "prompt_tokens": 2997213,
    "completion_tokens": 126536
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java\n@@ -49,6 +49,8 @@\n      */\n     private static final Logger LOG = LogManager.getLogger(Type1Lexer.class);\n     \n+    private static final int MAX_CONSECUTIVE_SKIPS = 10000;\n+    \n     private final ByteBuffer buffer;\n     private Token aheadToken;\n     private int openParens = 0;\n@@ -116,6 +118,7 @@\n      */\n     private Token readToken(Token prevToken) throws IOException\n     {\n+        int consecutiveSkips = 0;\n         boolean skip;\n         do\n         {\n@@ -197,11 +200,25 @@\n                 else if (Character.isWhitespace(c))\n                 {\n                     skip = true;\n+                    consecutiveSkips++;\n+                    if (consecutiveSkips > MAX_CONSECUTIVE_SKIPS)\n+                    {\n+                        throw new DamagedFontException(\n+                            \"Excessive whitespace or NULL bytes at position \" + \n+                            buffer.position());\n+                    }\n                 }\n                 else if (c == 0)\n                 {\n                     LOG.warn(\"NULL byte in font, skipped\");\n                     skip = true;\n+                    consecutiveSkips++;\n+                    if (consecutiveSkips > MAX_CONSECUTIVE_SKIPS)\n+                    {\n+                        throw new DamagedFontException(\n+                            \"Excessive whitespace or NULL bytes at position \" + \n+                            buffer.position());\n+                    }\n                 }\n                 else\n                 {\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -43,6 +43,9 @@\n     // constants for encryption\n     private static final int EEXEC_KEY = 55665;\n     private static final int CHARSTRING_KEY = 4330;\n+    \n+    // maximum iterations for unbounded search loops\n+    private static final int MAX_SEARCH_ITERATIONS = 100000;\n \n     // state\n     private Type1Lexer lexer;\n@@ -214,12 +217,23 @@\n             // 0 1 255 {1 index exch /.notdef put } for\n             // we have to check \"readonly\" and \"def\" too\n             // as some fonts don't provide any dup-values, see PDFBOX-2134\n+            int encodingSearchIterations = 0;\n             while (!(lexer.peekKind(Token.NAME)\n                     && (lexer.peekToken().getText().equals(\"dup\")\n                             || lexer.peekToken().getText().equals(\"readonly\")\n                             || lexer.peekToken().getText().equals(\"def\"))))\n             {\n+                if (lexer.peekToken() == null)\n+                {\n+                    throw new IOException(\"Unexpected end of file while parsing encoding\");\n+                }\n                 lexer.nextToken();\n+                encodingSearchIterations++;\n+                if (encodingSearchIterations > MAX_SEARCH_ITERATIONS)\n+                {\n+                    throw new DamagedFontException(\n+                        \"Excessive tokens while searching for encoding entries\");\n+                }\n             }\n             \n             Map<Integer, String> codeToName = new HashMap<>();\n@@ -553,6 +567,7 @@\n         lexer = new Type1Lexer(decrypted);\n \n         // find /Private dict\n+        int searchIterations = 0;\n         Token peekToken = lexer.peekToken();\n         while (peekToken != null && !\"Private\".equals(peekToken.getText()))\n         {\n@@ -560,6 +575,13 @@\n             // determines how code before and following charstrings should look\n             // it is not currently checked anyway\n             lexer.nextToken();\n+            searchIterations++;\n+            if (searchIterations > MAX_SEARCH_ITERATIONS)\n+            {\n+                throw new DamagedFontException(\n+                    \"Exceeded maximum iterations (\" + MAX_SEARCH_ITERATIONS + \n+                    \") searching for /Private token\");\n+            }\n             peekToken = lexer.peekToken();\n         }\n         if (peekToken == null)\n@@ -637,10 +659,22 @@\n         // some fonts have \"2 index\" here, others have \"end noaccess put\"\n         // sometimes followed by \"put\". Either way, we just skip until\n         // the /CharStrings dict is found\n+        int charStringsSearchIterations = 0;\n         while (!(lexer.peekKind(Token.LITERAL)\n                 && lexer.peekToken().getText().equals(\"CharStrings\")))\n         {\n+            if (lexer.peekToken() == null)\n+            {\n+                throw new IOException(\"Unexpected end of file while searching for CharStrings\");\n+            }\n             lexer.nextToken();\n+            charStringsSearchIterations++;\n+            if (charStringsSearchIterations > MAX_SEARCH_ITERATIONS)\n+            {\n+                throw new DamagedFontException(\n+                    \"Exceeded maximum iterations (\" + MAX_SEARCH_ITERATIONS + \n+                    \") searching for /CharStrings\");\n+            }\n         }\n \n         // CharStrings dict\n",
  "stdout": "",
  "stderr": ""
}