{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_8",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 14.335862999999998,
    "prompt_tokens": 4009036,
    "completion_tokens": 153917
  },
  "variant": "sound",
  "diff": "--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n@@ -22,6 +22,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n import java.util.Map.Entry;\n \n import org.apache.logging.log4j.LogManager;\n@@ -45,6 +46,11 @@\n     private static final char[] XREF_TABLE = { 'x', 'r', 'e', 'f' };\n     private static final char[] STARTXREF = { 's', 't', 'a', 'r', 't', 'x', 'r', 'e', 'f' };\n \n+    /**\n+     * Maximum length of xref chain to prevent timeout on malformed PDFs with circular references.\n+     */\n+    private static final int MAX_XREF_CHAIN_LENGTH = 100;\n+\n     /** \n      * Collects all Xref/trailer objects and resolves them into single\n      * object using startxref reference. \n@@ -98,14 +104,24 @@\n         }\n         document.setStartXref(startXrefOffset);\n         long prev = startXrefOffset;\n-        //lastPrev prevents potential infinite loops in crafted files\n-        long lastPrev = -1;\n-        // ---- parse whole chain of xref tables/object streams using PREV reference\n+        Set<Long> visitedXrefOffsets = new HashSet<>();\n+        int chainLength = 0;\n         COSDictionary trailer = null;\n-        while (prev > 0 && prev != lastPrev)\n-        {\n-            lastPrev = prev;\n-            // seek to xref table\n+        while (prev > 0)\n+        {\n+            if (visitedXrefOffsets.contains(prev))\n+            {\n+                throw new IOException(\"Circular reference detected in xref chain at offset \" + prev);\n+            }\n+            visitedXrefOffsets.add(prev);\n+            \n+            chainLength++;\n+            if (chainLength > MAX_XREF_CHAIN_LENGTH)\n+            {\n+                throw new IOException(\"Xref chain length exceeded maximum of \" + MAX_XREF_CHAIN_LENGTH + \n+                        \" entries. The PDF may be malformed.\");\n+            }\n+            \n             source.seek(prev);\n             // skip white spaces\n             parser.skipSpaces();\n@@ -170,10 +186,6 @@\n                     trailer.setLong(COSName.PREV, prev);\n                 }\n             }\n-            if (prev == lastPrev)\n-            {\n-                throw new IOException(\"/Prev loop at offset \" + prev);\n-            }\n         }\n         // ---- build valid xrefs out of the xref chain\n         xrefTrailerResolver.setStartxref(startXrefOffset);\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BruteForceParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BruteForceParser.java\n@@ -57,6 +57,20 @@\n      * obj-marker.\n      */\n     private static final char[] OBJ_MARKER = { 'o', 'b', 'j' };\n+\n+    /**\n+     * Maximum number of brute force xref search invocations to prevent timeout on malformed PDFs.\n+     */\n+    private static final int MAX_BF_SEARCH_INVOCATIONS = 5;\n+\n+    /**\n+     * Maximum bytes to scan in findString() to prevent timeout on large malformed files.\n+     */\n+    private static final long MAX_FINDSTRING_BYTES = 100_000_000L;\n+\n+    private int bfSearchXrefInvocationCount = 0;\n+    private List<Long> cachedXRefTablesOffsets = null;\n+    private List<Long> cachedXRefStreamsOffsets = null;\n \n     /**\n      * trailer-marker.\n@@ -226,20 +240,31 @@\n      */\n     protected long bfSearchForXRef(long xrefOffset) throws IOException\n     {\n+        if (bfSearchXrefInvocationCount >= MAX_BF_SEARCH_INVOCATIONS)\n+        {\n+            throw new IOException(\"Exceeded maximum brute force xref search invocations (\" + \n+                    MAX_BF_SEARCH_INVOCATIONS + \"). The PDF may be malformed.\");\n+        }\n+        bfSearchXrefInvocationCount++;\n+\n         long newOffset = -1;\n \n-        // initialize bfSearchXRefTablesOffsets -> not null\n-        List<Long> bfSearchXRefTablesOffsets = bfSearchForXRefTables();\n-        // initialize bfSearchXRefStreamsOffsets -> not null\n-        List<Long> bfSearchXRefStreamsOffsets = bfSearchForXRefStreams();\n-\n-        // TODO to be optimized, this won't work in every case\n+        if (cachedXRefTablesOffsets == null)\n+        {\n+            cachedXRefTablesOffsets = bfSearchForXRefTables();\n+        }\n+        List<Long> bfSearchXRefTablesOffsets = new ArrayList<>(cachedXRefTablesOffsets);\n+\n+        if (cachedXRefStreamsOffsets == null)\n+        {\n+            cachedXRefStreamsOffsets = bfSearchForXRefStreams();\n+        }\n+        List<Long> bfSearchXRefStreamsOffsets = new ArrayList<>(cachedXRefStreamsOffsets);\n+\n         long newOffsetTable = searchNearestValue(bfSearchXRefTablesOffsets, xrefOffset);\n \n-        // TODO to be optimized, this won't work in every case\n         long newOffsetStream = searchNearestValue(bfSearchXRefStreamsOffsets, xrefOffset);\n \n-        // choose the nearest value\n         if (newOffsetTable > -1 && newOffsetStream > -1)\n         {\n             long differenceTable = xrefOffset - newOffsetTable;\n@@ -782,9 +807,17 @@\n         long position = -1L;\n         int stringLength = string.length;\n         int counter = 0;\n+        long bytesRead = 0;\n         int readChar = source.read();\n         while (readChar != -1)\n         {\n+            bytesRead++;\n+            if (bytesRead > MAX_FINDSTRING_BYTES)\n+            {\n+                throw new IOException(\"Brute force string search exceeded maximum scan length of \" + \n+                        MAX_FINDSTRING_BYTES + \" bytes. The PDF may be malformed or too large.\");\n+            }\n+            \n             if (readChar == string[counter])\n             {\n                 if (counter == 0)\n",
  "stdout": "",
  "stderr": ""
}