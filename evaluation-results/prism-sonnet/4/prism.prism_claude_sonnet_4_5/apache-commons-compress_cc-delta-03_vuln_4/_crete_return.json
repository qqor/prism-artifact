{
  "project_name": "apache-commons-compress",
  "vulnerability_identifier": "apache-commons-compress_cc-delta-03_vuln_4",
  "source_directory": "/home/qqor/crete/.cache/official-afc-commons-compress",
  "llm_usage": {
    "total_cost": 2.9028300000000002,
    "prompt_tokens": 885015,
    "completion_tokens": 16519
  },
  "variant": "sound",
  "diff": "--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -219,7 +219,7 @@\n      * </p>\n      */\n     private static final Pattern PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN =\n-            Pattern.compile(\"-?\\\\d{1,19}(?:\\\\.\\\\d*)?\");\n+            Pattern.compile(\"-?\\\\d{1,19}(?:\\\\.\\\\d{0,18})?\");\n \n     private static FileTime fileTimeFromOptionalSeconds(final long seconds) {\n         return seconds <= 0 ? null : FileTimes.fromUnixTime(seconds);\n@@ -272,12 +272,43 @@\n             throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\");\n         }\n \n-        final BigDecimal epochSeconds = new BigDecimal(value);\n-        final long seconds = epochSeconds.longValue();\n-        final long nanos = epochSeconds.remainder(BigDecimal.ONE).movePointRight(9).longValue();\n         try {\n+            // Find decimal point position\n+            final int dotIndex = value.indexOf('.');\n+            \n+            final long seconds;\n+            final long nanos;\n+            \n+            if (dotIndex == -1) {\n+                // No decimal part - parse seconds directly\n+                seconds = Long.parseLong(value);\n+                nanos = 0;\n+            } else {\n+                // Parse integer part (seconds)\n+                final String secondsPart = value.substring(0, dotIndex);\n+                seconds = Long.parseLong(secondsPart);\n+                \n+                // Parse decimal part (nanoseconds)\n+                String nanosPart = value.substring(dotIndex + 1);\n+                \n+                // Limit to 9 digits for nanoseconds, truncate if longer\n+                if (nanosPart.length() > 9) {\n+                    nanosPart = nanosPart.substring(0, 9);\n+                }\n+                \n+                // Pad with trailing zeros if shorter than 9 digits\n+                while (nanosPart.length() < 9) {\n+                    nanosPart = nanosPart + \"0\";\n+                }\n+                \n+                nanos = Long.parseLong(nanosPart);\n+            }\n+            \n             return Instant.ofEpochSecond(seconds, nanos);\n-        } catch (DateTimeException | ArithmeticException e) {\n+            \n+        } catch (final NumberFormatException e) {\n+            throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\", e);\n+        } catch (final DateTimeException | ArithmeticException e) {\n             // DateTimeException: Thrown if the instant exceeds the maximum or minimum instant.\n             // ArithmeticException: Thrown if numeric overflow occurs.\n             throw new IOException(\"Corrupted PAX header. Time field value is invalid '\" + value + \"'\", e);\n",
  "stdout": "",
  "stderr": ""
}