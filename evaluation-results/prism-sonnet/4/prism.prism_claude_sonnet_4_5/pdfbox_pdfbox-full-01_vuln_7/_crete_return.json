{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_7",
  "source_directory": "/home/user/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 3.0351329999999996,
    "prompt_tokens": 877471,
    "completion_tokens": 26848
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -219,7 +219,9 @@\n                             || lexer.peekToken().getText().equals(\"readonly\")\n                             || lexer.peekToken().getText().equals(\"def\"))))\n             {\n-                lexer.nextToken();\n+                if (lexer.nextToken() == null) {\n+                    throw new IOException(\"Should have found dup, readonly or def?! EOF?\");\n+                }\n             }\n             \n             Map<Integer, String> codeToName = new HashMap<>();\n@@ -559,7 +561,9 @@\n             // for a more thorough validation, the presence of \"begin\" before Private\n             // determines how code before and following charstrings should look\n             // it is not currently checked anyway\n-            lexer.nextToken();\n+            if (lexer.nextToken() == null) {\n+                throw new IOException(\"Unexpected EOF while searching for /Private dict\");\n+            }\n             peekToken = lexer.peekToken();\n         }\n         if (peekToken == null)\n@@ -640,7 +644,9 @@\n         while (!(lexer.peekKind(Token.LITERAL)\n                 && lexer.peekToken().getText().equals(\"CharStrings\")))\n         {\n-            lexer.nextToken();\n+            if (lexer.nextToken() == null) {\n+                throw new IOException(\"Unexpected EOF while searching for /CharStrings dict\");\n+            }\n         }\n \n         // CharStrings dict\n@@ -707,6 +713,10 @@\n     {\n         // allocate size (array indexes may not be in-order)\n         int length = read(Token.INTEGER).intValue();\n+        if (length < 0 || length > 65536)\n+        {\n+            throw new IOException(\"Invalid Subrs array length: \" + length);\n+        }\n         for (int i = 0; i < length; i++)\n         {\n             font.subrs.add(null);\n@@ -777,6 +787,10 @@\n     private void readCharStrings(int lenIV) throws IOException\n     {\n         int length = read(Token.INTEGER).intValue();\n+        if (length < 0 || length > 65536)\n+        {\n+            throw new IOException(\"Invalid CharStrings dict length: \" + length);\n+        }\n         read(Token.NAME, \"dict\");\n         // could actually be a sequence ending in \"CharStrings begin\", too\n         // instead of the \"dup begin\"\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n@@ -23,6 +23,7 @@\n import java.util.Map;\n import java.util.Optional;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n@@ -98,17 +99,19 @@\n         }\n         document.setStartXref(startXrefOffset);\n         long prev = startXrefOffset;\n-        //lastPrev prevents potential infinite loops in crafted files\n-        long lastPrev = -1;\n         // ---- parse whole chain of xref tables/object streams using PREV reference\n+        Set<Long> prevSet = new HashSet<>();\n         COSDictionary trailer = null;\n-        while (prev > 0 && prev != lastPrev)\n-        {\n-            lastPrev = prev;\n+        while (prev > 0)\n+        {\n+            // save expected position for loop detection\n+            prevSet.add(prev);\n             // seek to xref table\n             source.seek(prev);\n             // skip white spaces\n             parser.skipSpaces();\n+            // save current position as well due to skipped spaces\n+            prevSet.add(source.getPosition());\n             // -- parse xref\n             if (source.peek() == X)\n             {\n@@ -170,7 +173,7 @@\n                     trailer.setLong(COSName.PREV, prev);\n                 }\n             }\n-            if (prev == lastPrev)\n+            if (prevSet.contains(prev))\n             {\n                 throw new IOException(\"/Prev loop at offset \" + prev);\n             }\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/PDPageTree.java\n@@ -18,8 +18,11 @@\n \n import java.util.ArrayDeque;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Queue;\n+import java.util.Set;\n import org.apache.pdfbox.cos.COSArray;\n import org.apache.pdfbox.cos.COSBase;\n import org.apache.pdfbox.cos.COSDictionary;\n@@ -180,6 +183,7 @@\n     private final class PageIterator implements Iterator<PDPage>\n     {\n         private final Queue<COSDictionary> queue = new ArrayDeque<>();\n+        private Set<COSDictionary> seen = new HashSet<>();\n \n         private PageIterator(COSDictionary node)\n         {\n@@ -205,6 +209,11 @@\n          */\n         private List<COSDictionary> enqueueKids(COSDictionary node)\n         {\n+            if (seen.contains(node)) {\n+                LOG.warn(\"Found an infinite loop in the page tree\");\n+                return Collections.emptyList();\n+            }\n+            seen.add(node);\n             if (isPageTreeNode(node))\n             {\n                 return getKids(node);\n",
  "stdout": "",
  "stderr": ""
}