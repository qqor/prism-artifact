{
  "project_name": "tika",
  "vulnerability_identifier": "tika_tk-delta-01_vuln_9",
  "source_directory": "/home/qqor/crete/.cache/official-afc-tika",
  "llm_usage": {
    "total_cost": 3.092484,
    "prompt_tokens": 891168,
    "completion_tokens": 27932
  },
  "variant": "sound",
  "diff": "--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-html-module/src/main/java/org/apache/tika/parser/html/HtmlHandler.java\n+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-html-module/src/main/java/org/apache/tika/parser/html/HtmlHandler.java\n@@ -359,10 +359,6 @@\n             //swallow\n             return;\n         }\n-        int added = 0;\n-        if (metadata.get(\"html_meta:exiftool_path\") != null) {\n-            added = configureExifTool(metadata.get(\"html_meta:exiftool_path\"));\n-        }\n         //do anything with attrs?\n         Metadata m = new Metadata();\n         m.set(TikaCoreProperties.EMBEDDED_RESOURCE_TYPE,\n@@ -377,8 +373,6 @@\n                 embeddedDocumentExtractor.parseEmbedded(stream, xhtml, m, true);\n             } catch (IOException e) {\n                 EmbeddedDocumentUtil.recordEmbeddedStreamException(e, metadata);\n-            } finally {\n-                resetExifTool(added);\n             }\n         }\n     }\n\n--- a/tika-core/src/main/java/org/apache/tika/utils/ProcessUtils.java\n+++ b/tika-core/src/main/java/org/apache/tika/utils/ProcessUtils.java\n@@ -46,24 +46,113 @@\n     }\n \n     /**\n-     * This should correctly put double-quotes around an argument if\n-     * ProcessBuilder doesn't seem to work (as it doesn't\n-     * on paths with spaces on Windows)\n-     *\n-     * @param arg\n-     * @return\n+     * Properly escapes command-line arguments to prevent command injection.\n+     * Uses platform-specific escaping strategies for Windows and Unix/Linux systems.\n+     *\n+     * @param arg the argument to escape\n+     * @return escaped argument safe for command-line execution\n      */\n     public static String escapeCommandLine(String arg) {\n         if (arg == null) {\n             return arg;\n         }\n-        //need to test for \" \" on windows, can't just add double quotes\n-        //across platforms.\n-        if (arg.contains(\" \") && SystemUtils.IS_OS_WINDOWS &&\n-                (!arg.startsWith(\"\\\"\") && !arg.endsWith(\"\\\"\"))) {\n-            arg = \"\\\"\" + arg + \"\\\"\";\n-        }\n-        return arg;\n+        \n+        if (arg.indexOf('\\0') >= 0 || arg.indexOf('\\n') >= 0 || arg.indexOf('\\r') >= 0) {\n+            throw new IllegalArgumentException(\"Command argument contains dangerous control characters\");\n+        }\n+        \n+        if (SystemUtils.IS_OS_WINDOWS) {\n+            return escapeWindowsCommandLine(arg);\n+        } else {\n+            return escapeUnixCommandLine(arg);\n+        }\n+    }\n+    \n+    /**\n+     * Escapes command-line arguments for Windows systems.\n+     * Wraps arguments containing special characters in double quotes and escapes\n+     * internal quotes and backslashes.\n+     *\n+     * @param arg the argument to escape\n+     * @return escaped argument for Windows command line\n+     */\n+    private static String escapeWindowsCommandLine(String arg) {\n+        boolean needsQuoting = arg.contains(\" \") || arg.contains(\"\\t\") || \n+                               arg.contains(\"\\\"\") || arg.contains(\"&\") || \n+                               arg.contains(\"|\") || arg.contains(\"<\") || \n+                               arg.contains(\">\") || arg.contains(\"^\") ||\n+                               arg.contains(\"%\");\n+        \n+        if (!needsQuoting) {\n+            return arg;\n+        }\n+        \n+        if (arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\") && arg.length() > 1) {\n+            String internal = arg.substring(1, arg.length() - 1);\n+            if (!internal.contains(\"\\\"\") || internal.replace(\"\\\\\\\"\", \"\").indexOf('\"') < 0) {\n+                return arg;\n+            }\n+        }\n+        \n+        StringBuilder escaped = new StringBuilder();\n+        for (int i = 0; i < arg.length(); i++) {\n+            char c = arg.charAt(i);\n+            if (c == '\"') {\n+                escaped.append(\"\\\\\\\"\");\n+            } else if (c == '\\\\') {\n+                int backslashCount = 1;\n+                while (i + 1 < arg.length() && arg.charAt(i + 1) == '\\\\') {\n+                    backslashCount++;\n+                    i++;\n+                }\n+                if (i + 1 < arg.length() && arg.charAt(i + 1) == '\"') {\n+                    for (int j = 0; j < backslashCount * 2; j++) {\n+                        escaped.append(\"\\\\\\\\\");\n+                    }\n+                } else if (i + 1 == arg.length()) {\n+                    for (int j = 0; j < backslashCount * 2; j++) {\n+                        escaped.append(\"\\\\\\\\\");\n+                    }\n+                } else {\n+                    for (int j = 0; j < backslashCount; j++) {\n+                        escaped.append(\"\\\\\");\n+                    }\n+                }\n+            } else {\n+                escaped.append(c);\n+            }\n+        }\n+        \n+        return \"\\\"\" + escaped + \"\\\"\";\n+    }\n+    \n+    /**\n+     * Escapes command-line arguments for Unix/Linux systems.\n+     * Uses single-quote wrapping which provides strong protection against shell expansion.\n+     * Any embedded single quotes are escaped using the '\\'' technique.\n+     *\n+     * @param arg the argument to escape\n+     * @return escaped argument for Unix/Linux command line\n+     */\n+    private static String escapeUnixCommandLine(String arg) {\n+        boolean needsEscaping = false;\n+        for (char c : arg.toCharArray()) {\n+            if (c == '\\'' || c == '\"' || c == ' ' || c == '\\t' || \n+                c == ';' || c == '|' || c == '&' || c == '$' || \n+                c == '`' || c == '\\\\' || c == '(' || c == ')' ||\n+                c == '<' || c == '>' || c == '*' || c == '?' ||\n+                c == '[' || c == ']' || c == '{' || c == '}' ||\n+                c == '~' || c == '!' || c == '#') {\n+                needsEscaping = true;\n+                break;\n+            }\n+        }\n+        \n+        if (!needsEscaping) {\n+            return arg;\n+        }\n+        \n+        return \"'\" + arg.replace(\"'\", \"'\\\\''\") + \"'\";\n     }\n \n     public static String unescapeCommandLine(String arg) {\n\n--- a/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java\n+++ b/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java\n@@ -295,13 +295,17 @@\n         }\n         for (int i = 0; i < cmd.length; i++) {\n             if (cmd[i].contains(INPUT_FILE_TOKEN)) {\n-                cmd[i] = cmd[i].replace(INPUT_FILE_TOKEN, stream.getFile().getPath());\n+                String inputPath = stream.getFile().getPath();\n+                String escapedInputPath = org.apache.tika.utils.ProcessUtils.escapeCommandLine(inputPath);\n+                cmd[i] = cmd[i].replace(INPUT_FILE_TOKEN, escapedInputPath);\n                 inputToStdIn = false;\n             }\n             if (cmd[i].contains(OUTPUT_FILE_TOKEN)) {\n                 output = tmp.createTemporaryFile();\n                 outputFromStdOut = false;\n-                cmd[i] = cmd[i].replace(OUTPUT_FILE_TOKEN, output.getPath());\n+                String outputPath = output.getPath();\n+                String escapedOutputPath = org.apache.tika.utils.ProcessUtils.escapeCommandLine(outputPath);\n+                cmd[i] = cmd[i].replace(OUTPUT_FILE_TOKEN, escapedOutputPath);\n             }\n         }\n \n",
  "stdout": "",
  "stderr": ""
}