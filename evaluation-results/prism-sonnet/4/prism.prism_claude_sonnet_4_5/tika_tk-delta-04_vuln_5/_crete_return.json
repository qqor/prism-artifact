{
  "project_name": "tika",
  "vulnerability_identifier": "tika_tk-delta-04_vuln_5",
  "source_directory": "/home/qqor/crete/.cache/official-afc-tika",
  "llm_usage": {
    "total_cost": 5.537628000000001,
    "prompt_tokens": 1585046,
    "completion_tokens": 52166
  },
  "variant": "sound",
  "diff": "--- a/tika-pipes/tika-emitters/tika-emitter-fs/src/main/java/org/apache/tika/pipes/emitter/fs/FileSystemEmitter.java\n+++ b/tika-pipes/tika-emitters/tika-emitter-fs/src/main/java/org/apache/tika/pipes/emitter/fs/FileSystemEmitter.java\n@@ -26,8 +26,16 @@\n import java.nio.file.Paths;\n import java.nio.file.StandardCopyOption;\n import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import org.apache.tika.config.Field;\n+import org.apache.tika.config.Initializable;\n+import org.apache.tika.config.InitializableProblemHandler;\n+import org.apache.tika.config.Param;\n+import org.apache.tika.exception.TikaConfigException;\n import org.apache.tika.metadata.Metadata;\n import org.apache.tika.metadata.TikaCoreProperties;\n import org.apache.tika.parser.ParseContext;\n@@ -65,7 +73,9 @@\n  *      &lt;/emitters&gt;\n  *  &lt;/properties&gt;</pre>\n  */\n-public class FileSystemEmitter extends AbstractEmitter implements StreamEmitter {\n+public class FileSystemEmitter extends AbstractEmitter implements Initializable, StreamEmitter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(FileSystemEmitter.class);\n \n     private Path basePath = null;\n     private String fileExtension = \"json\";\n@@ -85,6 +95,11 @@\n         }\n         if (basePath != null) {\n             output = basePath.resolve(emitKey);\n+            // Validate that the resolved path stays within basePath to prevent path traversal\n+            if (!isDescendant(basePath, output)) {\n+                throw new TikaEmitterException(\n+                        \"emitKey must resolve to be a descendant of the 'basePath': \" + emitKey);\n+            }\n         } else {\n             output = Paths.get(emitKey);\n         }\n@@ -146,6 +161,12 @@\n     public void emit(String path, InputStream inputStream, Metadata userMetadata, ParseContext parseContext) throws IOException, TikaEmitterException {\n         Path target = basePath.resolve(path);\n \n+        // Validate that the resolved path stays within basePath to prevent path traversal\n+        if (!isDescendant(basePath, target)) {\n+            throw new IOException(\n+                    \"path must resolve to be a descendant of the 'basePath': \" + path);\n+        }\n+\n         if (!Files.isDirectory(target.getParent())) {\n             Files.createDirectories(target.getParent());\n         }\n@@ -164,6 +185,49 @@\n         }\n     }\n \n+    /**\n+     * Validates that the descendant path is within the root path.\n+     * This prevents path traversal attacks.\n+     *\n+     * @param root the root path\n+     * @param descendant the path to validate\n+     * @return true if descendant is within root, false otherwise\n+     */\n+    private static boolean isDescendant(Path root, Path descendant) {\n+        try {\n+            // Use toRealPath to resolve symbolic links and normalize paths\n+            return descendant.toRealPath().startsWith(root.toRealPath());\n+        } catch (IOException e) {\n+            // If toRealPath fails (e.g., file doesn't exist yet), fall back to normalize\n+            return descendant.toAbsolutePath().normalize()\n+                    .startsWith(root.toAbsolutePath().normalize());\n+        }\n+    }\n+\n+    @Override\n+    public void initialize(Map<String, Param> params) throws TikaConfigException {\n+        // no-op - parameters are set via setters before initialization\n+    }\n+\n+    @Override\n+    public void checkInitialization(InitializableProblemHandler problemHandler)\n+            throws TikaConfigException {\n+        if (basePath == null || basePath.toString().isBlank()) {\n+            LOG.warn(\"'basePath' has not been set. \" +\n+                    \"This means that client code or clients can write to any location that this \" +\n+                    \"process has permissions to write. If you are running tika-server, make \" +\n+                    \"absolutely certain that you've locked down \" +\n+                    \"access to tika-server and file-permissions for the tika-server process.\");\n+            return;\n+        }\n+\n+        if (basePath.toString().contains(\"\\u0000\")) {\n+            throw new TikaConfigException(\n+                    \"basePath must not contain \\\\u0000. \" +\n+                    \"Seriously, what were you thinking?\");\n+        }\n+    }\n+\n     enum ON_EXISTS {\n         SKIP, EXCEPTION, REPLACE\n     }\n\n--- a/tika-core/src/main/java/org/apache/tika/extractor/AbstractEmbeddedDocumentBytesHandler.java\n+++ b/tika-core/src/main/java/org/apache/tika/extractor/AbstractEmbeddedDocumentBytesHandler.java\n@@ -75,6 +75,10 @@\n                                 EmbeddedDocumentBytesConfig embeddedDocumentBytesConfig,\n                                 Metadata metadata) {\n         String embeddedPath = metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY);\n+        // Sanitize the embedded path to prevent path traversal\n+        if (embeddedPath != null) {\n+            embeddedPath = sanitizeEmbeddedPath(embeddedPath);\n+        }\n         StringBuilder emitKey = new StringBuilder(containerEmitKey);\n         emitKey.append(\"/\");\n         String dirPath = addSubDirs(embeddedPath);\n@@ -115,6 +119,41 @@\n         return sb.toString();\n     }\n \n+    /**\n+     * Sanitizes an embedded path to prevent path traversal attacks.\n+     * Removes all \".\", \"..\", and empty path components.\n+     *\n+     * @param path the embedded path to sanitize\n+     * @return sanitized path with only safe components\n+     */\n+    private String sanitizeEmbeddedPath(String path) {\n+        if (path == null || path.isEmpty()) {\n+            return \"\";\n+        }\n+\n+        // Split by both forward and backward slashes\n+        String[] parts = path.split(\"[/\\\\\\\\]+\");\n+        StringBuilder sanitized = new StringBuilder();\n+\n+        for (String part : parts) {\n+            // Skip empty parts, \".\", and \"..\" to prevent traversal\n+            if (part.isEmpty() || part.equals(\".\") || part.equals(\"..\")) {\n+                continue;\n+            }\n+\n+            // Use FilenameUtils.normalize to sanitize reserved characters\n+            String normalizedPart = FilenameUtils.normalize(part);\n+            if (!normalizedPart.isEmpty()) {\n+                if (sanitized.length() > 0) {\n+                    sanitized.append(\"/\");\n+                }\n+                sanitized.append(normalizedPart);\n+            }\n+        }\n+\n+        return sanitized.toString();\n+    }\n+\n     private boolean containsAlphaNumeric(String part) {\n         for (char c : part.toCharArray()) {\n             if (Character.isAlphabetic(c) || Character.isDigit(c)) {\n",
  "stdout": "",
  "stderr": ""
}