--- a/epan/dissectors/packet-gvcp.c
+++ b/epan/dissectors/packet-gvcp.c
@@ -981,8 +981,10 @@
 	uint32_t value = 0;
 	
 	value = tvb_get_letohl(tvb, offset);
-	gvcp_register_number[gvcp_register_count] = addr;
-	gvcp_register_value[gvcp_register_count++] = value;
+	if (gvcp_register_count < GVCP_MAX_REGISTER_COUNT) {
+		gvcp_register_number[gvcp_register_count] = addr;
+		gvcp_register_value[gvcp_register_count++] = value;
+	}
 
 	switch (addr)
 	{
@@ -1496,8 +1498,10 @@
 	uint32_t value = 0;
 	
 	value = tvb_get_letohl(tvb, offset);
-	gvcp_register_number[gvcp_register_count] = addr;
-	gvcp_register_value[gvcp_register_count++] = value;
+	if (gvcp_register_count < GVCP_MAX_REGISTER_COUNT) {
+		gvcp_register_number[gvcp_register_count] = addr;
+		gvcp_register_value[gvcp_register_count++] = value;
+	}
 
 	switch (addr)
 	{
@@ -1782,6 +1786,11 @@
 	bool is_custom_register = false;
 	int num_registers = length / 8; /* divide by 8 because we are counting register-value pairs */
 	proto_tree *subtree = NULL;
+
+	/* Clamp num_registers to remaining capacity */
+	if (num_registers > (int)(GVCP_MAX_REGISTER_COUNT - gvcp_register_count)) {
+		num_registers = (int)(GVCP_MAX_REGISTER_COUNT - gvcp_register_count);
+	}
 
 	if (gvcp_trans)
 	{
@@ -2273,6 +2282,11 @@
 
 	offset = startoffset;
 	num_registers = length / 4;
+
+	/* Clamp num_registers to remaining capacity */
+	if (num_registers > (GVCP_MAX_REGISTER_COUNT - gvcp_register_count)) {
+		num_registers = GVCP_MAX_REGISTER_COUNT - gvcp_register_count;
+	}
 
 	if (gvcp_trans && gvcp_trans->addr_list)
 	{
@@ -2538,6 +2552,9 @@
 		return 0;
 	}
 
+	/* Reset global register counter for new packet */
+	gvcp_register_count = 0;
+
 	/* check for valid key/ack code */
 	key_code = (char) tvb_get_uint8(tvb, offset);
 	ack_code = tvb_get_ntohs(tvb, offset+2);
