--- a/epan/dissectors/packet-gvcp.c
+++ b/epan/dissectors/packet-gvcp.c
@@ -980,6 +980,10 @@
 {
 	uint32_t value = 0;
 	
+	if (gvcp_register_count >= GVCP_MAX_REGISTER_COUNT) {
+		return offset + length;
+	}
+	
 	value = tvb_get_letohl(tvb, offset);
 	gvcp_register_number[gvcp_register_count] = addr;
 	gvcp_register_value[gvcp_register_count++] = value;
@@ -1495,6 +1499,10 @@
 {
 	uint32_t value = 0;
 	
+	if (gvcp_register_count >= GVCP_MAX_REGISTER_COUNT) {
+		return offset + length;
+	}
+	
 	value = tvb_get_letohl(tvb, offset);
 	gvcp_register_number[gvcp_register_count] = addr;
 	gvcp_register_value[gvcp_register_count++] = value;
@@ -1700,6 +1708,10 @@
 	int offset = startoffset;
 	int i;
 	int num_registers = length / 4;
+
+	if (num_registers > GVCP_MAX_REGISTER_COUNT) {
+		num_registers = GVCP_MAX_REGISTER_COUNT;
+	}
 
 	addr = tvb_get_ntohl(tvb, offset);
 	address_string = get_register_name_from_address(addr, pinfo->pool, gvcp_info, &is_custom_register);
@@ -1782,6 +1794,10 @@
 	bool is_custom_register = false;
 	int num_registers = length / 8; /* divide by 8 because we are counting register-value pairs */
 	proto_tree *subtree = NULL;
+
+	if (num_registers > GVCP_MAX_REGISTER_COUNT) {
+		num_registers = GVCP_MAX_REGISTER_COUNT;
+	}
 
 	if (gvcp_trans)
 	{
@@ -2273,6 +2289,10 @@
 
 	offset = startoffset;
 	num_registers = length / 4;
+
+	if (num_registers > GVCP_MAX_REGISTER_COUNT) {
+		num_registers = GVCP_MAX_REGISTER_COUNT;
+	}
 
 	if (gvcp_trans && gvcp_trans->addr_list)
 	{
@@ -2533,6 +2553,8 @@
 	gvcp_conv_info_t *gvcp_info = 0;
 	gvcp_transaction_t *gvcp_trans = 0;
 
+	gvcp_register_count = 0;
+
 	if (tvb_captured_length(tvb) <  GVCP_MIN_PACKET_SIZE)
 	{
 		return 0;
