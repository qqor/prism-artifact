{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_8",
  "source_directory": "/home/user/aixcc/crete/.cache/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 0.8223952,
    "prompt_tokens": 528940,
    "completion_tokens": 54673
  },
  "variant": "sound",
  "diff": "--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java\n@@ -1053,10 +1053,15 @@\n     {\n         skipSpaces();\n         StringBuilder buffer = new StringBuilder();\n+        int tokenLen = 0;\n         int c = source.read();\n         while (!isEndOfName(c))\n         {\n-            buffer.append( (char)c );\n+            buffer.append((char)c);\n+            if (++tokenLen > 4096)\n+            {\n+                throw new IOException(\"Token too long (> 4096)\");\n+            }\n             c = source.read();\n         }\n         if (c != -1)\n@@ -1163,11 +1168,12 @@\n     {\n         if (source.isEOF())\n         {\n-            throw new IOException( \"Error: End-of-File, expected line at offset \" +\n+            throw new IOException(\"Error: End-of-File, expected line at offset \" +\n                     source.getPosition());\n         }\n \n-        StringBuilder buffer = new StringBuilder( 11 );\n+        StringBuilder buffer = new StringBuilder(11);\n+        int lineLen = 0;\n \n         int c;\n         while ((c = source.read()) != -1)\n@@ -1177,7 +1183,11 @@\n             {\n                 break;\n             }\n-            buffer.append( (char)c );\n+            if (++lineLen > 16384)\n+            {\n+                throw new IOException(\"Line too long (> 16384)\");\n+            }\n+            buffer.append((char)c);\n         }\n         // CR+LF is also a valid EOL \n         if (isCR(c) && isLF(source.peek()))\n\n--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/XrefParser.java\n@@ -583,23 +583,26 @@\n             return false;\n         }\n         \n-        // check for trailer after xref\n-        String str = parser.readString();\n-        byte[] b = str.getBytes(StandardCharsets.ISO_8859_1);\n-        source.seek(source.getPosition() - b.length);\n-        \n         // signal start of new XRef\n-        xrefTrailerResolver.nextXrefObj( startByteOffset, XRefType.TABLE );\n-    \n-        if (str.startsWith(\"trailer\"))\n-        {\n+        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);\n+\n+        // detect empty xref table via 'trailer' keyword\n+        if (parser.isString(\"trailer\".toCharArray()))\n+        {\n+            // consume 'trailer'\n+            parser.readString();\n             LOG.warn(\"skipping empty xref table\");\n             return false;\n         }\n-        \n+        int xrefLineCount = 0;\n         // Xref tables can have multiple sections. Each starts with a starting object id and a count.\n         while(true)\n         {\n+            if (++xrefLineCount > 100000)\n+            {\n+                LOG.warn(\"XRef table too large (>{} lines), aborting parse\", 100000);\n+                return false;\n+            }\n             String currentLine = parser.readLine();\n             String[] splitString = currentLine.split(\"\\\\s\");\n             if (splitString.length != 2)\n",
  "stdout": "",
  "stderr": ""
}