--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
@@ -214,12 +214,19 @@
             // 0 1 255 {1 index exch /.notdef put } for
             // we have to check "readonly" and "def" too
             // as some fonts don't provide any dup-values, see PDFBOX-2134
-            while (!(lexer.peekKind(Token.NAME)
-                    && (lexer.peekToken().getText().equals("dup")
-                            || lexer.peekToken().getText().equals("readonly")
-                            || lexer.peekToken().getText().equals("def"))))
-            {
+            // safe skip loop: stop on EOF or a marker NAME token
+            while (lexer.peekToken() != null) {
+                if (lexer.peekKind(Token.NAME)) {
+                    String t = lexer.peekToken().getText();
+                    if ("dup".equals(t) || "readonly".equals(t) || "def".equals(t)) {
+                        break;
+                    }
+                }
                 lexer.nextToken();
+            }
+            // if we ran out of tokens before finding a marker, abort
+            if (lexer.peekToken() == null) {
+                throw new IOException("Unexpected end of encoding data");
             }
             
             Map<Integer, String> codeToName = new HashMap<>();
