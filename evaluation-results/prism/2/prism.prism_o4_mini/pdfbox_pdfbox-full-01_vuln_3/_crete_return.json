{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_3",
  "source_directory": "/tasks_new/pdfbox_pdfbox-full-01/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 1.0937564000000002,
    "prompt_tokens": 670716,
    "completion_tokens": 80902
  },
  "variant": "sound",
  "diff": "--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java\n+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java\n@@ -41,6 +41,8 @@\n     private final int[] w = new int[3];\n     private ObjectNumbers objectNumbers = null;\n     private final RandomAccessRead source;\n+    private static final long MAX_XREF_ENTRIES = 1_000_000L;\n+    private static final int MAX_W_SUM = 1024;\n \n     /**\n      * Constructor.\n@@ -83,7 +85,11 @@\n         {\n             throw new IOException(\"Incorrect /W array in XRef: \" + Arrays.toString(w));\n         }\n-\n+        long wSum = (long) w[0] + w[1] + w[2];\n+        if (wSum == 0 || wSum > MAX_W_SUM)\n+        {\n+            throw new IOException(\"XRef stream field width sum is unreasonable: \" + wSum);\n+        }\n         COSArray indexArray = stream.getCOSArray(COSName.INDEX);\n         if (indexArray == null)\n         {\n@@ -118,9 +124,14 @@\n      */\n     public void parse(XrefTrailerResolver resolver) throws IOException\n     {\n+        long processedEntries = 0L;\n         byte[] currLine = new byte[w[0] + w[1] + w[2]];\n         while (!source.isEOF() && objectNumbers.hasNext())\n         {\n+            if (++processedEntries > MAX_XREF_ENTRIES)\n+            {\n+                throw new IOException(\"Too many XRef entries processed: \" + processedEntries);\n+            }\n             readNextValue(currLine);\n             // get the current objID\n             long objID = objectNumbers.next();\n\n--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -43,6 +43,8 @@\n     // constants for encryption\n     private static final int EEXEC_KEY = 55665;\n     private static final int CHARSTRING_KEY = 4330;\n+    private static final int MAX_ENCODING_SKIP_TOKENS = 10000;\n+    private static final int MAX_ENCODING_ENTRIES = 256;\n \n     // state\n     private Type1Lexer lexer;\n@@ -214,23 +216,38 @@\n             // 0 1 255 {1 index exch /.notdef put } for\n             // we have to check \"readonly\" and \"def\" too\n             // as some fonts don't provide any dup-values, see PDFBOX-2134\n-            while (!(lexer.peekKind(Token.NAME)\n-                    && (lexer.peekToken().getText().equals(\"dup\")\n-                            || lexer.peekToken().getText().equals(\"readonly\")\n-                            || lexer.peekToken().getText().equals(\"def\"))))\n-            {\n+            int skipCount = 0;\n+            while (true)\n+            {\n+                if (!lexer.peekKind(Token.NAME))\n+                {\n+                    throw new IOException(\"Unexpected EOF in encoding\");\n+                }\n+                String tokenText = lexer.peekToken().getText();\n+                if (\"dup\".equals(tokenText) || \"readonly\".equals(tokenText) || \"def\".equals(tokenText))\n+                {\n+                    break;\n+                }\n                 lexer.nextToken();\n+                if (++skipCount > MAX_ENCODING_SKIP_TOKENS)\n+                {\n+                    throw new IOException(\"Too many tokens before encoding definition: \" + skipCount);\n+                }\n             }\n             \n             Map<Integer, String> codeToName = new HashMap<>();\n-            while (lexer.peekKind(Token.NAME) &&\n-                    lexer.peekToken().getText().equals(\"dup\"))\n+            int entryCount = 0;\n+            while (lexer.peekKind(Token.NAME) && lexer.peekToken().getText().equals(\"dup\"))\n             {\n                 read(Token.NAME, \"dup\");\n                 int code = read(Token.INTEGER).intValue();\n                 String name = read(Token.LITERAL).getText();\n                 read(Token.NAME, \"put\");\n                 codeToName.put(code, name);\n+                if (++entryCount > MAX_ENCODING_ENTRIES)\n+                {\n+                    throw new IOException(\"Too many encoding entries: \" + entryCount);\n+                }\n             }\n             font.encoding = new BuiltInEncoding(codeToName);\n             readMaybe(Token.NAME, \"readonly\");\n",
  "stdout": "",
  "stderr": ""
}