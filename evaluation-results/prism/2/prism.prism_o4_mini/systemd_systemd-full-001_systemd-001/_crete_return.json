{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd_systemd-full-001_systemd-001",
  "source_directory": "/tasks_new/systemd_systemd-full-001/official-afc-systemd",
  "llm_usage": {
    "total_cost": 0.1636437,
    "prompt_tokens": 63991,
    "completion_tokens": 21194
  },
  "variant": "sound",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -1182,15 +1182,23 @@\n                 }\n                 /*\n                  * The return value must be terminated by two subsequent NULs\n-                 * so it could be safely interpreted as nulstr.\n+                * so it could be safely interpreted as nulstr.\n                  */\n-                if (is_prefix_match){\n-                        j[0] = '*';\n-                        j[1] = '\\0';\n-                        j[2] = '\\0';\n-                } else {\n-                        j[0] = '\\0';\n-                        j[1] = '\\0';\n+                {\n+                        char *orig_buf = str;\n+                        char *alloc_end = orig_buf + strlen(orig_buf);\n+                        if (is_prefix_match) {\n+                                if (j + 2 > alloc_end)\n+                                        return -ENOBUFS;\n+                                j[0] = '*';\n+                                j[1] = '\\0';\n+                                j[2] = '\\0';\n+                        } else {\n+                                if (j + 1 > alloc_end)\n+                                        return -ENOBUFS;\n+                                j[0] = '\\0';\n+                                j[1] = '\\0';\n+                        }\n                 }\n                 str = m;            \n         } else {\n@@ -1216,6 +1224,10 @@\n                 * so it could be safely interpreted as nulstr.\n                 */\n                 if (is_prefix_match){\n+                        char *orig_buf = str;\n+                        char *alloc_end = orig_buf + strlen(orig_buf);\n+                        if (orig_buf + pos + l + 1 > alloc_end)\n+                                return -ENOBUFS;\n                         /* need more room to make rule glob match */\n                         memcpy(str + pos - 1, unescaped, l + 1);\n                         str[pos + l - 1] = '*';\n",
  "stdout": "",
  "stderr": ""
}