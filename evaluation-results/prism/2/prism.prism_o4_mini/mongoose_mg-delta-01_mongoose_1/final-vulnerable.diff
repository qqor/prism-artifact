--- a/src/fmt.c
+++ b/src/fmt.c
@@ -245,6 +245,7 @@
 size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
                    va_list *ap) {
   size_t i = 0, n = 0;
+  char scratch[128];
   while (fmt[i] != '\0') {
     if (fmt[i] == '%') {
       size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;
@@ -315,17 +316,34 @@
         for (j = 0; minus && pr < w && j + pr < w; j++)
           n += scpy(out, param, &pad, 1);
       } else if (c == 'e' || c == 'E') {
-		  char tmp[8];
-          double d = va_arg(*ap, double);
-          int64_t exponent = (int64_t)log10(my_fabs(d));
-          double mantissa = d / power(10, exponent);
-          k = mg_dtoa(tmp, 10, mantissa, 8, c == 'e');
-          n += scpy(out, param, tmp, k);
-          out(c, param);
-          n++;
-		  k = mg_lld(tmp, exponent, 1, 0);
-          n += scpy(out, param, tmp, k);
-	  } else if (c == '%') {
+        /* Format in shared scratch buffer */
+        double d = va_arg(*ap, double);
+        int64_t exponent = (int64_t) log10(my_fabs(d));
+        double mantissa = d / power(10, exponent);
+
+        /* Mantissa */
+        k = mg_dtoa(scratch, sizeof(scratch), mantissa, 8, c == 'e');
+        if (k >= (int) sizeof(scratch)) k = (int) sizeof(scratch) - 1;
+        scratch[k] = '\0';
+        n += scpy(out, param, scratch, k);
+
+        /* Exponent marker */
+        out(c, param);
+        n++;
+
+        /* Clamp exponent magnitude to buffer capacity */
+        {
+          size_t cap = sizeof(scratch) - 1;
+          if (exponent > (int64_t) cap) exponent = (int64_t) cap;
+          if (exponent < -(int64_t)(cap - 1)) exponent = -(int64_t)(cap - 1);
+        }
+
+        /* Exponent */
+        k = mg_lld(scratch, exponent, 1, 0);
+        if (k >= (int) sizeof(scratch)) k = (int) sizeof(scratch) - 1;
+        scratch[k] = '\0';
+        n += scpy(out, param, scratch, k);
+      } else if (c == '%') {
         out('%', param);
         n++;
       } else {
