{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_6",
  "source_directory": "/tasks_new/pdfbox_pdfbox-full-01/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 1.2203488,
    "prompt_tokens": 524372,
    "completion_tokens": 146259
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/pfb/PfbParser.java\n@@ -92,7 +92,9 @@\n      */\n     public PfbParser(final String filename) throws IOException \n     {\n-        this(Files.readAllBytes(Paths.get(filename)));\n+        try (java.io.InputStream in = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(filename))) {\n+            parsePfbStream(in);\n+        }\n     }\n \n     /**\n@@ -102,8 +104,7 @@\n      */\n     public PfbParser(final InputStream in) throws IOException \n     {\n-        byte[] pfb = in.readAllBytes();\n-        parsePfb(pfb);\n+        parsePfbStream(in);\n     }\n \n     /**\n@@ -123,101 +124,79 @@\n      */\n     private void parsePfb(final byte[] pfb) throws IOException \n     {\n-        if (pfb.length < PFB_HEADER_LENGTH)\n-        {\n-            throw new IOException(\"PFB header missing\");\n-        }\n-        // read into segments and keep them\n+        try (ByteArrayInputStream bais = new ByteArrayInputStream(pfb)) {\n+            parsePfbStream(bais);\n+        }\n+    }\n+\n+    /**\n+     * Stream-based PFB parsing: reads segment-by-segment without pre-loading the entire font.\n+     */\n+    private void parsePfbStream(InputStream in) throws IOException {\n+        java.io.DataInputStream dataIn = new java.io.DataInputStream(in);\n         List<Integer> typeList = new ArrayList<>(3);\n         List<byte[]> barrList = new ArrayList<>(3);\n-        ByteArrayInputStream in = new ByteArrayInputStream(pfb);\n         int total = 0;\n-        do\n-        {\n-            int r = in.read();\n-            if (r == -1 && total > 0)\n-            {\n-                break; // EOF\n-            }\n-            if (r != START_MARKER) \n-            {\n+        while (true) {\n+            int marker = dataIn.read();\n+            if (marker == -1) {\n+                if (total > 0) {\n+                    break; // normal EOF\n+                }\n+                throw new java.io.EOFException(\"Unexpected EOF in PFB header\");\n+            }\n+            if (marker != START_MARKER) {\n                 throw new IOException(\"Start marker missing\");\n             }\n-            int recordType = in.read();\n-            if (recordType == EOF_MARKER)\n-            {\n+            int recordType = dataIn.read();\n+            if (recordType == EOF_MARKER) {\n                 break;\n             }\n-            if (recordType != ASCII_MARKER && recordType != BINARY_MARKER)\n-            {\n+            if (recordType != ASCII_MARKER && recordType != BINARY_MARKER) {\n                 throw new IOException(\"Incorrect record type: \" + recordType);\n             }\n-\n-            int size = in.read();\n-            size += in.read() << 8;\n-            size += in.read() << 16;\n-            size += in.read() << 24;\n-            LOG.debug(\"record type: {}, segment size: {}\", recordType, size);\n-            long newTotal = total + size;\n-            if (newTotal > MAX_LENGTH) {\n-                throw new IOException(\"record size would be too large: \" + newTotal);\n-            }\n-\n-            byte[] ar = new byte[size];\n-            int got = in.read(ar);\n-            if (got != size)\n-            {\n-                throw new EOFException(\"EOF while reading PFB font\");\n-            }\n+            int size = (dataIn.read() & 0xFF)\n+                     | ((dataIn.read() & 0xFF) << 8)\n+                     | ((dataIn.read() & 0xFF) << 16)\n+                     | ((dataIn.read() & 0xFF) << 24);\n+            if ((long) total + size > MAX_LENGTH) {\n+                throw new IOException(\"record size would be too large: \" + ((long) total + size));\n+            }\n+            byte[] segment = new byte[size];\n+            dataIn.readFully(segment);\n             total += size;\n             typeList.add(recordType);\n-            barrList.add(ar);\n-        }\n-        while (true);\n-        \n-        // We now have ASCII and binary segments. Lets arrange these so that the ASCII segments\n-        // come first, then the binary segments, then the last ASCII segment if it is\n-        // 0000... cleartomark\n-        \n+            barrList.add(segment);\n+        }\n+\n         pfbdata = new byte[total];\n-        byte[] cleartomarkSegment = null;\n-        int dstPos = 0;\n-        \n-        // copy the ASCII segments\n-        for (int i = 0; i < typeList.size(); ++i)\n-        {\n-            if (typeList.get(i) != ASCII_MARKER)\n-            {\n+        byte[] cleartomark = null;\n+        int dst = 0;\n+        for (int i = 0; i < typeList.size(); i++) {\n+            if (typeList.get(i) != ASCII_MARKER) {\n                 continue;\n             }\n-            byte[] ar = barrList.get(i);\n-            if (i == typeList.size() - 1 && ar.length < 600 && new String(ar).contains(\"cleartomark\"))\n-            {\n-                cleartomarkSegment = ar;\n+            byte[] seg = barrList.get(i);\n+            if (i == typeList.size() - 1 && seg.length < 600 && new String(seg).contains(\"cleartomark\")) {\n+                cleartomark = seg;\n                 continue;\n             }\n-            System.arraycopy(ar, 0, pfbdata, dstPos, ar.length);\n-            dstPos += ar.length;\n-        }\n-        lengths[0] = dstPos;\n-\n-        // copy the binary segments\n-        for (int i = 0; i < typeList.size(); ++i)\n-        {\n-            if (typeList.get(i) != BINARY_MARKER)\n-            {\n+            System.arraycopy(seg, 0, pfbdata, dst, seg.length);\n+            dst += seg.length;\n+        }\n+        lengths[0] = dst;\n+        for (int i = 0; i < typeList.size(); i++) {\n+            if (typeList.get(i) != BINARY_MARKER) {\n                 continue;\n             }\n-            byte[] ar = barrList.get(i);\n-            System.arraycopy(ar, 0, pfbdata, dstPos, ar.length);\n-            dstPos += ar.length;\n-        }\n-        lengths[1] = dstPos - lengths[0];\n-        \n-        if (cleartomarkSegment != null)\n-        {\n-            System.arraycopy(cleartomarkSegment, 0, pfbdata, dstPos, cleartomarkSegment.length);\n-            lengths[2] = cleartomarkSegment.length;\n+            byte[] seg = barrList.get(i);\n+            System.arraycopy(seg, 0, pfbdata, dst, seg.length);\n+            dst += seg.length;\n+        }\n+        lengths[1] = dst - lengths[0];\n+        if (cleartomark != null) {\n+            System.arraycopy(cleartomark, 0, pfbdata, dst, cleartomark.length);\n+            lengths[2] = cleartomark.length;\n         }\n     }\n \n",
  "stdout": "",
  "stderr": ""
}