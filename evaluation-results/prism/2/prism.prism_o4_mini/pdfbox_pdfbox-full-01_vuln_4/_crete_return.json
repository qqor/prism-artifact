{
  "project_name": "pdfbox",
  "vulnerability_identifier": "pdfbox_pdfbox-full-01_vuln_4",
  "source_directory": "/tasks_new/pdfbox_pdfbox-full-01/official-afc-pdfbox",
  "llm_usage": {
    "total_cost": 0.20792200000000002,
    "prompt_tokens": 113860,
    "completion_tokens": 18790
  },
  "variant": "sound",
  "diff": "--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java\n@@ -540,6 +540,10 @@\n      */\n     private void parseBinary(byte[] bytes) throws IOException\n     {\n+        final int MAX_EEXEC_SEGMENT_SIZE = 50 * 1024 * 1024;\n+        if (bytes.length > MAX_EEXEC_SEGMENT_SIZE) {\n+            throw new IOException(\"Binary segment too large: \" + bytes.length);\n+        }\n         byte[] decrypted;\n         // Sometimes, fonts use the hex format, so this needs to be converted before decryption\n         if (isBinary(bytes))\n@@ -634,15 +638,17 @@\n             }\n         }\n \n-        // some fonts have \"2 index\" here, others have \"end noaccess put\"\n-        // sometimes followed by \"put\". Either way, we just skip until\n-        // the /CharStrings dict is found\n-        while (!(lexer.peekKind(Token.LITERAL)\n-                && lexer.peekToken().getText().equals(\"CharStrings\")))\n-        {\n+        Token peek;\n+        while ((peek = lexer.peekToken()) != null) {\n+            if (peek.getKind() == Token.LITERAL\n+                && \"CharStrings\".equals(peek.getText())) {\n+                break;\n+            }\n             lexer.nextToken();\n         }\n-\n+        if (peek == null) {\n+            throw new IOException(\"/CharStrings token not found\");\n+        }\n         // CharStrings dict\n         read(Token.LITERAL, \"CharStrings\");\n         readCharStrings(lenIV);\n@@ -707,6 +713,9 @@\n     {\n         // allocate size (array indexes may not be in-order)\n         int length = read(Token.INTEGER).intValue();\n+        if (length < 0 || length > 10_000) {\n+            throw new IOException(\"Invalid Subrs count: \" + length);\n+        }\n         for (int i = 0; i < length; i++)\n         {\n             font.subrs.add(null);\n@@ -777,6 +786,9 @@\n     private void readCharStrings(int lenIV) throws IOException\n     {\n         int length = read(Token.INTEGER).intValue();\n+        if (length < 0 || length > 100_000) {\n+            throw new IOException(\"Invalid CharStrings count: \" + length);\n+        }\n         read(Token.NAME, \"dict\");\n         // could actually be a sequence ending in \"CharStrings begin\", too\n         // instead of the \"dup begin\"\n",
  "stdout": "",
  "stderr": ""
}