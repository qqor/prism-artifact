{
  "project_name": "libexif",
  "vulnerability_identifier": "libexif_ex-delta-01_exif-005",
  "source_directory": "/home/user/crete/.cache/official-afc-libexif",
  "llm_usage": {
    "total_cost": 0.2475374,
    "prompt_tokens": 121070,
    "completion_tokens": 25991
  },
  "variant": "sound",
  "diff": "--- a/libexif/apple/exif-mnote-data-apple.c\n+++ b/libexif/apple/exif-mnote-data-apple.c\n@@ -70,6 +70,12 @@\n \n     /* Start of interesting data */\n     ofs = d->offset + 6;\n+    /* Guard for byte-order header */\n+    if (ofs + 14 > buf_size) {\n+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+                 \"ExifMnoteDataApple\", \"MakerNote too small for byte-order header\");\n+        return;\n+    }\n \n     if ((buf[ofs + 12] == 'M') && (buf[ofs + 13] == 'M')) {\n         d->order = EXIF_BYTE_ORDER_MOTOROLA;\n@@ -107,15 +113,30 @@\n     }\n \n     for (i = 0; i < tcount; i++) {\n-        d->entries[i].tag = exif_get_short(buf + ofs, d->order);\n-        d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);\n-        d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);\n-        d->entries[i].order = d->order;\n+        size_t entry_ofs = ofs + i * 12;\n+        /* Ensure we can read 12-byte entry header */\n+        if (entry_ofs + 12 > buf_size) {\n+            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+                     \"ExifMnoteDataApple\", \"Directory entry %u past end of buffer\", i);\n+            break;\n+        }\n+        d->entries[i].tag        = exif_get_short(buf + entry_ofs,     d->order);\n+        d->entries[i].format     = exif_get_short(buf + entry_ofs + 2, d->order);\n+        d->entries[i].components = exif_get_long (buf + entry_ofs + 4, d->order);\n+        d->entries[i].order      = d->order;\n         dsize = exif_format_get_size(d->entries[i].format) * d->entries[i].components;\n         if (dsize > 4) {\n-            dofs = d->offset + exif_get_long(buf + ofs + 8, d->order);\n+            dofs = d->offset + exif_get_long(buf + entry_ofs + 8, d->order);\n         } else {\n-            dofs = ofs + 8;\n+            dofs = entry_ofs + 8;\n+        }\n+        /* Ensure full data block fits */\n+        if (dofs + dsize > buf_size) {\n+            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+                     \"ExifMnoteDataApple\",\n+                     \"Tag data %u past end of buffer (%zu >= %zu)\",\n+                     d->entries[i].tag, (size_t)(dofs + dsize), buf_size);\n+            continue;\n         }\n \tif (dofs > buf_size) {\n \t\texif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,\n",
  "stdout": "",
  "stderr": ""
}