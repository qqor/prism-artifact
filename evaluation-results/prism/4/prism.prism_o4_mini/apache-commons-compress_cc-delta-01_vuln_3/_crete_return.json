{
  "project_name": "apache-commons-compress",
  "vulnerability_identifier": "apache-commons-compress_cc-delta-01_vuln_3",
  "source_directory": "/home/qqor/crete/.cache/official-afc-commons-compress",
  "llm_usage": {
    "total_cost": 0.6621505000000002,
    "prompt_tokens": 388139,
    "completion_tokens": 53454
  },
  "variant": "sound",
  "diff": "--- a/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSet.java\n@@ -22,7 +22,7 @@\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Set;\n-import java.util.regex.Pattern;\n+// import java.util.regex.Pattern;\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.changes.Change.ChangeType;\n@@ -100,8 +100,8 @@\n             return;\n         }\n         final String source = deleteChange.getTargetFileName();\n-        final Pattern pattern = Pattern.compile(source + \"/.*\");\n-        if (source != null && !changes.isEmpty()) {\n+        final String prefix = source + \"/\";\n+        if (!changes.isEmpty()) {\n             for (final Iterator<Change<E>> it = changes.iterator(); it.hasNext();) {\n                 final Change<E> change = it.next();\n                 if (change.getType() == ChangeType.ADD && change.getEntry() != null) {\n@@ -109,8 +109,8 @@\n                     if (target == null) {\n                         continue;\n                     }\n-                    if (ChangeType.DELETE == deleteChange.getType() && source.equals(target)\n-                            || ChangeType.DELETE_DIR == deleteChange.getType() && pattern.matcher(target).matches()) {\n+                    if ((ChangeType.DELETE == deleteChange.getType() && source.equals(target))\n+                            || (ChangeType.DELETE_DIR == deleteChange.getType() && target.startsWith(prefix))) {\n                         it.remove();\n                     }\n                 }\n\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipSplitReadOnlySeekableByteChannel.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipSplitReadOnlySeekableByteChannel.java\n@@ -101,10 +101,28 @@\n         final String fileBaseName = FileNameUtils.getBaseName(lastSegmentPath);\n         final ArrayList<Path> splitZipSegments;\n         // ZIP split segments should be like z01,z02....z(n-1) based on the ZIP specification\n-        final Pattern pattern = Pattern.compile(Pattern.quote(fileBaseName) + \".[zZ][0-9]+\");\n+        final String prefix = fileBaseName + \".\";\n         try (Stream<Path> walk = Files.walk(parent, 1)) {\n-            splitZipSegments = walk.filter(Files::isRegularFile).filter(path -> pattern.matcher(path.getFileName().toString()).matches())\n-                    .sorted(new ZipSplitSegmentComparator()).collect(Collectors.toCollection(ArrayList::new));\n+            splitZipSegments = walk.filter(Files::isRegularFile).filter(path -> {\n+                String name = path.getFileName().toString();\n+                if (!name.startsWith(prefix)) {\n+                    return false;\n+                }\n+                String suffix = name.substring(prefix.length());\n+                if (suffix.length() < 2) {\n+                    return false;\n+                }\n+                char z = suffix.charAt(0);\n+                if (z != 'z' && z != 'Z') {\n+                    return false;\n+                }\n+                for (int i = 1; i < suffix.length(); i++) {\n+                    if (!Character.isDigit(suffix.charAt(i))) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }).sorted(new ZipSplitSegmentComparator()).collect(Collectors.toCollection(ArrayList::new));\n         }\n         return forPaths(lastSegmentPath, splitZipSegments);\n     }\n\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -219,8 +219,7 @@\n      * Since they are parsed into long values, maximum length of each is the same as Long.MAX_VALUE which is 19 digits.\n      * </p>\n      */\n-    private static final Pattern PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN = Pattern.compile(\n-            \"(-?(?:\\\\d{1,19}|(?:.|\\\\d)*))(?:\\\\.\\\\d{1,19})?\");\n+    private static final Pattern PAX_EXTENDED_HEADER_FILE_TIMES_PATTERN = Pattern.compile(\"-?\\\\d{1,19}(?:\\\\.\\\\d{1,19})?\");\n \n     private static FileTime fileTimeFromOptionalSeconds(final long seconds) {\n         return seconds <= 0 ? null : FileTimes.fromUnixTime(seconds);\n",
  "stdout": "",
  "stderr": ""
}