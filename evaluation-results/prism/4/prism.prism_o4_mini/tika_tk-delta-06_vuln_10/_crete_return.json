{
  "project_name": "tika",
  "vulnerability_identifier": "tika_tk-delta-06_vuln_10",
  "source_directory": "/home/qqor/crete/.cache/official-afc-tika",
  "llm_usage": {
    "total_cost": 0.3627866,
    "prompt_tokens": 185830,
    "completion_tokens": 35994
  },
  "variant": "sound",
  "diff": "--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CellFormatter.java\n+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CellFormatter.java\n@@ -37,6 +37,52 @@\n             \"&fraction_format=\\\"(?:(#{1,20}) )?(#{1,20})/(#{1,20})\\\"\");\n \n     private final Matcher fractionFormatMatcher = FRACTION_FORMAT.matcher(\"\");\n+\n+    private static final int MAX_DENOMINATOR_LENGTH = 8;\n+\n+    private static int[] approximateFraction(double value, int maxDenominator) {\n+        int sign = value < 0 ? -1 : 1;\n+        value = Math.abs(value);\n+        if (Double.isNaN(value) || Double.isInfinite(value)) {\n+            return new int[]{0, 1};\n+        }\n+        int numerator0 = 0;\n+        int numerator1 = 1;\n+        int denominator0 = 1;\n+        int denominator1 = 0;\n+        double x = value;\n+        while (true) {\n+            int a = (int) Math.floor(x);\n+            int denom2 = a * denominator1 + denominator0;\n+            if (denom2 > maxDenominator) {\n+                break;\n+            }\n+            int num2 = a * numerator1 + numerator0;\n+            numerator0 = numerator1;\n+            numerator1 = num2;\n+            denominator0 = denominator1;\n+            denominator1 = denom2;\n+            double fracPart = x - a;\n+            if (fracPart == 0) {\n+                break;\n+            }\n+            x = 1.0 / fracPart;\n+        }\n+        double err1 = (denominator1 != 0) ? Math.abs((double) numerator1 / denominator1 - value)\n+                                         : Double.MAX_VALUE;\n+        double err0 = (denominator0 != 0) ? Math.abs((double) numerator0 / denominator0 - value)\n+                                         : Double.MAX_VALUE;\n+        int finalNum;\n+        int finalDen;\n+        if (denominator1 != 0 && err1 < err0) {\n+            finalNum = numerator1;\n+            finalDen = denominator1;\n+        } else {\n+            finalNum = numerator0;\n+            finalDen = denominator0;\n+        }\n+        return new int[]{sign * finalNum, finalDen};\n+    }\n     String format(String cell) {\n         if (cell == null) {\n             cell = \"\";\n@@ -61,18 +107,13 @@\n         double decPart = Math.abs(val) - wholePart;\n         int denomLength = denomFormat.length();\n \n-        double minVal = 1.0;\n-        double currDenom = Math.pow(10, denomLength) - 1d;\n-        double currNum = 0;\n-        for (int i = (int)(Math.pow(10, denomLength) - 1d); i > 0; i--) {\n-            for (int i2 = (int)(Math.pow(10, denomLength) - 1d); i2 >= 0; i2--) {\n-                if (minVal >= Math.abs((double)i2 / (double)i - decPart)) {\n-                    currDenom = i;\n-                    currNum = i2;\n-                    minVal = Math.abs((double) i2 / (double) i - decPart);\n-                }\n-            }\n+        if (denomLength > MAX_DENOMINATOR_LENGTH) {\n+            denomLength = MAX_DENOMINATOR_LENGTH;\n         }\n+        int maxDenominator = (int) Math.pow(10, denomLength) - 1;\n+        int[] frac = approximateFraction(decPart, maxDenominator);\n+        double currNum = frac[0];\n+        double currDenom = frac[1];\n         sign = (sign == null) ? \"\" : sign;\n         wholeFormat = (wholeFormat == null) ? \"#\" : wholeFormat;\n \n",
  "stdout": "",
  "stderr": ""
}