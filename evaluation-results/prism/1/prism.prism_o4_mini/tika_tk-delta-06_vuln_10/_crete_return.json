{
  "project_name": "tika",
  "vulnerability_identifier": "tika_tk-delta-06_vuln_10",
  "source_directory": "/home/qqor/crete/.cache/official-afc-tika",
  "llm_usage": {
    "total_cost": 0.16507480000000002,
    "prompt_tokens": 85012,
    "completion_tokens": 16264
  },
  "variant": "sound",
  "diff": "--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CellFormatter.java\n+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CellFormatter.java\n@@ -32,6 +32,7 @@\n \n     //this intentionally limits integer precision and fraction formats to a reasonable\n     //size to limit excessive computation\n+    private static final int MAX_DENOM_LENGTH = 4;\n     private static final Pattern FRACTION_FORMAT =\n             Pattern.compile(\"([+-])?(\\\\d{0,20}(?:\\\\.\\\\d{0,20})?) \" +\n             \"&fraction_format=\\\"(?:(#{1,20}) )?(#{1,20})/(#{1,20})\\\"\");\n@@ -61,15 +62,33 @@\n         double decPart = Math.abs(val) - wholePart;\n         int denomLength = denomFormat.length();\n \n-        double minVal = 1.0;\n-        double currDenom = Math.pow(10, denomLength) - 1d;\n+        // 1) If there's no fractional component, simply format the whole part.\n+        if (decPart == 0.0d) {\n+            String safeSign = (sign == null) ? \"\" : sign;\n+            String safeWholeFormat = (wholeFormat == null) ? \"#\" : wholeFormat;\n+            NumberFormat wf = new DecimalFormat(safeWholeFormat, new DecimalFormatSymbols(Locale.US));\n+            return safeSign + wf.format(wholePart);\n+        }\n+        // 2) Reject overly large denominators to bound runtime.\n+        if (denomLength > MAX_DENOM_LENGTH) {\n+            return cell;\n+        }\n+\n+        int maxDenom = (int) Math.pow(10, denomLength) - 1;\n+        double minVal = 1.0d;\n+        double currDenom = maxDenom;\n         double currNum = 0;\n-        for (int i = (int)(Math.pow(10, denomLength) - 1d); i > 0; i--) {\n-            for (int i2 = (int)(Math.pow(10, denomLength) - 1d); i2 >= 0; i2--) {\n-                if (minVal >= Math.abs((double)i2 / (double)i - decPart)) {\n+outer:\n+        for (int i = maxDenom; i > 0; i--) {\n+            for (int i2 = maxDenom; i2 >= 0; i2--) {\n+                double diff = Math.abs((double) i2 / (double) i - decPart);\n+                if (diff < minVal) {\n                     currDenom = i;\n                     currNum = i2;\n-                    minVal = Math.abs((double) i2 / (double) i - decPart);\n+                    minVal = diff;\n+                    if (diff == 0.0d) {\n+                        break outer;\n+                    }\n                 }\n             }\n         }\n",
  "stdout": "",
  "stderr": ""
}