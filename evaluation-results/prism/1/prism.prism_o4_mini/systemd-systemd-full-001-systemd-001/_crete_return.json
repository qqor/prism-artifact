{
  "project_name": "systemd",
  "vulnerability_identifier": "systemd-systemd-full-001-systemd-001",
  "source_directory": "/tasks/4d0b56e5-fc68-40e3-9f6e-e14e62699c8b/official-afc-systemd",
  "llm_usage": {
    "total_cost": 0.2306513,
    "prompt_tokens": 76511,
    "completion_tokens": 33293
  },
  "variant": "sound",
  "diff": "--- a/src/udev/udev-rules.c\n+++ b/src/udev/udev-rules.c\n@@ -1184,6 +1184,14 @@\n                  * The return value must be terminated by two subsequent NULs\n                  * so it could be safely interpreted as nulstr.\n                  */\n+                /* boundary check */\n+                {\n+                    size_t buf_len = strlen(str);\n+                    size_t offset = j - str;\n+                    size_t needed = is_prefix_match ? 3 : 2;\n+                    if (offset + needed > buf_len + 1)\n+                        return -EINVAL;\n+                }\n                 if (is_prefix_match){\n                         j[0] = '*';\n                         j[1] = '\\0';\n@@ -1217,6 +1225,17 @@\n                 */\n                 if (is_prefix_match){\n                         /* need more room to make rule glob match */\n+                        /* boundary check */\n+                        {\n+                            size_t buf_len = strlen(str);\n+                            size_t start = pos + l - 1;\n+                            size_t needed = 3;\n+                            if (start > buf_len + 1)\n+                                return -EINVAL;\n+                            size_t avail = buf_len + 1 - start;\n+                            if (avail < needed)\n+                                return -EINVAL;\n+                        }\n                         memcpy(str + pos - 1, unescaped, l + 1);\n                         str[pos + l - 1] = '*';\n                         str[pos + l] = '\\0';\n@@ -1224,6 +1243,14 @@\n                         m = str + pos - 1;\n \n                 } else {\n+                        /* boundary check */\n+                        {\n+                            size_t buf_len = strlen(str);\n+                            size_t offset = m - str;\n+                            size_t needed = 2;\n+                            if (offset + needed > buf_len + 1)\n+                                return -EINVAL;\n+                        }\n                         memcpy(m, unescaped, l + 1);\n                         m[l] = '\\0';\n                         m[l + 1] = '\\0';\n",
  "stdout": "",
  "stderr": ""
}