diff --git a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
index 9075a74db..9ba575155 100644
--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
@@ -152,10 +152,17 @@ class CSVSniffer {
             boolean eof = false;
             boolean hitMarkLimit = false;
             int lastC = -1;
+            int mainLoopIterations = 0;
             StringBuilder unquoted = new StringBuilder();
             try (PushbackReader reader = new PushbackReader(new CloseShieldReader(r), PUSH_BACK)) {
                 int c = read(reader);
                 while (c != EOF) {
+                    mainLoopIterations++;
+                    // Prevent infinite loops in main parsing loop
+                    // Use markLimit as upper bound since we can't read more chars than that
+                    if (mainLoopIterations > markLimit) {
+                        throw new HitMarkLimitException();
+                    }
                     if (c == quoteCharacter) {
                         handleUnquoted(unquoted);
                         //test to make sure there isn't an unencapsulated quote character
@@ -232,8 +239,14 @@ class CSVSniffer {
 
         void consumeSpaceCharacters(PushbackReader reader) throws IOException {
             int c = read(reader);
+            int iterations = 0;
             while (c == SPACE) {
                 c = read(reader);
+                iterations++;
+                // Prevent infinite loops - no legitimate CSV should have more than markLimit consecutive spaces
+                if (iterations > markLimit) {
+                    throw new HitMarkLimitException();
+                }
             }
             if (c == EOF) {
                 throw new UnsurprisingEOF();
@@ -256,7 +269,13 @@ class CSVSniffer {
             //we can make this more interesting later with other
             //escaping options
             int c = read(reader);
+            int iterations = 0;
             while (c != -1) {
+                iterations++;
+                // Prevent infinite loops - no legitimate quoted field should exceed markLimit characters
+                if (iterations > markLimit) {
+                    throw new HitMarkLimitException();
+                }
                 if (c == quoteCharacter) {
                     int nextC = read(reader);
                     if (nextC == EOF) {
@@ -311,8 +330,14 @@ class CSVSniffer {
         //consume all consecutive '\r\n' in any order
         void consumeNewLines(PushbackReader reader) throws IOException {
             int c = read(reader);
+            int iterations = 0;
             while (c == NEW_LINE || c == CARRIAGE_RETURN) {
                 c = read(reader);
+                iterations++;
+                // Prevent infinite loops - no legitimate CSV should have more than markLimit consecutive newlines
+                if (iterations > markLimit) {
+                    throw new HitMarkLimitException();
+                }
             }
             if (c == EOF) {
                 throw new EOFException();
