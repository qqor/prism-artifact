I tried to fix a timeout after 25 seconds vulnerability causing the crash log in the <crash_log> below.
I failed to fix the vulnerability with the following patches:

```diff
diff --git a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
index 9075a74db..740ca9e49 100644
--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
@@ -257,6 +257,10 @@ class CSVSniffer {
             //escaping options
             int c = read(reader);
             while (c != -1) {
+                if (charsRead >= markLimit - 1) {
+                    // Hit mark limit while parsing quoted field, treat as parse exception
+                    throw new HitMarkLimitException();
+                }
                 if (c == quoteCharacter) {
                     int nextC = read(reader);
                     if (nextC == EOF) {

``````diff
diff --git a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
index 9075a74db..d7b7ee261 100644
--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
@@ -143,6 +143,7 @@ class CSVSniffer {
         boolean rowZeroEmpty = false;
         int encapsulated = 0; //number of cells that are encapsulated in dquotes (for now)
         boolean parseException = false;
+        int loopIterations = 0; //track total iterations to prevent infinite loops
 
         public Snifflet(char delimiter) {
             this.delimiter = delimiter;
@@ -156,6 +157,11 @@ class CSVSniffer {
             try (PushbackReader reader = new PushbackReader(new CloseShieldReader(r), PUSH_BACK)) {
                 int c = read(reader);
                 while (c != EOF) {
+                    // Prevent infinite loops in main parsing loop
+                    loopIterations++;
+                    if (loopIterations > markLimit * 2) {
+                        throw new HitMarkLimitException();
+                    }
                     if (c == quoteCharacter) {
                         handleUnquoted(unquoted);
                         //test to make sure there isn't an unencapsulated quote character
@@ -233,6 +239,11 @@ class CSVSniffer {
         void consumeSpaceCharacters(PushbackReader reader) throws IOException {
             int c = read(reader);
             while (c == SPACE) {
+                // Prevent infinite loops
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    throw new HitMarkLimitException();
+                }
                 c = read(reader);
             }
             if (c == EOF) {
@@ -257,6 +268,13 @@ class CSVSniffer {
             //escaping options
             int c = read(reader);
             while (c != -1) {
+                // Prevent infinite loops by checking total loop iterations against a reasonable limit
+                // Use markLimit as the upper bound since we shouldn't loop more times than characters we can read
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    // If we've iterated more than twice the mark limit, something is wrong
+                    throw new HitMarkLimitException();
+                }
                 if (c == quoteCharacter) {
                     int nextC = read(reader);
                     if (nextC == EOF) {
@@ -312,6 +330,11 @@ class CSVSniffer {
         void consumeNewLines(PushbackReader reader) throws IOException {
             int c = read(reader);
             while (c == NEW_LINE || c == CARRIAGE_RETURN) {
+                // Prevent infinite loops
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    throw new HitMarkLimitException();
+                }
                 c = read(reader);
             }
             if (c == EOF) {

```

Explain why the patches failed and provide a new patch to fix the vulnerability.
Do not repeat the same mistakes in the new patch.
Try a completely different approach to fix the vulnerability.
NEVER fix files outside the source directory.
NEVER do any git operations in or outside the source directory.

Below is the crash log:

<crash_log>
== ERROR: libFuzzer: timeout after 25 seconds

Stack traces of all JVM threads:
Thread[Common-Cleaner,8,InnocuousThreadGroup]
	at java.base@17.0.2/java.lang.Object.wait(Native Method)
	at java.base@17.0.2/java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:155)
	at java.base@17.0.2/jdk.internal.ref.CleanerImpl.run(CleanerImpl.java:140)
	at java.base@17.0.2/java.lang.Thread.run(Thread.java:833)
	at java.base@17.0.2/jdk.internal.misc.InnocuousThread.run(InnocuousThread.java:162)

Thread[Attach Listener,9,system]

Thread[Finalizer,8,system]
	at java.base@17.0.2/java.lang.Object.wait(Native Method)
	at java.base@17.0.2/java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:155)
	at java.base@17.0.2/java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:176)
	at java.base@17.0.2/java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:172)

Thread[Notification Thread,9,system]

Thread[Reference Handler,10,system]
	at java.base@17.0.2/java.lang.ref.Reference.waitForReferencePendingList(Native Method)
	at java.base@17.0.2/java.lang.ref.Reference.processPendingReferences(Reference.java:253)
	at java.base@17.0.2/java.lang.ref.Reference$ReferenceHandler.run(Reference.java:215)

Thread[Signal Dispatcher,9,system]

Thread[main,5,main]
	at app//com.code_intelligence.jazzer.driver.FuzzTargetRunner.dumpAllStackTraces(FuzzTargetRunner.java:534)

Thread[process reaper,10,system]
	at java.base@17.0.2/jdk.internal.misc.Unsafe.park(Native Method)
	at java.base@17.0.2/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:252)
	at java.base@17.0.2/java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:401)
	at java.base@17.0.2/java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:903)
	at java.base@17.0.2/java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1061)
	at java.base@17.0.2/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1122)
	at java.base@17.0.2/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base@17.0.2/java.lang.Thread.run(Thread.java:833)

Garbage collector stats:
INFO: Instrumented com.sun.management.internal.GarbageCollectorExtImpl (took 5 ms, size +17%)
INFO: Instrumented com.sun.management.GarbageCollectorMXBean (took 0 ms, size +0%)
INFO: Instrumented com.sun.jmx.mbeanserver.GetPropertyAction (took 1 ms, size +14%)
INFO: Instrumented com.sun.jmx.mbeanserver.Util (took 5 ms, size +17%)

PS MarkSweep: 0 collections took 0ms
PS Scavenge: 26 collections took 219ms

SUMMARY: libFuzzer: timeout
subprocess command returned a non-zero exit status: 70
INFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -i -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/crete/packages/python_oss_fuzz/.oss_fuzz/build/out/tika:/out -v /tmp/tmphmmplbto:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TextAndCSVParserFuzzer -runs=100.

</crash_log>