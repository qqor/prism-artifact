diff --git a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
index 9075a74db..d7b7ee261 100644
--- a/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
+++ b/tika-parsers/tika-parsers-standard/tika-parsers-standard-modules/tika-parser-text-module/src/main/java/org/apache/tika/parser/csv/CSVSniffer.java
@@ -143,6 +143,7 @@ class CSVSniffer {
         boolean rowZeroEmpty = false;
         int encapsulated = 0; //number of cells that are encapsulated in dquotes (for now)
         boolean parseException = false;
+        int loopIterations = 0; //track total iterations to prevent infinite loops
 
         public Snifflet(char delimiter) {
             this.delimiter = delimiter;
@@ -156,6 +157,11 @@ class CSVSniffer {
             try (PushbackReader reader = new PushbackReader(new CloseShieldReader(r), PUSH_BACK)) {
                 int c = read(reader);
                 while (c != EOF) {
+                    // Prevent infinite loops in main parsing loop
+                    loopIterations++;
+                    if (loopIterations > markLimit * 2) {
+                        throw new HitMarkLimitException();
+                    }
                     if (c == quoteCharacter) {
                         handleUnquoted(unquoted);
                         //test to make sure there isn't an unencapsulated quote character
@@ -233,6 +239,11 @@ class CSVSniffer {
         void consumeSpaceCharacters(PushbackReader reader) throws IOException {
             int c = read(reader);
             while (c == SPACE) {
+                // Prevent infinite loops
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    throw new HitMarkLimitException();
+                }
                 c = read(reader);
             }
             if (c == EOF) {
@@ -257,6 +268,13 @@ class CSVSniffer {
             //escaping options
             int c = read(reader);
             while (c != -1) {
+                // Prevent infinite loops by checking total loop iterations against a reasonable limit
+                // Use markLimit as the upper bound since we shouldn't loop more times than characters we can read
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    // If we've iterated more than twice the mark limit, something is wrong
+                    throw new HitMarkLimitException();
+                }
                 if (c == quoteCharacter) {
                     int nextC = read(reader);
                     if (nextC == EOF) {
@@ -312,6 +330,11 @@ class CSVSniffer {
         void consumeNewLines(PushbackReader reader) throws IOException {
             int c = read(reader);
             while (c == NEW_LINE || c == CARRIAGE_RETURN) {
+                // Prevent infinite loops
+                loopIterations++;
+                if (loopIterations > markLimit * 2) {
+                    throw new HitMarkLimitException();
+                }
                 c = read(reader);
             }
             if (c == EOF) {
