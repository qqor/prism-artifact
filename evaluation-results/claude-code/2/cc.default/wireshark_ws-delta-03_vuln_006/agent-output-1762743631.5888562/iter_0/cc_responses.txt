
================================================================================
Response 1
================================================================================
I'll analyze the crash log and create a patch to fix the heap-buffer-overflow bug.

From the crash log, I can see:
1. The bug is in `dissect_irc_names` function at line 563 in `/src/wireshark/epan/dissectors/packet-irc.c`
2. A 51-byte buffer was allocated at line 537
3. A write of 132 bytes is attempted at line 563, causing the overflow
4. The test case shows: `NAMES #aaaa...aaa,#hello\n` - a long channel name followed by another channel

Let me first find and read the source file:

================================================================================
Response 2
================================================================================
Now let me check what CHANNELLEN is defined as:

================================================================================
Response 3
================================================================================
Perfect! I found the bug. At line 563, the code does:

```c
tvb_memcpy(tvb, channel_name, start_offset, length);
```

But it should be checking if `length` exceeds `CHANNELLEN` (50 bytes), just like it does at line 555 and other places in the code. The buffer is allocated as 51 bytes (CHANNELLEN+1), but at line 563, it tries to copy `length` bytes without bounds checking.

Looking at the crash:
- Buffer allocated: 51 bytes
- Attempted write: 132 bytes (the long channel name from the test case)
- This causes heap-buffer-overflow

The fix is to add the same bounds check that exists at line 555 to line 563. Let me check if there are similar issues elsewhere:

================================================================================
Response 4
================================================================================
Good! Line 563 is the only place where `tvb_memcpy` is called with an unbounded `length` parameter. Now let me read a bit more context around the dissect_irc_list function to see if there's a similar issue:

================================================================================
Response 5
================================================================================
Good! The `dissect_irc_list` function at line 613 correctly bounds-checks with `(end_offset-start_offset < CHANNELLEN) ? end_offset-start_offset : CHANNELLEN`.

Now I understand the issue completely. At line 563 in `dissect_irc_names`, when a comma is found, the code calculates `length` as the remaining bytes from `start_offset` to the end, but then tries to copy all of `length` without checking if it exceeds CHANNELLEN.

The fix should be to replace line 563 with a bounds-checked version. Let me create the patch:

================================================================================
Response 6
================================================================================
Let me read the exact content with tabs/spaces preserved:

================================================================================
Response 7
================================================================================
Perfect! The patch has been applied. Let me verify the fix by reading the corrected section one more time:

================================================================================
Response 8
================================================================================
Excellent! The fix has been successfully applied. Let me create a summary of what was fixed:

## Summary

I've successfully fixed the **AddressSanitizer: heap-buffer-overflow** bug in the Wireshark IRC dissector.

### Root Cause
The bug was in the `dissect_irc_names` function at line 563 of `/home/qqor/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c`. When parsing IRC NAMES commands with comma-separated channel names, the code:

1. Allocated a buffer of 51 bytes (CHANNELLEN+1, where CHANNELLEN=50)
2. At line 563, attempted to copy `length` bytes without bounds checking
3. When `length` exceeded 50 bytes (e.g., 132 bytes in the test case), it caused a heap-buffer-overflow

### The Fix
Changed line 563 from:
```c
tvb_memcpy(tvb, channel_name, start_offset, length);
```

To:
```c
tvb_memcpy(tvb, channel_name, start_offset, (end_offset-start_offset < CHANNELLEN) ? end_offset-start_offset : CHANNELLEN);
```

This ensures the copy operation never exceeds the allocated buffer size by:
- Calculating the actual channel name length as `end_offset - start_offset`
- Capping it at CHANNELLEN (50 bytes) to prevent overflow
- This matches the bounds-checking pattern used elsewhere in the same file (lines 555, 604, 613, etc.)

The patch prevents the overflow while preserving the intended functionality of parsing IRC channel names.
