diff --git a/poi/src/main/java/org/apache/poi/ss/format/CellFormat.java b/poi/src/main/java/org/apache/poi/ss/format/CellFormat.java
index 0c9a73c87..92c5b309a 100644
--- a/poi/src/main/java/org/apache/poi/ss/format/CellFormat.java
+++ b/poi/src/main/java/org/apache/poi/ss/format/CellFormat.java
@@ -135,6 +135,12 @@ public class CellFormat {
     private static final Map<Locale, Map<String, CellFormat>> formatCache =
             new WeakHashMap<>();
 
+    /**
+     * Maximum length of format string to prevent ReDoS (Regular Expression Denial of Service)
+     * attacks that can cause stack overflow due to catastrophic backtracking in complex regex patterns.
+     */
+    private static final int MAX_FORMAT_LENGTH = 4096;
+
     /**
      * Returns a CellFormat that applies the given format.  Two calls
      * with the same format may or may not return the same object.
@@ -177,6 +183,13 @@ public class CellFormat {
     private CellFormat(Locale locale, String format) {
         this.locale = locale;
         this.format = format;
+
+        // Validate format string length to prevent ReDoS attacks
+        if (format != null && format.length() > MAX_FORMAT_LENGTH) {
+            throw new IllegalArgumentException("Format string too long: " + format.length() +
+                    " characters (maximum allowed: " + MAX_FORMAT_LENGTH + ")");
+        }
+
         CellFormatPart defaultTextFormat = new CellFormatPart(locale, "@");
         Matcher m = ONE_PART.matcher(format);
         List<CellFormatPart> parts = new ArrayList<>();
diff --git a/poi/src/main/java/org/apache/poi/ss/format/CellFormatPart.java b/poi/src/main/java/org/apache/poi/ss/format/CellFormatPart.java
index ea8eaa37b..65e8422b7 100644
--- a/poi/src/main/java/org/apache/poi/ss/format/CellFormatPart.java
+++ b/poi/src/main/java/org/apache/poi/ss/format/CellFormatPart.java
@@ -49,6 +49,12 @@ import static org.apache.poi.ss.format.CellFormatter.quote;
 public class CellFormatPart {
     private static final Logger LOG = PoiLogManager.getLogger(CellFormatPart.class);
 
+    /**
+     * Maximum length of format string to prevent ReDoS (Regular Expression Denial of Service)
+     * attacks that can cause stack overflow due to catastrophic backtracking in complex regex patterns.
+     */
+    private static final int MAX_FORMAT_LENGTH = 4096;
+
     static final Map<String, Color> NAMED_COLORS;
 
     private final Color color;
@@ -182,6 +188,12 @@ public class CellFormatPart {
      * @param desc The string to parse.
      */
     public CellFormatPart(Locale locale, String desc) {
+        // Validate format string length to prevent ReDoS attacks
+        if (desc != null && desc.length() > MAX_FORMAT_LENGTH) {
+            throw new IllegalArgumentException("Format string too long: " + desc.length() +
+                    " characters (maximum allowed: " + MAX_FORMAT_LENGTH + ")");
+        }
+
         Matcher m = FORMAT_PAT.matcher(desc);
         if (!m.matches()) {
             throw new IllegalArgumentException("Unrecognized format: " + quote(
@@ -490,6 +502,12 @@ public class CellFormatPart {
     public static StringBuffer parseFormat(String fdesc, CellFormatType type,
             PartHandler partHandler) {
 
+        // Validate format string length to prevent ReDoS attacks
+        if (fdesc != null && fdesc.length() > MAX_FORMAT_LENGTH) {
+            throw new IllegalArgumentException("Format string too long: " + fdesc.length() +
+                    " characters (maximum allowed: " + MAX_FORMAT_LENGTH + ")");
+        }
+
         // Quoting is very awkward.  In the Java classes, quoting is done
         // between ' chars, with '' meaning a single ' char. The problem is that
         // in Excel, it is legal to have two adjacent escaped strings.  For
