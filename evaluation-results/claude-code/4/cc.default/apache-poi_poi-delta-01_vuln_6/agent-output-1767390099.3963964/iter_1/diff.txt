diff --git a/poi/src/main/java/org/apache/poi/ss/usermodel/DateUtil.java b/poi/src/main/java/org/apache/poi/ss/usermodel/DateUtil.java
index 401b1c47a..b0b2d7607 100644
--- a/poi/src/main/java/org/apache/poi/ss/usermodel/DateUtil.java
+++ b/poi/src/main/java/org/apache/poi/ss/usermodel/DateUtil.java
@@ -70,13 +70,57 @@ public class DateUtil {
     private static final Pattern date_ptrn2 = Pattern.compile("^\\[[a-zA-Z]+]");
     private static final Pattern date_ptrn3a = Pattern.compile("[yYmMdDhHsS]");
     // add "\u5e74 \u6708 \u65e5" for Chinese/Japanese date format:2017 \u5e74 2 \u6708 7 \u65e5
-    private static final Pattern date_ptrn3b = Pattern.compile("^[\\[\\]yYmMdDhHsS\\-T/\u5e74\u6708\u65e5,. :\"\\\\]+0* ?[ampAMP/]*$");
+    // Note: date_ptrn3b regex replaced with iterative method to prevent stack overflow on long inputs
+    private static final String DATE_PTRN3B_CHARS = "[]yYmMdDhHsS-T/\u5e74\u6708\u65e5,. :\"\\";
+    private static final String DATE_PTRN3B_AMPM_CHARS = "ampAMP/";
     //  elapsed time patterns: [h],[m] and [s]
     private static final Pattern date_ptrn4 = Pattern.compile("^\\[([hH]+|[mM]+|[sS]+)]");
 
     // for format which start with "[DBNum1]" or "[DBNum2]" or "[DBNum3]" could be a Chinese date
     private static final Pattern date_ptrn5 = Pattern.compile("^\\[DBNum([123])]");
 
+    /**
+     * Iterative replacement for date_ptrn3b regex to avoid stack overflow on long inputs.
+     * Matches: ^[...]+ 0* ?[ampAMP/]*$
+     * where [...] contains date/time format characters.
+     */
+    private static boolean matchesDatePattern3b(String fs) {
+        if (fs == null || fs.isEmpty()) {
+            return false;
+        }
+
+        int len = fs.length();
+        int pos = 0;
+
+        // Match one or more date format characters: [...]+
+        boolean foundDateChar = false;
+        while (pos < len && DATE_PTRN3B_CHARS.indexOf(fs.charAt(pos)) >= 0) {
+            foundDateChar = true;
+            pos++;
+        }
+        if (!foundDateChar) {
+            return false;
+        }
+
+        // Match zero or more '0' characters: 0*
+        while (pos < len && fs.charAt(pos) == '0') {
+            pos++;
+        }
+
+        // Match optional space: ?
+        if (pos < len && fs.charAt(pos) == ' ') {
+            pos++;
+        }
+
+        // Match zero or more AM/PM characters: [ampAMP/]*
+        while (pos < len && DATE_PTRN3B_AMPM_CHARS.indexOf(fs.charAt(pos)) >= 0) {
+            pos++;
+        }
+
+        // Must have consumed the entire string
+        return pos == len;
+    }
+
     private static final DateTimeFormatter dateTimeFormats = new DateTimeFormatterBuilder()
             .appendPattern("[d[.] [MMMM][MMM][ yyyy]][[ ]h:m[:s][.SSS] a][[ ]H:m[:s][.SSS]]")
             .appendPattern("[[yyyy ]d-[MMMM][MMM][-yyyy]][[ ]h:m[:s][.SSS] a][[ ]H:m[:s][.SSS]]")
@@ -715,7 +759,7 @@ public class DateUtil {
         //  y m d h s - \ / , . : [ ] T
         // optionally followed by AM/PM
 
-        boolean result = date_ptrn3b.matcher(fs).matches();
+        boolean result = matchesDatePattern3b(fs);
         cache(formatString, formatIndex, result);
         return result;
     }
