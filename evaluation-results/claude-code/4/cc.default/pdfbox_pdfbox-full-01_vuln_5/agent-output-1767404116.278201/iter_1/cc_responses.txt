
================================================================================
Response 1
================================================================================
Now I understand the issue. Let me analyze what happened:

## Why the Previous Patch Failed

Looking at the crash log, the OutOfMemoryError occurs at line 507, which is `new byte[length]`. The previous patch added a check for `length < 0 || length > buffer.remaining()`, but the crash still occurred at line 507.

The issue is that the patch checked `buffer.remaining()` but did NOT check if `length` exceeds the maximum array size allowed by the JVM. A malicious or corrupted font could specify a `length` value that is:
1. Positive (passes `length < 0` check)
2. Less than or equal to `buffer.remaining()` (passes `length > buffer.remaining()` check)
3. But still extremely large - triggering an OOM when allocating `new byte[length]`

The actual stack trace shows `Requested array size exceeds VM limit`, meaning the `length` value is larger than what can be allocated, even if theoretically there's enough remaining buffer.

## New Approach

Instead of checking against `buffer.remaining()`, we need to add a reasonable maximum limit for CharString length. CharStrings in Type 1 fonts are typically small (a few hundred bytes to a few KB at most). Setting a sensible maximum limit (e.g., 64KB or 1MB) would prevent OOM while still accepting all valid fonts.

================================================================================
Response 2
================================================================================
## Summary

**Why the previous patch failed:**

The previous patch checked `length > buffer.remaining()`, but this doesn't prevent OOM attacks. A malicious font file could have:
- A very large buffer (several GB of data)
- A `length` value that is huge but still less than `buffer.remaining()`

In this case, the check would pass, but `new byte[length]` would still fail with `OutOfMemoryError: Requested array size exceeds VM limit` because:
1. The JVM has array size limits (typically ~Integer.MAX_VALUE - 8)
2. Even smaller arrays can exceed available heap memory

**The new fix uses a different approach:**

Instead of comparing against `buffer.remaining()`, I added a hard-coded maximum limit (`MAX_CHARSTRING_LENGTH = 65536` bytes / 64KB) for CharString length. This approach:

1. **Uses domain knowledge**: CharStrings in Type 1 fonts encode glyph outlines and are typically small (a few hundred bytes to a few KB). 64KB is extremely generous and accommodates all valid fonts.

2. **Is independent of buffer size**: No matter how large the buffer is, the length is capped at a sane maximum.

3. **Prevents OOM attacks**: A malicious `length` value of billions will be rejected before any memory allocation is attempted.

4. **Throws `DamagedFontException`**: This is the appropriate exception type for corrupted/malicious font data, consistent with the codebase's error handling patterns.
