
================================================================================
Message 0: SystemMessage
================================================================================
SystemMessage(subtype='init', data={'type': 'system', 'subtype': 'init', 'cwd': '/home/qqor/crete/.cache/official-afc-poi', 'session_id': 'fa76b057-f96c-45cb-b312-75b4d1068f90', 'tools': ['Task', 'Bash', 'Glob', 'Grep', 'ExitPlanMode', 'Read', 'Edit', 'Write', 'NotebookEdit', 'WebFetch', 'TodoWrite', 'WebSearch', 'BashOutput', 'KillShell', 'Skill', 'SlashCommand', 'EnterPlanMode'], 'mcp_servers': [], 'model': 'claude-opus-4-5-20251101', 'permissionMode': 'bypassPermissions', 'slash_commands': ['compact', 'context', 'cost', 'init', 'pr-comments', 'release-notes', 'todos', 'review', 'security-review'], 'apiKeySource': 'none', 'claude_code_version': '2.0.53', 'output_style': 'default', 'agents': ['general-purpose', 'statusline-setup', 'Explore', 'Plan'], 'skills': [], 'plugins': [], 'uuid': '29a4177f-3795-4dc9-b4ec-e5e05ed38c9c'})

================================================================================
Message 1: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01USMKHuKWc8ey5YJCrg5ZAD', name='Grep', input={'pattern': 'StringUtil\\.getFromUnicodeLE', 'output_mode': 'files_with_matches'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 2: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01RwGJySrbA4Le8gjzubRiEp', name='Grep', input={'pattern': 'MAPIAttribute\\.create', 'output_mode': 'files_with_matches'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 3: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_017zewjciUG8Kx4mSRenTQhx', name='Glob', input={'pattern': '**/StringUtil.java'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 4: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01A9rMBkH1FZKkg48eP1E6Bm', name='Glob', input={'pattern': '**/MAPIAttribute.java'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 5: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01A9rMBkH1FZKkg48eP1E6Bm', content='/home/qqor/crete/.cache/official-afc-poi/poi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIAttribute.java', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 6: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01RwGJySrbA4Le8gjzubRiEp', content='Found 2 files\npoi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/TNEFMAPIAttribute.java\npoi-scratchpad/src/main/java/org/apache/poi/hmef/dev/HMEFDumper.java', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 7: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01USMKHuKWc8ey5YJCrg5ZAD', content='Found 24 files\npoi/src/test/java/org/apache/poi/util/TestStringUtil.java\npoi/src/main/java/org/apache/poi/poifs/filesystem/Ole10Native.java\npoi/src/main/java/org/apache/poi/hssf/usermodel/HSSFPatriarch.java\npoi/src/main/java/org/apache/poi/hssf/usermodel/HSSFPicture.java\npoi/src/main/java/org/apache/poi/hssf/usermodel/HSSFShape.java\npoi/src/main/java/org/apache/poi/hpsf/UnicodeString.java\npoi-scratchpad/src/test/java/org/apache/poi/hwpf/usermodel/TestOfficeDrawings.java\npoi-scratchpad/src/main/java/org/apache/poi/hwpf/usermodel/Picture.java\npoi-scratchpad/src/main/java/org/apache/poi/hwpf/model/Sttb.java\npoi-scratchpad/src/main/java/org/apache/poi/hwpf/model/StyleDescription.java\npoi-scratchpad/src/main/java/org/apache/poi/hsmf/datatypes/StringChunk.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/usermodel/HSLFShape.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/record/TextCharsAtom.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/usermodel/HSLFPictureShape.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/record/FontEntityAtom.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/record/CString.java\npoi-scratchpad/src/main/java/org/apache/poi/hslf/record/CurrentUserAtom.java\npoi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIAttribute.java\npoi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIStringAttribute.java\npoi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/TNEFStringAttribute.java\npoi-scratchpad/src/main/java/org/apache/poi/hpbf/dev/HPBFDumper.java\npoi-scratchpad/src/main/java/org/apache/poi/hpbf/model/qcbits/QCPLCBit.java\npoi-scratchpad/src/main/java/org/apache/poi/hpbf/model/qcbits/QCTextBit.java\npoi-scratchpad/src/main/java/org/apache/poi/hemf/record/emfplus/HemfPlusDraw.java', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 8: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_017zewjciUG8Kx4mSRenTQhx', content='/home/qqor/crete/.cache/official-afc-poi/poi/src/main/java/org/apache/poi/util/StringUtil.java', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 9: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Let me read the relevant source files to understand the OOM issue:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 10: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01NHVoDVyMzbG1VHezSaMdkm', name='Read', input={'file_path': '/home/qqor/crete/.cache/official-afc-poi/poi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIAttribute.java'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 11: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01P1UHA7Ub51kfboMvojg6Un', name='Read', input={'file_path': '/home/qqor/crete/.cache/official-afc-poi/poi/src/main/java/org/apache/poi/util/StringUtil.java'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 12: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01NHVoDVyMzbG1VHezSaMdkm', content='     1→/* ====================================================================\n     2→   Licensed to the Apache Software Foundation (ASF) under one or more\n     3→   contributor license agreements.  See the NOTICE file distributed with\n     4→   this work for additional information regarding copyright ownership.\n     5→   The ASF licenses this file to You under the Apache License, Version 2.0\n     6→   (the "License"); you may not use this file except in compliance with\n     7→   the License.  You may obtain a copy of the License at\n     8→\n     9→       http://www.apache.org/licenses/LICENSE-2.0\n    10→\n    11→   Unless required by applicable law or agreed to in writing, software\n    12→   distributed under the License is distributed on an "AS IS" BASIS,\n    13→   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    14→   See the License for the specific language governing permissions and\n    15→   limitations under the License.\n    16→==================================================================== */\n    17→\n    18→package org.apache.poi.hmef.attribute;\n    19→\n    20→import java.io.IOException;\n    21→import java.io.InputStream;\n    22→import java.util.ArrayList;\n    23→import java.util.Arrays;\n    24→import java.util.List;\n    25→\n    26→import org.apache.commons.io.input.UnsynchronizedByteArrayInputStream;\n    27→import org.apache.poi.hmef.Attachment;\n    28→import org.apache.poi.hmef.HMEFMessage;\n    29→import org.apache.poi.hsmf.datatypes.MAPIProperty;\n    30→import org.apache.poi.hsmf.datatypes.Types;\n    31→import org.apache.poi.hsmf.datatypes.Types.MAPIType;\n    32→import org.apache.poi.util.HexDump;\n    33→import org.apache.poi.util.IOUtils;\n    34→import org.apache.poi.util.LittleEndian;\n    35→import org.apache.poi.util.StringUtil;\n    36→\n    37→/**\n    38→ * A pure-MAPI attribute which applies to a {@link HMEFMessage}\n    39→ *  or one of its {@link Attachment}s.\n    40→ */\n    41→public class MAPIAttribute {\n    42→\n    43→   //arbitrarily selected; may need to increase\n    44→   private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    45→   private static int MAX_RECORD_LENGTH = 1_000_000;\n    46→   private static int MAX_RECORD_COUNT = 10_000;\n    47→\n    48→   private final MAPIProperty property;\n    49→   private final int type;\n    50→   private final byte[] data;\n    51→\n    52→   /**\n    53→    * @param length the max record length allowed for MAPIAttribute\n    54→    */\n    55→   public static void setMaxRecordLength(int length) {\n    56→      MAX_RECORD_LENGTH = length;\n    57→   }\n    58→\n    59→   /**\n    60→    * @return the max record length allowed for MAPIAttribute\n    61→    */\n    62→   public static int getMaxRecordLength() {\n    63→      return MAX_RECORD_LENGTH;\n    64→   }\n    65→\n    66→   /**\n    67→    * Constructs a single new attribute from\n    68→    *  the contents of the stream\n    69→    */\n    70→   public MAPIAttribute(MAPIProperty property, int type, byte[] data) {\n    71→      this.property = property;\n    72→      this.type = type;\n    73→      this.data = data.clone();\n    74→   }\n    75→\n    76→   public MAPIProperty getProperty() {\n    77→      return property;\n    78→   }\n    79→\n    80→   public int getType() {\n    81→      return type;\n    82→   }\n    83→\n    84→   public byte[] getData() {\n    85→      return data;\n    86→   }\n    87→\n    88→   public String toString() {\n    89→      String hex;\n    90→      if(data.length <= 16) {\n    91→         hex = HexDump.toHex(data);\n    92→      } else {\n    93→         byte[] d = Arrays.copyOf(data, 16);\n    94→         hex = HexDump.toHex(d);\n    95→         hex = hex.substring(0, hex.length()-1) + ", ....]";\n    96→      }\n    97→\n    98→      return property + " " + hex;\n    99→   }\n   100→\n   101→   /**\n   102→    * Parses a MAPI Properties TNEF Attribute, and returns\n   103→    *  the list of MAPI Attributes contained within it\n   104→    */\n   105→   public static List<MAPIAttribute> create(TNEFAttribute parent) throws IOException {\n   106→      if(parent.getProperty() == TNEFProperty.ID_MAPIPROPERTIES) {\n   107→         // Regular MAPI Properties, normally on the message\n   108→      }\n   109→      else if(parent.getProperty() == TNEFProperty.ID_ATTACHMENT) {\n   110→         // MAPI Properties for an attachment\n   111→      }\n   112→      else {\n   113→         // Something else, oh dear...\n   114→         throw new IllegalArgumentException(\n   115→               "Can only create from a MAPIProperty attribute, " +\n   116→               "instead received a " + parent.getProperty() + " one"\n   117→         );\n   118→      }\n   119→      try(UnsynchronizedByteArrayInputStream inp = UnsynchronizedByteArrayInputStream.builder().setByteArray(parent.getData()).get()) {\n   120→         // First up, get the number of attributes\n   121→         int count = LittleEndian.readInt(inp);\n   122→         List<MAPIAttribute> attrs = new ArrayList<>();\n   123→\n   124→         // Now, read each one in in turn\n   125→         for(int i=0; i<count; i++) {\n   126→            int typeAndMV = LittleEndian.readUShort(inp);\n   127→            int id = LittleEndian.readUShort(inp);\n   128→\n   129→            // Is it either Multi-Valued or Variable-Length?\n   130→            boolean isMV = false;\n   131→            boolean isVL = false;\n   132→            int typeId = typeAndMV;\n   133→            if( (typeAndMV & Types.MULTIVALUED_FLAG) != 0 ) {\n   134→               isMV = true;\n   135→               typeId -= Types.MULTIVALUED_FLAG;\n   136→            }\n   137→            if(typeId == Types.ASCII_STRING.getId() || typeId == Types.UNICODE_STRING.getId() ||\n   138→                    typeId == Types.BINARY.getId() || typeId == Types.DIRECTORY.getId()) {\n   139→               isVL = true;\n   140→            }\n   141→\n   142→            // Turn the type ID into a strongly typed thing\n   143→            MAPIType type = Types.getById(typeId);\n   144→            if (type == null) {\n   145→               type = Types.createCustom(typeId);\n   146→            }\n   147→\n   148→            // If it\'s a named property, rather than a standard\n   149→            //  MAPI property, grab the details of it\n   150→            MAPIProperty prop = MAPIProperty.get(id);\n   151→            if(id >= 0x8000 && id <= 0xFFFF) {\n   152→               byte[] guid = new byte[16];\n   153→               if (IOUtils.readFully(inp, guid) < 0) {\n   154→                  throw new IOException("Not enough data to read guid");\n   155→               }\n   156→               int mptype = LittleEndian.readInt(inp);\n   157→\n   158→               // Get the name of it\n   159→               String name;\n   160→               if(mptype == 0) {\n   161→                  // It\'s based on a normal one\n   162→                  int mpid = LittleEndian.readInt(inp);\n   163→                  MAPIProperty base = MAPIProperty.get(mpid);\n   164→                  name = base.name;\n   165→               } else {\n   166→                  // Custom name was stored\n   167→                  int mplen = LittleEndian.readInt(inp);\n   168→                  if (mplen < 0) {\n   169→                     throw new IOException("Did not expect negative value: " + mplen);\n   170→                  }\n   171→                  byte[] mpdata = new byte[mplen];\n   172→                  if (IOUtils.readFully(inp, mpdata) < 0) {\n   173→                     throw new IOException("Not enough data to read " + mplen + " bytes for attribute name");\n   174→                  }\n   175→                  name = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);\n   176→                  skipToBoundary(mplen, inp);\n   177→               }\n   178→\n   179→               // Now create\n   180→               prop = MAPIProperty.createCustom(id, type, name);\n   181→            }\n   182→            if(prop == MAPIProperty.UNKNOWN) {\n   183→               prop = MAPIProperty.createCustom(id, type, "(unknown " + Integer.toHexString(id) + ")");\n   184→            }\n   185→\n   186→            // Now read in the value(s)\n   187→            int values = 1;\n   188→            if(isMV || isVL) {\n   189→               values = LittleEndian.readInt(inp);\n   190→            }\n   191→\n   192→            if (type == Types.NULL && values > 1) {\n   193→               throw new IOException("Placeholder/NULL arrays aren\'t supported.");\n   194→            }\n   195→\n   196→            for(int j=0; j<values; j++) {\n   197→               int len = getLength(type, inp);\n   198→               byte[] data = IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH);\n   199→               inp.read(data);\n   200→               skipToBoundary(len, inp);\n   201→\n   202→               // Create\n   203→               MAPIAttribute attr;\n   204→               if(type == Types.UNICODE_STRING || type == Types.ASCII_STRING) {\n   205→                  attr = new MAPIStringAttribute(prop, typeId, data);\n   206→               } else if(type == Types.APP_TIME || type == Types.TIME) {\n   207→                  attr = new MAPIDateAttribute(prop, typeId, data);\n   208→               } else if(id == MAPIProperty.RTF_COMPRESSED.id) {\n   209→                  attr = new MAPIRtfAttribute(prop, typeId, data);\n   210→               } else {\n   211→                  attr = new MAPIAttribute(prop, typeId, data);\n   212→               }\n   213→               attrs.add(attr);\n   214→            }\n   215→         }\n   216→\n   217→         // All done\n   218→         return attrs;\n   219→      }\n   220→   }\n   221→\n   222→   private static int getLength(MAPIType type, InputStream inp) throws IOException {\n   223→      if (type.isFixedLength()) {\n   224→         return type.getLength();\n   225→      }\n   226→      if (type == Types.ASCII_STRING ||\n   227→          type == Types.UNICODE_STRING ||\n   228→          type == Types.DIRECTORY ||\n   229→          type == Types.BINARY) {\n   230→            // Need to read the length, as it varies\n   231→            return LittleEndian.readInt(inp);\n   232→      } else {\n   233→            throw new IllegalArgumentException("Unknown type " + type);\n   234→      }\n   235→   }\n   236→   private static void skipToBoundary(int length, InputStream inp) throws IOException {\n   237→      // Data is always padded out to a 4 byte boundary\n   238→      if(length % 4 != 0) {\n   239→         int toSkip = 4 - (length % 4);\n   240→         inp.skip(toSkip);\n   241→      }\n   242→   }\n   243→}\n   244→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 13: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01P1UHA7Ub51kfboMvojg6Un', content='     1→/* ====================================================================\n     2→   Licensed to the Apache Software Foundation (ASF) under one or more\n     3→   contributor license agreements.  See the NOTICE file distributed with\n     4→   this work for additional information regarding copyright ownership.\n     5→   The ASF licenses this file to You under the Apache License, Version 2.0\n     6→   (the "License"); you may not use this file except in compliance with\n     7→   the License.  You may obtain a copy of the License at\n     8→\n     9→       http://www.apache.org/licenses/LICENSE-2.0\n    10→\n    11→   Unless required by applicable law or agreed to in writing, software\n    12→   distributed under the License is distributed on an "AS IS" BASIS,\n    13→   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    14→   See the License for the specific language governing permissions and\n    15→   limitations under the License.\n    16→==================================================================== */\n    17→\n    18→package org.apache.poi.util;\n    19→\n    20→import static java.nio.charset.StandardCharsets.ISO_8859_1;\n    21→import static java.nio.charset.StandardCharsets.UTF_8;\n    22→\n    23→import java.nio.charset.Charset;\n    24→import java.nio.charset.StandardCharsets;\n    25→import java.util.Arrays;\n    26→import java.util.Locale;\n    27→\n    28→/**\n    29→ * Collection of string handling utilities\n    30→ */\n    31→@Internal\n    32→public final class StringUtil {\n    33→    //arbitrarily selected; may need to increase\n    34→    private static final int DEFAULT_MAX_RECORD_LENGTH = 10000000;\n    35→    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n    36→\n    37→    public static final Charset UTF16LE = StandardCharsets.UTF_16LE;\n    38→    public static final Charset UTF8 = StandardCharsets.UTF_8;\n    39→    public static final Charset WIN_1252 = Charset.forName("cp1252");\n    40→\n    41→    /**\n    42→     * @param length the max record length allowed for StringUtil\n    43→     */\n    44→    public static void setMaxRecordLength(int length) {\n    45→        MAX_RECORD_LENGTH = length;\n    46→    }\n    47→\n    48→    /**\n    49→     * @return the max record length allowed for StringUtil\n    50→     */\n    51→    public static int getMaxRecordLength() {\n    52→        return MAX_RECORD_LENGTH;\n    53→    }\n    54→\n    55→    private StringUtil() {\n    56→        // no instances of this class\n    57→    }\n    58→\n    59→    /**\n    60→     * Given a byte array of 16-bit unicode characters in Little Endian\n    61→     * format (most important byte last), return a Java String representation\n    62→     * of it.\n    63→     * <p>\n    64→     * { 0x16, 0x00 } -0x16\n    65→     *\n    66→     * @param string the byte array to be converted\n    67→     * @param offset the initial offset into the\n    68→     *               byte array. it is assumed that string[ offset ] and string[ offset +\n    69→     *               1 ] contain the first 16-bit unicode character\n    70→     * @param len    the length of the final string\n    71→     * @return the converted string, never {@code null}.\n    72→     * @throws ArrayIndexOutOfBoundsException if offset is out of bounds for\n    73→     *                                        the byte array (i.e., is negative or is greater than or equal to\n    74→     *                                        string.length)\n    75→     * @throws IllegalArgumentException       if len is too large (i.e.,\n    76→     *                                        there is not enough data in string to create a String of that\n    77→     *                                        length)\n    78→     */\n    79→    public static String getFromUnicodeLE(\n    80→            final byte[] string,\n    81→            final int offset,\n    82→            final int len)\n    83→            throws ArrayIndexOutOfBoundsException, IllegalArgumentException {\n    84→        if (len == 0) {\n    85→            return "";\n    86→        }\n    87→        if ((offset < 0) || (offset >= string.length)) {\n    88→            throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");\n    89→        }\n    90→        if ((len < 0) || (((string.length - offset) / 2) < len)) {\n    91→            throw new IllegalArgumentException("Illegal length " + len);\n    92→        }\n    93→\n    94→        return new String(string, offset, len * 2, UTF16LE);\n    95→    }\n    96→\n    97→    /**\n    98→     * Given a byte array of 16-bit unicode characters in little endian\n    99→     * format (most important byte last), return a Java String representation\n   100→     * of it.\n   101→     * <p>\n   102→     * { 0x16, 0x00 } -0x16\n   103→     *\n   104→     * @param string the byte array to be converted\n   105→     * @return the converted string, never {@code null}\n   106→     */\n   107→    public static String getFromUnicodeLE(byte[] string) {\n   108→        if (string.length == 0) {\n   109→            return "";\n   110→        }\n   111→        return getFromUnicodeLE(string, 0, string.length / 2);\n   112→    }\n   113→\n   114→    /**\n   115→     * Convert String to 16-bit unicode characters in little endian format\n   116→     *\n   117→     * @param string the string\n   118→     * @return the byte array of 16-bit unicode characters\n   119→     */\n   120→    public static byte[] getToUnicodeLE(String string) {\n   121→        return string.getBytes(UTF16LE);\n   122→    }\n   123→\n   124→    /**\n   125→     * Read 8 bit data (in ISO-8859-1 codepage) into a (unicode) Java\n   126→     * String and return.\n   127→     * (In Excel terms, read compressed 8 bit unicode as a string)\n   128→     *\n   129→     * @param string byte array to read\n   130→     * @param offset offset to read byte array\n   131→     * @param len    length to read byte array\n   132→     * @return String generated String instance by reading byte array (ISO-8859-1)\n   133→     */\n   134→    public static String getFromCompressedUnicode(\n   135→            final byte[] string,\n   136→            final int offset,\n   137→            final int len) {\n   138→        int len_to_use = Math.min(len, string.length - offset);\n   139→        return new String(string, offset, len_to_use, ISO_8859_1);\n   140→    }\n   141→\n   142→    /**\n   143→     * Read 8 bit data (in UTF-8 codepage) into a (unicode) Java\n   144→     * String and return.\n   145→     * (In Excel terms, read compressed 8 bit unicode as a string)\n   146→     *\n   147→     * @param string byte array to read\n   148→     * @param offset offset to read byte array\n   149→     * @param len    length to read byte array\n   150→     * @return String generated String instance by reading byte array (UTF-8)\n   151→     */\n   152→    public static String getFromCompressedUTF8(\n   153→            final byte[] string,\n   154→            final int offset,\n   155→            final int len) {\n   156→        int len_to_use = Math.min(len, string.length - offset);\n   157→        return new String(string, offset, len_to_use, UTF_8);\n   158→    }\n   159→\n   160→    /**\n   161→     * @param in stream,\n   162→     * @param nChars number pf chars\n   163→     * @return ISO_8859_1 encoded result\n   164→     */\n   165→    public static String readCompressedUnicode(LittleEndianInput in, int nChars) {\n   166→        byte[] buf = IOUtils.safelyAllocate(nChars, MAX_RECORD_LENGTH);\n   167→        in.readFully(buf);\n   168→        return new String(buf, ISO_8859_1);\n   169→    }\n   170→\n   171→    /**\n   172→     * InputStream {@code in} is expected to contain:\n   173→     * <ol>\n   174→     * <li>ushort nChars</li>\n   175→     * <li>byte is16BitFlag</li>\n   176→     * <li>byte[]/char[] characterData</li>\n   177→     * </ol>\n   178→     * For this encoding, the is16BitFlag is always present even if nChars==0.\n   179→     * <p>\n   180→     * This structure is also known as a XLUnicodeString.\n   181→     */\n   182→    public static String readUnicodeString(LittleEndianInput in) {\n   183→\n   184→        int nChars = in.readUShort();\n   185→        byte flag = in.readByte();\n   186→        if ((flag & 0x01) == 0) {\n   187→            return readCompressedUnicode(in, nChars);\n   188→        }\n   189→        return readUnicodeLE(in, nChars);\n   190→    }\n   191→\n   192→    /**\n   193→     * InputStream {@code in} is expected to contain:\n   194→     * <ol>\n   195→     * <li>byte is16BitFlag</li>\n   196→     * <li>byte[]/char[] characterData</li>\n   197→     * </ol>\n   198→     * For this encoding, the is16BitFlag is always present even if nChars==0.\n   199→     * <br>\n   200→     * This method should be used when the nChars field is <em>not</em> stored\n   201→     * as a ushort immediately before the is16BitFlag. Otherwise, {@link\n   202→     * #readUnicodeString(LittleEndianInput)} can be used.\n   203→     */\n   204→    public static String readUnicodeString(LittleEndianInput in, int nChars) {\n   205→        byte is16Bit = in.readByte();\n   206→        if ((is16Bit & 0x01) == 0) {\n   207→            return readCompressedUnicode(in, nChars);\n   208→        }\n   209→        return readUnicodeLE(in, nChars);\n   210→    }\n   211→\n   212→    /**\n   213→     * OutputStream {@code out} will get:\n   214→     * <ol>\n   215→     * <li>ushort nChars</li>\n   216→     * <li>byte is16BitFlag</li>\n   217→     * <li>byte[]/char[] characterData</li>\n   218→     * </ol>\n   219→     * For this encoding, the is16BitFlag is always present even if nChars==0.\n   220→     */\n   221→    public static void writeUnicodeString(LittleEndianOutput out, String value) {\n   222→        int nChars = value.length();\n   223→        out.writeShort(nChars);\n   224→        boolean is16Bit = hasMultibyte(value);\n   225→        out.writeByte(is16Bit ? 0x01 : 0x00);\n   226→        if (is16Bit) {\n   227→            putUnicodeLE(value, out);\n   228→        } else {\n   229→            putCompressedUnicode(value, out);\n   230→        }\n   231→    }\n   232→\n   233→    /**\n   234→     * OutputStream {@code out} will get:\n   235→     * <ol>\n   236→     * <li>byte is16BitFlag</li>\n   237→     * <li>byte[]/char[] characterData</li>\n   238→     * </ol>\n   239→     * For this encoding, the is16BitFlag is always present even if nChars==0.\n   240→     * <br>\n   241→     * This method should be used when the nChars field is <em>not</em> stored\n   242→     * as a ushort immediately before the is16BitFlag. Otherwise, {@link\n   243→     * #writeUnicodeString(LittleEndianOutput, String)} can be used.\n   244→     */\n   245→    public static void writeUnicodeStringFlagAndData(LittleEndianOutput out, String value) {\n   246→        boolean is16Bit = hasMultibyte(value);\n   247→        out.writeByte(is16Bit ? 0x01 : 0x00);\n   248→        if (is16Bit) {\n   249→            putUnicodeLE(value, out);\n   250→        } else {\n   251→            putCompressedUnicode(value, out);\n   252→        }\n   253→    }\n   254→\n   255→    /**\n   256→     * @return the number of bytes that would be written by {@link #writeUnicodeString(LittleEndianOutput, String)}\n   257→     */\n   258→    public static int getEncodedSize(String value) {\n   259→        int result = 2 + 1;\n   260→        result += value.length() * (StringUtil.hasMultibyte(value) ? 2 : 1);\n   261→        return result;\n   262→    }\n   263→\n   264→    /**\n   265→     * Takes a unicode (java) string, and returns it as 8 bit data (in ISO-8859-1\n   266→     * codepage).\n   267→     * (In Excel terms, write compressed 8 bit unicode)\n   268→     *\n   269→     * @param input  the String containing the data to be written\n   270→     * @param output the byte array to which the data is to be written\n   271→     * @param offset an offset into the byte arrat at which the data is start\n   272→     *               when written\n   273→     */\n   274→    public static void putCompressedUnicode(String input, byte[] output, int offset) {\n   275→        byte[] bytes = input.getBytes(ISO_8859_1);\n   276→        System.arraycopy(bytes, 0, output, offset, bytes.length);\n   277→    }\n   278→\n   279→    public static void putCompressedUnicode(String input, LittleEndianOutput out) {\n   280→        byte[] bytes = input.getBytes(ISO_8859_1);\n   281→        out.write(bytes);\n   282→    }\n   283→\n   284→    /**\n   285→     * Takes a unicode string, and returns it as little endian (most\n   286→     * important byte last) bytes in the supplied byte array.\n   287→     * (In Excel terms, write uncompressed unicode)\n   288→     *\n   289→     * @param input  the String containing the unicode data to be written\n   290→     * @param output the byte array to hold the uncompressed unicode, should be twice the length of the String\n   291→     * @param offset the offset to start writing into the byte array\n   292→     */\n   293→    public static void putUnicodeLE(String input, byte[] output, int offset) {\n   294→        byte[] bytes = input.getBytes(UTF16LE);\n   295→        System.arraycopy(bytes, 0, output, offset, bytes.length);\n   296→    }\n   297→\n   298→    public static void putUnicodeLE(String input, LittleEndianOutput out) {\n   299→        byte[] bytes = input.getBytes(UTF16LE);\n   300→        out.write(bytes);\n   301→    }\n   302→\n   303→    public static String readUnicodeLE(LittleEndianInput in, int nChars) {\n   304→        byte[] bytes = IOUtils.safelyAllocate(nChars * 2L, MAX_RECORD_LENGTH);\n   305→        in.readFully(bytes);\n   306→        return new String(bytes, UTF16LE);\n   307→    }\n   308→\n   309→    /**\n   310→     * @return the encoding we want to use, currently hardcoded to ISO-8859-1\n   311→     */\n   312→    public static String getPreferredEncoding() {\n   313→        return ISO_8859_1.name();\n   314→    }\n   315→\n   316→    /**\n   317→     * check the parameter has multibyte character\n   318→     *\n   319→     * @param value string to check\n   320→     * @return boolean result true:string has at least one multibyte character\n   321→     */\n   322→    public static boolean hasMultibyte(String value) {\n   323→        if (value == null) {\n   324→            return false;\n   325→        }\n   326→        for (char c : value.toCharArray()) {\n   327→            if (c > 0xFF) {\n   328→                return true;\n   329→            }\n   330→        }\n   331→        return false;\n   332→    }\n   333→\n   334→    /**\n   335→     * Tests if the string starts with the specified prefix, ignoring case consideration.\n   336→     */\n   337→    public static boolean startsWithIgnoreCase(String haystack, String prefix) {\n   338→        return haystack.regionMatches(true, 0, prefix, 0, prefix.length());\n   339→    }\n   340→\n   341→    /**\n   342→     * Tests if the string ends with the specified suffix, ignoring case consideration.\n   343→     */\n   344→    public static boolean endsWithIgnoreCase(String haystack, String suffix) {\n   345→        int length = suffix.length();\n   346→        int start = haystack.length() - length;\n   347→        return haystack.regionMatches(true, start, suffix, 0, length);\n   348→    }\n   349→\n   350→    @Internal\n   351→    public static String toLowerCase(char c) {\n   352→        return Character.toString(c).toLowerCase(Locale.ROOT);\n   353→    }\n   354→\n   355→    @Internal\n   356→    public static String toUpperCase(char c) {\n   357→        return Character.toString(c).toUpperCase(Locale.ROOT);\n   358→    }\n   359→\n   360→    @Internal\n   361→    public static boolean isUpperCase(char c) {\n   362→        String s = Character.toString(c);\n   363→        return s.toUpperCase(Locale.ROOT).equals(s);\n   364→    }\n   365→\n   366→    /**\n   367→     * Some strings may contain encoded characters of the unicode private use area.\n   368→     * Currently the characters of the symbol fonts are mapped to the corresponding\n   369→     * characters in the normal unicode range.\n   370→     *\n   371→     * @param string the original string\n   372→     * @return the string with mapped characters\n   373→     * @see <a href="http://www.alanwood.net/unicode/private_use_area.html#symbol">Private Use Area (symbol)</a>\n   374→     * @see <a href="http://www.alanwood.net/demos/symbol.html">Symbol font - Unicode alternatives for Greek and special characters in HTML</a>\n   375→     */\n   376→    public static String mapMsCodepointString(String string) {\n   377→        if (string == null || string.isEmpty()) {\n   378→            return string;\n   379→        }\n   380→\n   381→        int[] cps = string.codePoints().map(StringUtil::mapMsCodepoint).toArray();\n   382→        return new String(cps, 0, cps.length);\n   383→    }\n   384→\n   385→    private static int mapMsCodepoint(int cp) {\n   386→        if (0xf020 <= cp && cp <= 0xf07f) {\n   387→            return symbolMap_f020[cp - 0xf020];\n   388→        } else if (0xf0a0 <= cp && cp <= 0xf0ff) {\n   389→            return symbolMap_f0a0[cp - 0xf0a0];\n   390→        }\n   391→        return cp;\n   392→    }\n   393→\n   394→    private static final int[] symbolMap_f020 = {\n   395→            \' \', // 0xf020 space\n   396→            \'!\', // 0xf021 exclam\n   397→            8704, // 0xf022 universal\n   398→            \'#\', // 0xf023 numbersign\n   399→            8707, // 0xf024 existential\n   400→            \'%\', // 0xf025 percent\n   401→            \'&\', // 0xf026 ampersand\n   402→            8717, // 0xf027 suchthat\n   403→            \'(\', // 0xf028 parenleft\n   404→            \')\', // 0xf029 parentright\n   405→            8727, // 0xf02a asteriskmath\n   406→            \'+\', // 0xf02b plus\n   407→            \',\', // 0xf02c comma\n   408→            8722, // 0xf02d minus sign (long -)\n   409→            \'.\', // 0xf02e period\n   410→            \'/\', // 0xf02f slash\n   411→            \'0\', // 0xf030 0\n   412→            \'1\', // 0xf031 1\n   413→            \'2\', // 0xf032 2\n   414→            \'3\', // 0xf033 3\n   415→            \'4\', // 0xf034 4\n   416→            \'5\', // 0xf035 5\n   417→            \'6\', // 0xf036 6\n   418→            \'7\', // 0xf037 7\n   419→            \'8\', // 0xf038 8\n   420→            \'9\', // 0xf039 9\n   421→            \':\', // 0xf03a colon\n   422→            \';\', // 0xf03b semicolon\n   423→            \'<\', // 0xf03c less\n   424→            \'=\', // 0xf03d equal\n   425→            \'>\', // 0xf03e greater\n   426→            \'?\', // 0xf03f question\n   427→            8773, // 0xf040 congruent\n   428→            913, // 0xf041 alpha (upper)\n   429→            914, // 0xf042 beta (upper)\n   430→            935, // 0xf043 chi (upper)\n   431→            916, // 0xf044 delta (upper)\n   432→            917, // 0xf045 epsilon (upper)\n   433→            934, // 0xf046 phi (upper)\n   434→            915, // 0xf047 gamma (upper)\n   435→            919, // 0xf048 eta (upper)\n   436→            921, // 0xf049 iota (upper)\n   437→            977, // 0xf04a theta1 (lower)\n   438→            922, // 0xf04b kappa (upper)\n   439→            923, // 0xf04c lambda (upper)\n   440→            924, // 0xf04d mu (upper)\n   441→            925, // 0xf04e nu (upper)\n   442→            927, // 0xf04f omicron (upper)\n   443→            928, // 0xf050 pi (upper)\n   444→            920, // 0xf051 theta (upper)\n   445→            929, // 0xf052 rho (upper)\n   446→            931, // 0xf053 sigma (upper)\n   447→            932, // 0xf054 tau (upper)\n   448→            933, // 0xf055 upsilon (upper)\n   449→            962, // 0xf056 simga1 (lower)\n   450→            937, // 0xf057 omega (upper)\n   451→            926, // 0xf058 xi (upper)\n   452→            936, // 0xf059 psi (upper)\n   453→            918, // 0xf05a zeta (upper)\n   454→            \'[\', // 0xf05b bracketleft\n   455→            8765, // 0xf05c therefore\n   456→            \']\', // 0xf05d bracketright\n   457→            8869, // 0xf05e perpendicular\n   458→            \'_\', // 0xf05f underscore\n   459→            \' \', // 0xf060 radicalex (doesn\'t exist in unicode)\n   460→            945, // 0xf061 alpha (lower)\n   461→            946, // 0xf062 beta (lower)\n   462→            967, // 0xf063 chi (lower)\n   463→            948, // 0xf064 delta (lower)\n   464→            949, // 0xf065 epsilon (lower)\n   465→            966, // 0xf066 phi (lower)\n   466→            947, // 0xf067 gamma (lower)\n   467→            951, // 0xf068 eta (lower)\n   468→            953, // 0xf069 iota (lower)\n   469→            981, // 0xf06a phi1 (lower)\n   470→            954, // 0xf06b kappa (lower)\n   471→            955, // 0xf06c lambda (lower)\n   472→            956, // 0xf06d mu (lower)\n   473→            957, // 0xf06e nu (lower)\n   474→            959, // 0xf06f omnicron (lower)\n   475→            960, // 0xf070 pi (lower)\n   476→            952, // 0xf071 theta (lower)\n   477→            961, // 0xf072 rho (lower)\n   478→            963, // 0xf073 sigma (lower)\n   479→            964, // 0xf074 tau (lower)\n   480→            965, // 0xf075 upsilon (lower)\n   481→            982, // 0xf076 piv (lower)\n   482→            969, // 0xf077 omega (lower)\n   483→            958, // 0xf078 xi (lower)\n   484→            968, // 0xf079 psi (lower)\n   485→            950, // 0xf07a zeta (lower)\n   486→            \'{\', // 0xf07b braceleft\n   487→            \'|\', // 0xf07c bar\n   488→            \'}\', // 0xf07d braceright\n   489→            8764, // 0xf07e similar \'~\'\n   490→            \' \', // 0xf07f not defined\n   491→    };\n   492→\n   493→    private static final int[] symbolMap_f0a0 = {\n   494→            8364, // 0xf0a0 not defined / euro symbol\n   495→            978, // 0xf0a1 upsilon1 (upper)\n   496→            8242, // 0xf0a2 minute\n   497→            8804, // 0xf0a3 lessequal\n   498→            8260, // 0xf0a4 fraction\n   499→            8734, // 0xf0a5 infinity\n   500→            402, // 0xf0a6 florin\n   501→            9827, // 0xf0a7 club\n   502→            9830, // 0xf0a8 diamond\n   503→            9829, // 0xf0a9 heart\n   504→            9824, // 0xf0aa spade\n   505→            8596, // 0xf0ab arrowboth\n   506→            8591, // 0xf0ac arrowleft\n   507→            8593, // 0xf0ad arrowup\n   508→            8594, // 0xf0ae arrowright\n   509→            8595, // 0xf0af arrowdown\n   510→            176, // 0xf0b0 degree\n   511→            177, // 0xf0b1 plusminus\n   512→            8243, // 0xf0b2 second\n   513→            8805, // 0xf0b3 greaterequal\n   514→            215, // 0xf0b4 multiply\n   515→            181, // 0xf0b5 proportional\n   516→            8706, // 0xf0b6 partialdiff\n   517→            8729, // 0xf0b7 bullet\n   518→            247, // 0xf0b8 divide\n   519→            8800, // 0xf0b9 notequal\n   520→            8801, // 0xf0ba equivalence\n   521→            8776, // 0xf0bb approxequal\n   522→            8230, // 0xf0bc ellipsis\n   523→            9168, // 0xf0bd arrowvertex\n   524→            9135, // 0xf0be arrowhorizex\n   525→            8629, // 0xf0bf carriagereturn\n   526→            8501, // 0xf0c0 aleph\n   527→            8475, // 0xf0c1 Ifraktur\n   528→            8476, // 0xf0c2 Rfraktur\n   529→            8472, // 0xf0c3 weierstrass\n   530→            8855, // 0xf0c4 circlemultiply\n   531→            8853, // 0xf0c5 circleplus\n   532→            8709, // 0xf0c6 emptyset\n   533→            8745, // 0xf0c7 intersection\n   534→            8746, // 0xf0c8 union\n   535→            8835, // 0xf0c9 propersuperset\n   536→            8839, // 0xf0ca reflexsuperset\n   537→            8836, // 0xf0cb notsubset\n   538→            8834, // 0xf0cc propersubset\n   539→            8838, // 0xf0cd reflexsubset\n   540→            8712, // 0xf0ce element\n   541→            8713, // 0xf0cf notelement\n   542→            8736, // 0xf0d0 angle\n   543→            8711, // 0xf0d1 gradient\n   544→            174, // 0xf0d2 registerserif\n   545→            169, // 0xf0d3 copyrightserif\n   546→            8482, // 0xf0d4 trademarkserif\n   547→            8719, // 0xf0d5 product\n   548→            8730, // 0xf0d6 radical\n   549→            8901, // 0xf0d7 dotmath\n   550→            172, // 0xf0d8 logicalnot\n   551→            8743, // 0xf0d9 logicaland\n   552→            8744, // 0xf0da logicalor\n   553→            8660, // 0xf0db arrowdblboth\n   554→            8656, // 0xf0dc arrowdblleft\n   555→            8657, // 0xf0dd arrowdblup\n   556→            8658, // 0xf0de arrowdblright\n   557→            8659, // 0xf0df arrowdbldown\n   558→            9674, // 0xf0e0 lozenge\n   559→            9001, // 0xf0e1 angleleft\n   560→            174, // 0xf0e2 registersans\n   561→            169, // 0xf0e3 copyrightsans\n   562→            8482, // 0xf0e4 trademarksans\n   563→            8721, // 0xf0e5 summation\n   564→            9115, // 0xf0e6 parenlefttp\n   565→            9116, // 0xf0e7 parenleftex\n   566→            9117, // 0xf0e8 parenleftbt\n   567→            9121, // 0xf0e9 bracketlefttp\n   568→            9122, // 0xf0ea bracketleftex\n   569→            9123, // 0xf0eb bracketleftbt\n   570→            9127, // 0xf0ec bracelefttp\n   571→            9128, // 0xf0ed braceleftmid\n   572→            9129, // 0xf0ee braceleftbt\n   573→            9130, // 0xf0ef braceex\n   574→            \' \', // 0xf0f0 not defined\n   575→            9002, // 0xf0f1 angleright\n   576→            8747, // 0xf0f2 integral\n   577→            8992, // 0xf0f3 integraltp\n   578→            9134, // 0xf0f4 integralex\n   579→            8993, // 0xf0f5 integralbt\n   580→            9118, // 0xf0f6 parenrighttp\n   581→            9119, // 0xf0f7 parenrightex\n   582→            9120, // 0xf0f8 parenrightbt\n   583→            9124, // 0xf0f9 bracketrighttp\n   584→            9125, // 0xf0fa bracketrightex\n   585→            9126, // 0xf0fb bracketrightbt\n   586→            9131, // 0xf0fc bracerighttp\n   587→            9132, // 0xf0fd bracerightmid\n   588→            9133, // 0xf0fe bracerightbt\n   589→            \' \', // 0xf0ff not defined\n   590→    };\n   591→\n   592→\n   593→    // Could be replaced with org.apache.commons.lang3.StringUtils#join\n   594→    @Internal\n   595→    public static String join(Object[] array, String separator) {\n   596→        if (array == null || array.length == 0) {\n   597→            return "";\n   598→        }\n   599→        StringBuilder sb = new StringBuilder();\n   600→        sb.append(array[0]);\n   601→        for (int i = 1; i < array.length; i++) {\n   602→            sb.append(separator).append(array[i]);\n   603→        }\n   604→        return sb.toString();\n   605→    }\n   606→\n   607→    @Internal\n   608→    public static String join(Object[] array) {\n   609→        if (array == null) {\n   610→            return "";\n   611→        }\n   612→        StringBuilder sb = new StringBuilder();\n   613→        for (Object o : array) {\n   614→            sb.append(o);\n   615→        }\n   616→        return sb.toString();\n   617→    }\n   618→\n   619→    @Internal\n   620→    public static String join(String separator, Object... array) {\n   621→        return join(array, separator);\n   622→    }\n   623→\n   624→    /**\n   625→     * Count number of occurrences of needle in haystack\n   626→     * Has same signature as org.apache.commons.lang3.StringUtils#countMatches\n   627→     *\n   628→     * @param haystack the CharSequence to check, may be null\n   629→     * @param needle   the character to count the quantity of\n   630→     * @return the number of occurrences, 0 if the CharSequence is null\n   631→     */\n   632→    public static int countMatches(CharSequence haystack, char needle) {\n   633→        if (haystack == null) {\n   634→            return 0;\n   635→        }\n   636→        int count = 0;\n   637→        final int length = haystack.length();\n   638→        for (int i = 0; i < length; i++) {\n   639→            if (haystack.charAt(i) == needle) {\n   640→                count++;\n   641→            }\n   642→        }\n   643→        return count;\n   644→    }\n   645→\n   646→\n   647→    /**\n   648→     * Given a byte array of 16-bit unicode characters in Little Endian\n   649→     * format (most important byte last), return a Java String representation\n   650→     * of it.\n   651→     *\n   652→     * Scans the byte array for two continous 0 bytes and returns the string before.\n   653→     * <p>\n   654→     *\n   655→     * #61881: there seem to be programs out there, which write the 0-termination also\n   656→     * at the beginning of the string. Check if the next two bytes contain a valid ascii char\n   657→     * and correct the _recdata with a \'?\' char\n   658→     *\n   659→     *\n   660→     * @param string the byte array to be converted\n   661→     * @param offset the initial offset into the\n   662→     *               byte array. it is assumed that string[ offset ] and string[ offset +\n   663→     *               1 ] contain the first 16-bit unicode character\n   664→     * @param len    the max. length of the final string\n   665→     * @return the converted string, never {@code null}.\n   666→     * @throws ArrayIndexOutOfBoundsException if offset is out of bounds for\n   667→     *                                        the byte array (i.e., is negative or is greater than or equal to\n   668→     *                                        string.length)\n   669→     * @throws IllegalArgumentException       if len is too large (i.e.,\n   670→     *                                        there is not enough data in string to create a String of that\n   671→     *                                        length)\n   672→     */\n   673→    public static String getFromUnicodeLE0Terminated(\n   674→            final byte[] string,\n   675→            final int offset,\n   676→            final int len)\n   677→            throws ArrayIndexOutOfBoundsException, IllegalArgumentException {\n   678→        if ((offset < 0) || (offset >= string.length)) {\n   679→            throw new ArrayIndexOutOfBoundsException("Illegal offset " + offset + " (String data is of length " + string.length + ")");\n   680→        }\n   681→\n   682→        if ((len < 0) || (((string.length - offset) / 2) < len)) {\n   683→            throw new IllegalArgumentException("Illegal length " + len);\n   684→        }\n   685→\n   686→        final int newOffset;\n   687→        final int newMaxLen;\n   688→        final String prefix;\n   689→\n   690→        // #61881 - for now we only check the first char\n   691→        if (len > 0 && offset < (string.length - 1) && string[offset] == 0 && string[offset+1] == 0) {\n   692→            newOffset = offset+2;\n   693→            prefix = "?";\n   694→\n   695→            // check if the next char is garbage and limit the len if necessary\n   696→            final int cp = (len > 1) ? LittleEndian.getShort(string, offset+2) : 0;\n   697→            newMaxLen = Character.isJavaIdentifierPart(cp) ? len-1 : 0;\n   698→        } else {\n   699→            newOffset = offset;\n   700→            prefix = "";\n   701→            newMaxLen = len;\n   702→        }\n   703→\n   704→        int newLen = 0;\n   705→\n   706→        // loop until we find a null-terminated end\n   707→        for(; newLen < newMaxLen; newLen++) {\n   708→            if (string[newOffset + newLen * 2] == 0 && string[newOffset + newLen * 2 + 1] == 0) {\n   709→                break;\n   710→            }\n   711→        }\n   712→        newLen = Math.min(newLen, newMaxLen);\n   713→\n   714→        return prefix + ((newLen == 0) ? "" : new String(string, newOffset, newLen * 2, UTF16LE));\n   715→    }\n   716→\n   717→\n   718→    /**\n   719→     * Gets a CharSequence length or {@code 0} if the CharSequence is\n   720→     * {@code null}.\n   721→     *\n   722→     * copied from commons-lang3\n   723→     *\n   724→     * @param cs\n   725→     *            a CharSequence or {@code null}\n   726→     * @return CharSequence length or {@code 0} if the CharSequence is\n   727→     *         {@code null}.\n   728→     */\n   729→    public static int length(final CharSequence cs) {\n   730→        return cs == null ? 0 : cs.length();\n   731→    }\n   732→\n   733→    /**\n   734→     * <p>Checks if a CharSequence is empty (""), null or whitespace only.</p>\n   735→     *\n   736→     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n   737→     *\n   738→     * <pre>\n   739→     * StringUtil.isBlank(null)      = true\n   740→     * StringUtil.isBlank("")        = true\n   741→     * StringUtil.isBlank(" ")       = true\n   742→     * StringUtil.isBlank("bob")     = false\n   743→     * StringUtil.isBlank("  bob  ") = false\n   744→     * </pre>\n   745→     *\n   746→     * copied from commons-lang3\n   747→     *\n   748→     * @param cs  the CharSequence to check, may be null\n   749→     * @return {@code true} if the CharSequence is null, empty or whitespace only\n   750→     */\n   751→    public static boolean isBlank(final CharSequence cs) {\n   752→        final int strLen = length(cs);\n   753→        if (strLen == 0) {\n   754→            return true;\n   755→        }\n   756→        for (int i = 0; i < strLen; i++) {\n   757→            if (!Character.isWhitespace(cs.charAt(i))) {\n   758→                return false;\n759→            }\n   760→        }\n   761→        return true;\n   762→    }\n   763→\n   764→    /**\n   765→     * <p>Checks if a CharSequence is not empty (""), not null and not whitespace only.</p>\n   766→     *\n   767→     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n   768→     *\n   769→     * <pre>\n   770→     * StringUtil.isNotBlank(null)      = false\n   771→     * StringUtil.isNotBlank("")        = false\n   772→     * StringUtil.isNotBlank(" ")       = false\n   773→     * StringUtil.isNotBlank("bob")     = true\n   774→     * StringUtil.isNotBlank("  bob  ") = true\n   775→     * </pre>\n   776→     *\n   777→     * copied from commons-lang3\n   778→     *\n   779→     * @param cs  the CharSequence to check, may be null\n   780→     * @return {@code true} if the CharSequence is\n   781→     *  not empty and not null and not whitespace only\n   782→     */\n   783→    public static boolean isNotBlank(final CharSequence cs) {\n   784→        return !isBlank(cs);\n   785→    }\n   786→\n   787→    /**\n   788→     * <p>Returns padding using the specified delimiter repeated\n   789→     * to a given length.</p>\n   790→     *\n   791→     * <pre>\n   792→     * StringUtil.repeat(\'e\', 0)  = ""\n   793→     * StringUtil.repeat(\'e\', 3)  = "eee"\n   794→     * StringUtil.repeat(\'e\', -2) = ""\n   795→     * </pre>\n   796→     *\n   797→     * <p>Note: this method does not support padding with\n   798→     * <a href="http://www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a>\n   799→     * as they require a pair of {@code char}s to be represented.\n   800→     * </p>\n   801→     *\n   802→     * copied from commons-lang3\n   803→     *\n   804→     * @param ch  character to repeat\n   805→     * @param repeat  number of times to repeat char, negative treated as zero\n   806→     * @return String with repeated character\n   807→     */\n   808→    public static String repeat(final char ch, final int repeat) {\n   809→        if (repeat <= 0) {\n   810→            return "";\n   811→        }\n   812→        final char[] buf = new char[repeat];\n   813→        Arrays.fill(buf, ch);\n   814→        return new String(buf);\n   815→    }\n   816→\n   817→}\n   818→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 14: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Now I understand the issue. Looking at the stack trace:\n1. `MAPIAttribute.create()` at line 175 calls `StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1)`\n2. The `mplen` variable is read directly from the input stream at line 167 without proper validation for maximum size\n3. A malicious input can specify a very large `mplen` value, causing allocation of a huge byte array and subsequently the OOM error\n\nLooking at line 167-175 of `MAPIAttribute.java`:\n```java\nint mplen = LittleEndian.readInt(inp);\nif (mplen < 0) {\n    throw new IOException("Did not expect negative value: " + mplen);\n}\nbyte[] mpdata = new byte[mplen];\nif (IOUtils.readFully(inp, mpdata) < 0) {\n    throw new IOException("Not enough data to read " + mplen + " bytes for attribute name");\n}\nname = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);\n```\n\nThe fix should use `IOUtils.safelyAllocate()` instead of directly creating a `new byte[mplen]` to bound the allocation size. Let me apply the fix:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 15: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01N76FcyMg4vxqYVKw78N1RS', name='Edit', input={'file_path': '/home/qqor/crete/.cache/official-afc-poi/poi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIAttribute.java', 'old_string': '               // Custom name was stored\n                  int mplen = LittleEndian.readInt(inp);\n                  if (mplen < 0) {\n                     throw new IOException("Did not expect negative value: " + mplen);\n                  }\n                  byte[] mpdata = new byte[mplen];\n                  if (IOUtils.readFully(inp, mpdata) < 0) {\n                     throw new IOException("Not enough data to read " + mplen + " bytes for attribute name");\n                  }\n                  name = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);', 'new_string': '               // Custom name was stored\n                  int mplen = LittleEndian.readInt(inp);\n                  if (mplen < 0) {\n                     throw new IOException("Did not expect negative value: " + mplen);\n                  }\n                  byte[] mpdata = IOUtils.safelyAllocate(mplen, MAX_RECORD_LENGTH);\n                  if (IOUtils.readFully(inp, mpdata) < 0) {\n                     throw new IOException("Not enough data to read " + mplen + " bytes for attribute name");\n                  }\n                  name = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 16: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01N76FcyMg4vxqYVKw78N1RS', content='The file /home/qqor/crete/.cache/official-afc-poi/poi-scratchpad/src/main/java/org/apache/poi/hmef/attribute/MAPIAttribute.java has been updated. Here\'s the result of running `cat -n` on a snippet of the edited file:\n   162→                  int mpid = LittleEndian.readInt(inp);\n   163→                  MAPIProperty base = MAPIProperty.get(mpid);\n   164→                  name = base.name;\n   165→               } else {\n   166→                  // Custom name was stored\n   167→                  int mplen = LittleEndian.readInt(inp);\n   168→                  if (mplen < 0) {\n   169→                     throw new IOException("Did not expect negative value: " + mplen);\n   170→                  }\n   171→                  byte[] mpdata = IOUtils.safelyAllocate(mplen, MAX_RECORD_LENGTH);\n   172→                  if (IOUtils.readFully(inp, mpdata) < 0) {\n   173→                     throw new IOException("Not enough data to read " + mplen + " bytes for attribute name");\n   174→                  }\n   175→                  name = StringUtil.getFromUnicodeLE(mpdata, 0, (mplen/2)-1);\n   176→                  skipToBoundary(mplen, inp);\n   177→               }\n   178→\n   179→               // Now create', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 17: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='The patch has been applied. The fix changes line 171 from:\n```java\nbyte[] mpdata = new byte[mplen];\n```\nto:\n```java\nbyte[] mpdata = IOUtils.safelyAllocate(mplen, MAX_RECORD_LENGTH);\n```\n\nThis uses the `IOUtils.safelyAllocate()` method which will throw an exception if `mplen` exceeds the `MAX_RECORD_LENGTH` (1,000,000 bytes) limit, preventing the Out of Memory condition caused by malicious input that specifies an extremely large length value.\n\nThe fix is consistent with how other byte array allocations are handled in the same file (see line 198 which already uses `IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH)`).')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 18: ResultMessage
================================================================================
ResultMessage(subtype='success', duration_ms=27429, duration_api_ms=28311, is_error=False, num_turns=8, session_id='fa76b057-f96c-45cb-b312-75b4d1068f90', total_cost_usd=0.19358775, usage={'input_tokens': 82, 'cache_creation_input_tokens': 19201, 'cache_read_input_tokens': 75703, 'output_tokens': 1354, 'server_tool_use': {'web_search_requests': 0, 'web_fetch_requests': 0}, 'service_tier': 'standard', 'cache_creation': {'ephemeral_1h_input_tokens': 0, 'ephemeral_5m_input_tokens': 19201}}, result='The patch has been applied. The fix changes line 171 from:\n```java\nbyte[] mpdata = new byte[mplen];\n```\nto:\n```java\nbyte[] mpdata = IOUtils.safelyAllocate(mplen, MAX_RECORD_LENGTH);\n```\n\nThis uses the `IOUtils.safelyAllocate()` method which will throw an exception if `mplen` exceeds the `MAX_RECORD_LENGTH` (1,000,000 bytes) limit, preventing the Out of Memory condition caused by malicious input that specifies an extremely large length value.\n\nThe fix is consistent with how other byte array allocations are handled in the same file (see line 198 which already uses `IOUtils.safelyAllocate(len, MAX_RECORD_LENGTH)`).', structured_output=None)
