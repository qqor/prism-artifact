
================================================================================
Message 0: SystemMessage
================================================================================
SystemMessage(subtype='init', data={'type': 'system', 'subtype': 'init', 'cwd': '/home/user/crete/.cache/official-afc-wireshark', 'session_id': 'c1fc151f-ee41-44f6-8d3e-e7a15225bc29', 'tools': ['Task', 'Bash', 'Glob', 'Grep', 'ExitPlanMode', 'Read', 'Edit', 'Write', 'NotebookEdit', 'WebFetch', 'TodoWrite', 'WebSearch', 'BashOutput', 'KillShell', 'Skill', 'SlashCommand', 'EnterPlanMode'], 'mcp_servers': [], 'model': 'claude-opus-4-5-20251101', 'permissionMode': 'bypassPermissions', 'slash_commands': ['compact', 'context', 'cost', 'init', 'pr-comments', 'release-notes', 'todos', 'review', 'security-review'], 'apiKeySource': 'none', 'claude_code_version': '2.0.53', 'output_style': 'default', 'agents': ['general-purpose', 'statusline-setup', 'Explore', 'Plan'], 'skills': [], 'plugins': [], 'uuid': 'e58595ad-8627-4ef9-8970-0645b6eb170b'})

================================================================================
Message 1: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01FqXXK9mUaUmBTCfSAa7oa5', name='Read', input={'file_path': '/src/wireshark/epan/dissectors/packet-netbios.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 2: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01FqXXK9mUaUmBTCfSAa7oa5', content='<tool_use_error>File does not exist.</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 3: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Let me search for the file in a different location:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 4: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01S3Wp5MHb9tN4gLUYFtimdb', name='Glob', input={'pattern': '**/packet-netbios.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 5: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01S3Wp5MHb9tN4gLUYFtimdb', content='/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-netbios.c', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 6: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01BsEndxARpx3pVYWpyY1Sju', name='Read', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-netbios.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 7: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01BsEndxARpx3pVYWpyY1Sju', content='     1→/* packet-netbios.c\n     2→ * Routines for NetBIOS protocol packet disassembly\n     3→ * Jeff Foster <jfoste@woodward.com>\n     4→ * Copyright 1999 Jeffrey C. Foster\n     5→ *\n     6→ * derived from the packet-nbns.c\n     7→ *\n     8→ * Wireshark - Network traffic analyzer\n     9→ * By Gerald Combs <gerald@wireshark.org>\n    10→ * Copyright 1998 Gerald Combs\n    11→ *\n    12→ * SPDX-License-Identifier: GPL-2.0-or-later\n    13→ */\n    14→\n    15→#include "config.h"\n    16→\n    17→#include <epan/packet.h>\n    18→#include <epan/capture_dissectors.h>\n    19→#include <epan/llcsaps.h>\n    20→#include <epan/reassemble.h>\n    21→#include <epan/prefs.h>\n    22→#include <epan/expert.h>\n    23→#include <epan/tfs.h>\n    24→#include <wsutil/array.h>\n    25→#include "packet-netbios.h"\n    26→\n    27→void proto_register_netbios(void);\n    28→void proto_reg_handoff_netbios(void);\n    29→\n    30→static dissector_handle_t netbios_handle;\n    31→static capture_dissector_handle_t netbios_cap_handle;\n    32→\n    33→/* Netbios command numbers */\n    34→#define NB_ADD_GROUP\t\t0x00\n    35→#define NB_ADD_NAME\t\t0x01\n    36→#define NB_NAME_IN_CONFLICT\t0x02\n    37→#define NB_STATUS_QUERY\t\t0x03\n    38→#define NB_TERMINATE_TRACE_R\t0x07\n    39→#define NB_DATAGRAM\t\t0x08\n    40→#define NB_DATAGRAM_BCAST\t0x09\n    41→#define NB_NAME_QUERY\t\t0x0a\n    42→#define NB_ADD_NAME_RESP\t0x0d\n    43→#define NB_NAME_RESP \t\t0x0e\n    44→#define NB_STATUS_RESP \t\t0x0f\n    45→#define NB_TERMINATE_TRACE_LR\t0x13\n    46→#define NB_DATA_ACK\t\t0x14\n    47→#define NB_DATA_FIRST_MIDDLE\t0x15\n    48→#define NB_DATA_ONLY_LAST\t0x16\n    49→#define NB_SESSION_CONFIRM\t0x17\n    50→#define NB_SESSION_END\t\t0x18\n    51→#define NB_SESSION_INIT\t\t0x19\n    52→#define NB_NO_RECEIVE\t\t0x1a\n    53→#define NB_RECEIVE_OUTSTANDING\t0x1b\n    54→#define NB_RECEIVE_CONTINUE\t0x1c\n    55→#define NB_KEEP_ALIVE\t\t0x1f\n    56→\n    57→/* Offsets of fields in the NetBIOS header. */\n    58→#define NB_LENGTH\t\t 0\n    59→#define\tNB_DELIMITER\t\t 2\n    60→#define\tNB_COMMAND\t\t 4\n    61→#define\tNB_FLAGS\t\t 5\n    62→#define\tNB_DATA1\t\t 5\n    63→#define\tNB_RESYNC\t\t 6\n    64→#define\tNB_DATA2\t\t 6\n    65→#define\tNB_CALL_NAME_TYPE\t 7\n    66→#define\tNB_XMIT_CORL\t\t 8\n    67→#define\tNB_RESP_CORL\t\t10\n    68→#define\tNB_RMT_SES\t\t12\n    69→#define\tNB_LOCAL_SES\t\t13\n    70→#define\tNB_RECVER_NAME\t\t12\n    71→#define\tNB_SENDER_NAME\t\t28\n    72→\n    73→\n    74→static int proto_netbios;\n    75→static int hf_netb_cmd;\n    76→static int hf_netb_hdr_len;\n    77→static int hf_netb_delimiter;\n    78→static int hf_netb_xmit_corrl;\n    79→static int hf_netb_resp_corrl;\n    80→static int hf_netb_call_name_type;\n    81→static int hf_netb_version;\n    82→static int hf_netbios_no_receive_flags;\n    83→static int hf_netbios_no_receive_flags_send_no_ack;\n    84→static int hf_netb_largest_frame;\n    85→static int hf_netb_nb_name;\n    86→static int hf_netb_nb_name_type;\n    87→static int hf_netb_status_buffer_len;\n    88→static int hf_netb_status;\n    89→static int hf_netb_name_type;\n    90→static int hf_netb_max_data_recv_size;\n    91→static int hf_netb_termination_indicator;\n    92→static int hf_netb_num_data_bytes_accepted;\n    93→static int hf_netb_local_ses_no;\n    94→static int hf_netb_remote_ses_no;\n    95→static int hf_netb_flags;\n    96→static int hf_netb_flags_send_no_ack;\n    97→static int hf_netb_flags_ack;\n    98→static int hf_netb_flags_ack_with_data;\n    99→static int hf_netb_flags_ack_expected;\n   100→static int hf_netb_flags_recv_cont_req;\n   101→static int hf_netb_data2;\n   102→static int hf_netb_data2_frame;\n   103→static int hf_netb_data2_user;\n   104→static int hf_netb_data2_status;\n   105→static int hf_netb_datagram_mac;\n   106→static int hf_netb_datagram_bcast_mac;\n   107→static int hf_netb_resync_indicator;\n   108→static int hf_netb_status_request;\n   109→static int hf_netb_local_session_no;\n   110→static int hf_netb_state_of_name;\n   111→static int hf_netb_status_response;\n   112→static int hf_netb_fragments;\n   113→static int hf_netb_fragment;\n   114→static int hf_netb_fragment_overlap;\n   115→static int hf_netb_fragment_overlap_conflict;\n   116→static int hf_netb_fragment_multiple_tails;\n   117→static int hf_netb_fragment_too_long_fragment;\n   118→static int hf_netb_fragment_error;\n   119→static int hf_netb_fragment_count;\n   120→static int hf_netb_reassembled_length;\n   121→\n   122→static int ett_netb;\n   123→static int ett_netb_name;\n   124→static int ett_netb_flags;\n   125→static int ett_netb_status;\n   126→static int ett_netb_fragments;\n   127→static int ett_netb_fragment;\n   128→\n   129→static expert_field ei_netb_unknown_command_data;\n   130→\n   131→static const fragment_items netbios_frag_items = {\n   132→\t&ett_netb_fragment,\n   133→\t&ett_netb_fragments,\n   134→\t&hf_netb_fragments,\n   135→\t&hf_netb_fragment,\n   136→\t&hf_netb_fragment_overlap,\n   137→\t&hf_netb_fragment_overlap_conflict,\n   138→\t&hf_netb_fragment_multiple_tails,\n   139→\t&hf_netb_fragment_too_long_fragment,\n   140→\t&hf_netb_fragment_error,\n   141→\t&hf_netb_fragment_count,\n   142→\tNULL,\n   143→\t&hf_netb_reassembled_length,\n   144→\t/* Reassembled data field */\n   145→\tNULL,\n   146→\t"fragments"\n   147→};\n   148→\n   149→/* The strings for the station type, used by get_netbios_name function;\n   150→   many of them came from the file "NetBIOS.txt" in the Zip archive at\n   151→\n   152→\thttp://www.net3group.com/ftp/browser.zip\n   153→ */\n   154→\n   155→static const value_string nb_name_type_vals[] = {\n   156→\t{0x00,\t"Workstation/Redirector"},\n   157→\t{0x01,\t"Browser"},\n   158→\t{0x02,\t"Workstation/Redirector"},\n   159→\t\t/* not sure what 0x02 is, I\'m seeing a lot of them however */\n   160→\t\t/* I\'m seeing them with workstation/redirection host\n   161→\t\t\tannouncements */\n   162→\t{0x03,\t"Messenger service/Main name"},\n   163→\t{0x05,\t"Forwarded name"},\n   164→\t{0x06,\t"RAS Server service"},\n   165→\t{0x1b,\t"Domain Master Browser"},\n   166→\t{0x1c,\t"Domain Controllers"},\n   167→\t{0x1d,\t"Local Master Browser"},\n   168→\t{0x1e,\t"Browser Election Service"},\n   169→\t{0x1f,\t"Net DDE Service"},\n   170→\t{0x20,\t"Server service"},\n   171→\t{0x21,\t"RAS client service"},\n   172→\t{0x22,\t"Exchange Interchange (MSMail Connector)"},\n   173→\t{0x23,\t"Exchange Store"},\n   174→\t{0x24,\t"Exchange Directory"},\n   175→\t{0x2b,\t"Lotus Notes Server service"},\n   176→\t{0x30,\t"Modem sharing server service"},\n   177→\t{0x31,\t"Modem sharing client service"},\n   178→\t{0x43,\t"SMS Clients Remote Control"},\n   179→\t{0x44,\t"SMS Administrators Remote Control Tool"},\n   180→\t{0x45,\t"SMS Clients Remote Chat"},\n   181→\t{0x46,\t"SMS Clients Remote Transfer"},\n   182→\t{0x4c,\t"DEC Pathworks TCP/IP Service on Windows NT"},\n   183→\t{0x52,\t"DEC Pathworks TCP/IP Service on Windows NT"},\n   184→\t{0x6a,\t"Microsoft Exchange IMC"},\n   185→\t{0x87,\t"Microsoft Exchange MTA"},\n   186→\t{0xbe,\t"Network Monitor Agent"},\n   187→\t{0xbf,\t"Network Monitor Analyzer"},\n   188→\t{0x00,\tNULL}\n   189→};\n   190→static value_string_ext nb_name_type_vals_ext = VALUE_STRING_EXT_INIT(nb_name_type_vals);\n   191→\n   192→/* Table for reassembly of fragments. */\n   193→static reassembly_table netbios_reassembly_table;\n   194→\n   195→/* defragmentation of NetBIOS Frame */\n   196→static bool netbios_defragment = true;\n   197→\n   198→/* See\n   199→\n   200→\thttp://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS/BK8P7001/CCONTENTS\n   201→\n   202→   and\n   203→\n   204→\thttp://ourworld.compuserve.com/homepages/TimothyDEvans/contents.htm\n   205→\n   206→   for information about the NetBIOS Frame Protocol (which is what this\n   207→   module dissects). */\n   208→\n   209→/* the strings for the command types  */\n   210→\n   211→static const value_string cmd_vals[] = {\n   212→\t{ NB_ADD_GROUP,\t\t\t"Add Group Name Query" },\n   213→\t{ NB_ADD_NAME,\t\t\t"Add Name Query" },\n   214→\t{ NB_NAME_IN_CONFLICT,\t\t"Name In Conflict" },\n   215→\t{ NB_STATUS_QUERY,\t\t"Status Query" },\n   216→\t{ NB_TERMINATE_TRACE_R,\t\t"Terminate Trace" },\n   217→\t{ NB_DATAGRAM,\t\t\t"Datagram" },\n   218→\t{ NB_DATAGRAM_BCAST,\t\t"Broadcast Datagram" },\n   219→\t{ NB_NAME_QUERY,\t\t"Name Query" },\n   220→\t{ NB_ADD_NAME_RESP,\t\t"Add Name Response" },\n   221→\t{ NB_NAME_RESP,\t\t\t"Name Recognized" },\n   222→\t{ NB_STATUS_RESP,\t\t"Status Response" },\n   223→\t{ NB_TERMINATE_TRACE_LR,\t"Terminate Trace" },\n   224→\t{ NB_DATA_ACK,\t\t\t"Data Ack" },\n   225→\t{ NB_DATA_FIRST_MIDDLE,\t\t"Data First Middle" },\n   226→\t{ NB_DATA_ONLY_LAST,\t\t"Data Only Last" },\n   227→\t{ NB_SESSION_CONFIRM,\t\t"Session Confirm" },\n   228→\t{ NB_SESSION_END,\t\t"Session End" },\n   229→\t{ NB_SESSION_INIT,\t\t"Session Initialize" },\n   230→\t{ NB_NO_RECEIVE,\t\t"No Receive" },\n   231→\t{ NB_RECEIVE_OUTSTANDING,\t"Receive Outstanding" },\n   232→\t{ NB_RECEIVE_CONTINUE,\t\t"Receive Continue" },\n   233→\t{ NB_KEEP_ALIVE,\t\t"Session Alive" },\n   234→\t{ 0,\t\t\t\tNULL }\n   235→};\n   236→static value_string_ext cmd_vals_ext = VALUE_STRING_EXT_INIT(cmd_vals);\n   237→\n   238→static const value_string name_types[] = {\n   239→\t{ 0, "Unique name" },\n   240→\t{ 1, "Group name" },\n   241→\t{ 0, NULL }\n   242→};\n   243→\n   244→\n   245→static const true_false_string netb_version_str = {\n   246→\t"2.00 or higher",\n   247→\t"1.xx"\n   248→};\n   249→\n   250→static const value_string termination_indicator_vals[] = {\n   251→\t{ 0x0000, "Normal session end" },\n   252→\t{ 0x0001, "Abnormal session end" },\n   253→\t{ 0,      NULL }\n   254→};\n   255→\n   256→static const value_string status_vals[] = {\n   257→\t{ 0, "Add name not in process" },\n   258→\t{ 1, "Add name in process" },\n   259→\t{ 0, NULL }\n   260→};\n   261→\n   262→static const value_string max_frame_size_vals[] = {\n   263→\t{ 0,\t"516" },\n   264→\t{ 1,\t"1500" },\n   265→\t{ 2,\t"2052" },\n   266→\t{ 3,\t"4472" },\n   267→\t{ 4,\t"8144" },\n   268→\t{ 5,\t"11407" },\n   269→\t{ 6,\t"17800" },\t/* 17800 in TR spec, 17749 in NBF spec */\n   270→\t{ 7,\t"65535" },\n   271→\t{ 0,\tNULL }\n   272→};\n   273→\n   274→\n   275→static bool\n   276→capture_netbios(const unsigned char *pd _U_, int offset _U_, int len _U_, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\n   277→{\n   278→\tcapture_dissector_increment_count(cpinfo, proto_netbios);\n   279→\treturn true;\n   280→}\n   281→\n   282→\n   283→int\n   284→process_netbios_name(const unsigned char *name_ptr, char *name_ret, int name_ret_len)\n   285→{\n   286→\tint    i;\n   287→\tint    name_type = *(name_ptr + NETBIOS_NAME_LEN - 1);\n   288→\tunsigned char name_char;\n   289→\tchar  *name_ret_orig = name_ret;\n   290→\tstatic const char hex_digits[16] = {\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n   291→\n   292→\tfor (i = 0; i < NETBIOS_NAME_LEN - 1; i++) {\n   293→\t\tname_char = *name_ptr++;\n   294→\t\tif (name_char >= \' \' && name_char <= \'~\') {\n   295→\t\t\tif (--name_ret_len > 0)\n   296→\t\t\t\t*name_ret++ = name_char;\n   297→\t\t} else {\n   298→\t\t\t/* It\'s not printable; show it as <XX>, where\n   299→\t\t\t   XX is the value in hex. */\n   300→\t\t\tif (--name_ret_len > 0)\n   301→\t\t\t\t*name_ret++ = \'<\';\n   302→\t\t\tif (--name_ret_len > 0)\n   303→\t\t\t\t*name_ret++ = hex_digits[(name_char >> 4)];\n   304→\t\t\tif (--name_ret_len > 0)\n   305→\t\t\t\t*name_ret++ = hex_digits[(name_char & 0x0F)];\n   306→\t\t\tif (--name_ret_len > 0)\n   307→\t\t\t\t*name_ret++ = \'>\';\n   308→\t\t}\n   309→\t}\n   310→\t*name_ret = \'\\0\';\n   311→\n   312→\t/* Remove trailing space characters from name. */\n   313→\n   314→\tname_ret--;\n   315→\n   316→\twhile (name_ret >= name_ret_orig) {\n   317→\t\tif (*name_ret != \' \') {\n   318→\t\t\t*(name_ret + 1) = 0;\n   319→\t\t\tbreak;\n   320→\t\t}\n   321→\t\tname_ret--;\n   322→\t}\n   323→\n   324→\treturn name_type;\n   325→}\n   326→\n   327→\n   328→int\n   329→get_netbios_name( tvbuff_t *tvb, int offset, char *name_ret, int name_ret_len)\n   330→\n   331→{/*  Extract the name string and name type.  Return the name string in  */\n   332→ /* name_ret and return the name_type. */\n   333→\n   334→\treturn process_netbios_name( tvb_get_ptr( tvb, offset, NETBIOS_NAME_LEN ), name_ret, name_ret_len);\n   335→}\n   336→\n   337→\n   338→/*\n   339→ * Get a string describing the type of a NetBIOS name.\n   340→ */\n   341→const char *\n   342→netbios_name_type_descr(int name_type)\n   343→\n   344→{\n   345→\treturn val_to_str_ext_const(name_type, &nb_name_type_vals_ext, "Unknown");\n   346→}\n   347→\n   348→void\n   349→netbios_add_name(const char* label, tvbuff_t *tvb, int offset, proto_tree *tree)\n   350→\n   351→{/* add a name field display tree. Display the name and station type in sub-tree */\n   352→\n   353→\tproto_tree *field_tree;\n   354→\tchar        name_str[(NETBIOS_NAME_LEN - 1)*4 + 1];\n   355→\tint         name_type;\n   356→\tconst char *name_type_str;\n   357→\n   358→\t\t\t\t\t/* decode the name field */\n   359→\tname_type = get_netbios_name( tvb, offset, name_str, (NETBIOS_NAME_LEN - 1)*4 + 1);\n   360→\tname_type_str = netbios_name_type_descr(name_type);\n   361→\tfield_tree = proto_tree_add_subtree_format( tree, tvb, offset, NETBIOS_NAME_LEN,\n   362→\t\t\tett_netb_name, NULL, "%s: %s<%02x> (%s)", label, name_str, name_type, name_type_str);\n   363→\n   364→\tproto_tree_add_string_format( field_tree, hf_netb_nb_name, tvb, offset,\n   365→\t\t15, name_str, "%s", name_str);\n   366→\tproto_tree_add_uint_format( field_tree, hf_netb_nb_name_type, tvb, offset + 15, 1, name_type,\n   367→\t\t"0x%02x (%s)", name_type, name_type_str);\n   368→}\n   369→\n   370→\n   371→static void\n   372→netbios_data_first_middle_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\n   373→\n   374→{\n   375→\tproto_tree *field_tree;\n   376→\tproto_item *tf;\n   377→\n   378→\t\t/* decode the flag field for Data First Middle packet*/\n   379→\n   380→\ttf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   381→\tfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\n   382→\n   383→\tproto_tree_add_item( field_tree, hf_netb_flags_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   384→\n   385→\tproto_tree_add_item( field_tree, hf_netb_flags_ack_expected, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   386→\n   387→\tproto_tree_add_item( field_tree, hf_netb_flags_recv_cont_req, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   388→}\n   389→\n   390→static void\n   391→netbios_data_only_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\n   392→\n   393→{\n   394→\tproto_tree *field_tree;\n   395→\tproto_item *tf;\n   396→\n   397→\t/* decode the flag field for Data Only Last packet*/\n   398→\ttf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   399→\tfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\n   400→\n   401→\tproto_tree_add_item( field_tree, hf_netb_flags_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   402→\n   403→\tproto_tree_add_item( field_tree, hf_netb_flags_ack_with_data, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   404→\n   405→\tproto_tree_add_item( field_tree, hf_netb_flags_ack_expected, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   406→}\n   407→\n   408→\n   409→\n   410→static void\n   411→netbios_add_ses_confirm_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\n   412→\n   413→{\n   414→\tproto_tree *field_tree;\n   415→\tproto_item *tf;\n   416→\n   417→\t/* decode the flag field for Session Confirm packet */\n   418→\ttf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   419→\tfield_tree = proto_item_add_subtree( tf, ett_netb_flags);\n   420→\n   421→\tproto_tree_add_item( field_tree, hf_netb_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   422→\n   423→\tproto_tree_add_item( field_tree, hf_netb_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   424→}\n   425→\n   426→\n   427→static void\n   428→netbios_add_session_init_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\n   429→\n   430→{\n   431→\tproto_tree *field_tree;\n   432→\tproto_item *tf;\n   433→\n   434→\t/* decode the flag field for Session Init packet */\n   435→\ttf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   436→\tfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\n   437→\n   438→\tproto_tree_add_item( field_tree, hf_netb_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   439→\n   440→\tproto_tree_add_item( field_tree, hf_netb_largest_frame, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   441→\n   442→\tproto_tree_add_item( field_tree, hf_netb_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   443→}\n   444→\n   445→\n   446→static void\n   447→netbios_no_receive_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\n   448→\n   449→{\n   450→\tproto_tree *field_tree;\n   451→\tproto_item *tf;\n   452→\n   453→\t/* decode the flag field for No Receive packet*/\n   454→\ttf = proto_tree_add_item(tree, hf_netbios_no_receive_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   455→\tfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\n   456→\tproto_tree_add_item(field_tree, hf_netbios_no_receive_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n   457→}\n   458→\n   459→\n   460→/************************************************************************/\n   461→/*\t\t\t\t\t\t\t\t\t*/\n   462→/*  The routines to display the netbios field values in the tree\t*/\n   463→/*\t\t\t\t\t\t\t\t\t*/\n   464→/************************************************************************/\n   465→\n   466→\n   467→static void\n   468→nb_xmit_corrl( tvbuff_t *tvb, int offset, proto_tree *tree)\n   469→\n   470→{/* display the transmit correlator */\n   471→\n   472→\tproto_tree_add_item( tree, hf_netb_xmit_corrl, tvb, offset + NB_XMIT_CORL,\n   473→\t\t2, ENC_LITTLE_ENDIAN);\n   474→}\n   475→\n   476→\n   477→static void\n   478→nb_resp_corrl( tvbuff_t *tvb, int offset, proto_tree *tree)\n   479→\n   480→{/* display the response correlator */\n   481→\n   482→\tproto_tree_add_item( tree, hf_netb_resp_corrl, tvb, offset + NB_RESP_CORL,\n   483→\t\t2, ENC_LITTLE_ENDIAN);\n   484→}\n   485→\n   486→\n   487→static void\n   488→nb_call_name_type( tvbuff_t *tvb, int offset, proto_tree *tree)\n   489→\n   490→{/* display the call name type */\n   491→\n   492→\tproto_tree_add_item( tree, hf_netb_call_name_type, tvb, offset + NB_CALL_NAME_TYPE,\n   493→\t\t1, ENC_LITTLE_ENDIAN);\n   494→\n   495→}\n   496→\n   497→\n   498→static uint8_t\n   499→nb_local_session( tvbuff_t *tvb, int offset, proto_tree *tree)\n   500→\n   501→{/* add the local session to tree, and return its value */\n   502→\n   503→\tuint8_t local_session = tvb_get_uint8( tvb, offset + NB_LOCAL_SES);\n   504→\n   505→\tproto_tree_add_uint( tree, hf_netb_local_ses_no, tvb, offset + NB_LOCAL_SES, 1,\n   506→\t\tlocal_session);\n   507→\n   508→\treturn local_session;\n   509→}\n   510→\n   511→\n   512→static uint8_t\n   513→nb_remote_session( tvbuff_t *tvb, int offset, proto_tree *tree)\n   514→\n   515→{/* add the remote session to tree, and return its value */\n   516→\n   517→\tuint8_t remote_session = tvb_get_uint8( tvb, offset + NB_RMT_SES);\n   518→\n   519→\tproto_tree_add_uint( tree, hf_netb_remote_ses_no, tvb, offset + NB_RMT_SES, 1,\n   520→\t\tremote_session);\n   521→\n   522→\treturn remote_session;\n   523→}\n   524→\n   525→\n   526→static void\n   527→nb_data1(int hf, tvbuff_t *tvb, int offset, proto_tree *tree)\n   528→\n   529→{/* add the DATA1 to tree with specified hf_ value */\n   530→\n   531→\tproto_tree_add_item( tree, hf, tvb, offset + NB_DATA1, 1, ENC_LITTLE_ENDIAN);\n   532→\n   533→}\n   534→\n   535→\n   536→static void\n   537→nb_data2(int hf, tvbuff_t *tvb, int offset, proto_tree *tree)\n   538→\n   539→{/* add the DATA2 to tree with specified hf_ value */\n   540→\n   541→\tproto_tree_add_item( tree, hf, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   542→\n   543→}\n   544→\n   545→\n   546→static void\n   547→nb_resync_indicator( tvbuff_t *tvb, int offset, proto_tree *tree, const char *cmd_str)\n   548→\n   549→{\n   550→\tuint16_t resync_indicator = tvb_get_letohs( tvb, offset + NB_DATA2);\n   551→\n   552→\n   553→\tswitch (resync_indicator) {\n   554→\n   555→\tcase 0x0000:\n   556→\t\tproto_tree_add_uint_format_value(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2,\n   557→\t\t    resync_indicator, "No re-sync");\n   558→\t\tbreak;\n   559→\n   560→\tcase 0x0001:\n   561→\t\tproto_tree_add_uint_format_value(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2,\n   562→\t\t    resync_indicator, "First \'%s\' following \'Receive Outstanding\'", cmd_str);\n   563→\t\tbreak;\n   564→\n   565→\tdefault:\n   566→\t\tproto_tree_add_item(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   567→\t\tbreak;\n   568→\t}\n   569→}\n   570→\n   571→/************************************************************************/\n   572→/*\t\t\t\t\t\t\t\t\t*/\n   573→/*  The routines called by the top level to handle individual commands  */\n   574→/*\t\t\t\t\t\t\t\t\t*/\n   575→/************************************************************************/\n   576→\n   577→static uint32_t\n   578→dissect_netb_unknown( tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *tree)\n   579→\n   580→{/* Handle any unknown commands, do nothing */\n   581→\n   582→\tproto_tree_add_expert(tree, pinfo, &ei_netb_unknown_command_data, tvb, offset + NB_COMMAND + 1, -1);\n   583→\n   584→\treturn 0;\n   585→}\n   586→\n   587→\n   588→static uint32_t\n   589→dissect_netb_add_group_name( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   590→\n   591→{/* Handle the ADD GROUP NAME QUERY command */\n   592→\n   593→\tnb_resp_corrl( tvb, offset, tree);\n   594→\n   595→\tnetbios_add_name("Group name to add", tvb, offset + NB_SENDER_NAME,\n   596→\t    tree);\n   597→\n   598→\treturn 0;\n   599→}\n   600→\n   601→\n   602→static uint32_t\n   603→dissect_netb_add_name( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   604→\n   605→{/* Handle the ADD NAME QUERY command */\n   606→\n   607→\tnb_resp_corrl( tvb, offset, tree);\n   608→\n   609→\tnetbios_add_name("Name to add", tvb, offset + NB_SENDER_NAME, tree);\n   610→\n   611→\treturn 0;\n   612→}\n   613→\n   614→\n   615→static uint32_t\n   616→dissect_netb_name_in_conflict( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   617→\n   618→{/* Handle the NAME IN CONFLICT command */\n   619→\n   620→\tnetbios_add_name("Name In Conflict", tvb, offset + NB_RECVER_NAME,\n   621→\t    tree);\n   622→\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME, tree);\n   623→\n   624→\treturn 0;\n   625→}\n   626→\n   627→\n   628→static uint32_t\n   629→dissect_netb_status_query( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   630→\n   631→{/* Handle the STATUS QUERY command */\n   632→\tuint8_t status_request = tvb_get_uint8( tvb, offset + NB_DATA1);\n   633→\n   634→\tswitch (status_request) {\n   635→\n   636→\tcase 0:\n   637→\t\tproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\n   638→\t\t    status_request, "NetBIOS 1.x or 2.0");\n   639→\t\tbreak;\n   640→\n   641→\tcase 1:\n   642→\t\tproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\n   643→\t\t    status_request, "NetBIOS 2.1, initial status request");\n   644→\t\tbreak;\n   645→\n   646→\tdefault:\n   647→\t\tproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\n   648→\t\t    status_request, "NetBIOS 2.1, %u names received so far",\n   649→\t\t    status_request);\n   650→\t\tbreak;\n   651→\t}\n   652→\tnb_data2( hf_netb_status_buffer_len, tvb, offset, tree);\n   653→\tnb_resp_corrl( tvb, offset, tree);\n   654→\tnetbios_add_name("Receiver\'s Name", tvb, offset + NB_RECVER_NAME, tree);\n   655→\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME, tree);\n   656→\n   657→\treturn 0;\n   658→}\n   659→\n   660→\n   661→static uint32_t\n   662→dissect_netb_terminate_trace( tvbuff_t *tvb _U_, packet_info *pinfo _U_, int offset _U_, proto_tree *tree _U_)\n   663→\n   664→{/* Handle the TERMINATE TRACE command */\n   665→\n   666→\t/*\n   667→\t * XXX - are any of the fields in this message significant?\n   668→\t * The IBM NetBIOS document shows them as "Reserved".\n   669→\t */\n   670→\n   671→\treturn 0;\n   672→}\n   673→\n   674→\n   675→static const unsigned char zeroes[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n   676→\n   677→static uint32_t\n   678→dissect_netb_datagram( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   679→\n   680→{/* Handle the DATAGRAM command */\n   681→\n   682→\tnetbios_add_name("Receiver\'s Name", tvb, offset + NB_RECVER_NAME, tree);\n   683→\t/* Weird.  In some datagrams, this is 10 octets of 0, followed\n   684→\t   by a MAC address.... */\n   685→\n   686→\tif (tvb_memeql(tvb, offset + NB_SENDER_NAME, zeroes, 10) == 0) {\n   687→\t\tproto_tree_add_item(tree, hf_netb_datagram_mac,\n   688→\t\t\t\t\t\t\ttvb, offset + NB_SENDER_NAME + 10, 6, ENC_NA );\n   689→\t} else {\n   690→\t\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME,\n   691→\t\t    tree);\n   692→\t}\n   693→\n   694→\treturn 0;\n   695→}\n   696→\n   697→\n   698→static uint32_t\n   699→dissect_netb_datagram_bcast( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   700→\n   701→{/* Handle the DATAGRAM BROADCAST command */\n   702→\n   703→\t/* We assume the same weirdness can happen here.... */\n   704→\tif (tvb_memeql(tvb, offset + NB_SENDER_NAME, zeroes, 10) == 0) {\n   705→\t\tproto_tree_add_item(tree, hf_netb_datagram_bcast_mac,\n   706→\t\t\t\t\t\t\ttvb, offset + NB_SENDER_NAME + 10, 6, ENC_NA );\n   707→\t} else {\n   708→\t\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME,\n   709→\t\t    tree);\n   710→\t}\n   711→\n   712→\treturn 0;\n   713→}\n   714→\n   715→\n   716→static uint32_t\n   717→dissect_netb_name_query( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   718→\n   719→{/* Handle the NAME QUERY command */\n   720→\tuint8_t local_session_number = tvb_get_uint8( tvb, offset + NB_DATA2);\n   721→\n   722→\tif (local_session_number == 0) {\n   723→\t\tproto_tree_add_uint_format_value( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1,\n   724→\t\t    local_session_number, "0 (FIND.NAME request)");\n   725→\t} else {\n   726→\t\tproto_tree_add_item( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1, ENC_LITTLE_ENDIAN);\n   727→\t}\n   728→\tnb_call_name_type( tvb, offset, tree);\n   729→\tnb_resp_corrl( tvb, offset, tree);\n   730→\tnetbios_add_name("Query Name", tvb, offset + NB_RECVER_NAME, tree);\n   731→\tif (local_session_number != 0) {\n   732→\t\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME,\n   733→\t\t    tree);\n   734→\t}\n   735→\n   736→\treturn 0;\n   737→}\n   738→\n   739→\n   740→static uint32_t\n   741→dissect_netb_add_name_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   742→\n   743→{/* Handle the ADD NAME RESPONSE command */\n   744→\n   745→\tnb_data1( hf_netb_status, tvb, offset, tree);\n   746→\tnb_data2( hf_netb_name_type, tvb, offset, tree);\n   747→\tnb_xmit_corrl( tvb, offset, tree);\n   748→\tnetbios_add_name("Name to be added", tvb, offset + NB_RECVER_NAME,\n   749→\t    tree);\n   750→\tnetbios_add_name("Name to be added", tvb, offset + NB_SENDER_NAME,\n   751→\t    tree);\n   752→\n   753→\treturn 0;\n   754→}\n   755→\n   756→\n   757→static uint32_t\n   758→dissect_netb_name_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   759→\n   760→{/* Handle the NAME RECOGNIZED command */\n   761→\tuint8_t local_session_number = tvb_get_uint8( tvb, offset + NB_DATA2);\n   762→\n   763→\tswitch (local_session_number) {\n   764→\n   765→\tcase 0x00:\n   766→\t\tproto_tree_add_uint_format_value( tree, hf_netb_state_of_name, tvb, offset + NB_DATA2, 1,\n   767→\t\t    local_session_number, "No LISTEN pending, or FIND.NAME response");\n   768→\t\tbreak;\n   769→\n   770→\tcase 0xFF:\n   771→\t\tproto_tree_add_uint_format_value( tree, hf_netb_state_of_name, tvb, offset + NB_DATA2, 1,\n   772→\t\t    local_session_number, "LISTEN pending, but insufficient resources to establish session");\n   773→\t\tbreak;\n   774→\n   775→\tdefault:\n   776→\t\tproto_tree_add_item( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1, ENC_LITTLE_ENDIAN);\n   777→\t\tbreak;\n   778→\t}\n   779→\tnb_call_name_type( tvb, offset, tree);\n   780→\tnb_xmit_corrl( tvb, offset, tree);\n   781→\tif (local_session_number != 0x00 && local_session_number != 0xFF)\n   782→\t\tnb_resp_corrl(tvb, offset, tree);\n   783→\tnetbios_add_name("Receiver\'s Name", tvb, offset + NB_RECVER_NAME, tree);\n   784→\tif (local_session_number != 0x00 && local_session_number != 0xFF) {\n   785→\t\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME,\n   786→\t\t    tree);\n   787→\t}\n   788→\n   789→\treturn 0;\n   790→}\n   791→\n   792→\n   793→static uint32_t\n   794→dissect_netb_status_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   795→\n   796→{/* Handle the STATUS RESPONSE command */\n   797→\tuint8_t\t    status_response = tvb_get_uint8( tvb, offset + NB_DATA1);\n   798→\tproto_item *td2;\n   799→\tproto_tree *data2_tree;\n   800→\n   801→\tnb_call_name_type( tvb, offset, tree);\n   802→\tif (status_response == 0) {\n   803→\t\tproto_tree_add_uint_format_value(tree, hf_netb_status_response, tvb, offset + NB_DATA1, 1,\n   804→\t\t    status_response, "NetBIOS 1.x or 2.0");\n   805→\t} else {\n   806→\t\tproto_tree_add_uint_format_value(tree, hf_netb_status_response, tvb, offset + NB_DATA1, 1,\n   807→\t\t    status_response, "NetBIOS 2.1, %u names sent so far",\n   808→\t\t    status_response);\n   809→\t}\n   810→\n   811→\ttd2 = proto_tree_add_item(tree, hf_netb_data2, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   812→\tdata2_tree = proto_item_add_subtree(td2, ett_netb_status);\n   813→\tproto_tree_add_item(data2_tree, hf_netb_data2_frame, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   814→\tproto_tree_add_item(data2_tree, hf_netb_data2_user, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   815→\tproto_tree_add_item(data2_tree, hf_netb_data2_status, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\n   816→\n   817→\tnb_xmit_corrl( tvb, offset, tree);\n   818→\tnetbios_add_name("Receiver\'s Name", tvb, offset + NB_RECVER_NAME, tree);\n   819→\tnetbios_add_name("Sender\'s Name", tvb, offset + NB_SENDER_NAME,\n   820→\t    tree);\n   821→\n   822→\treturn 0;\n   823→}\n   824→\n   825→\n   826→static uint32_t\n   827→dissect_netb_data_ack( tvbuff_t* tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   828→\n   829→{/* Handle the DATA ACK command */\n   830→\n   831→\tnb_xmit_corrl( tvb, offset, tree);\n   832→\tnb_remote_session( tvb, offset, tree);\n   833→\tnb_local_session( tvb, offset, tree);\n   834→\n   835→\treturn 0;\n   836→}\n   837→\n   838→\n   839→static uint32_t\n   840→dissect_netb_data_first_middle( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   841→\n   842→{/* Handle the DATA FIRST MIDDLE command */\n   843→\n   844→\tuint8_t remote_session, local_session;\n   845→\n   846→\t/*\n   847→\t * This is the first frame, or the middle frame, of a fragmented\n   848→\t * packet.\n   849→\t *\n   850→\t * XXX - there are no sequence numbers, so we have to assume\n   851→\t * that fragments arrive in order with no duplicates.\n   852→\t * In fact, 802.2 LLC is supposed to handle that, so we\n   853→\t * might have to have the LLC dissector do so (but the TCP\n   854→\t * dissector doesn\'t currently handle out-of-order or duplicate\n   855→\t * data, either).\n   856→\t */\n   857→\n   858→\tnetbios_data_first_middle_flags( tvb, tree, offset + NB_FLAGS);\n   859→\n   860→\tnb_resync_indicator( tvb, offset, tree, "DATA FIRST MIDDLE");\n   861→\tnb_xmit_corrl( tvb, offset, tree);\n   862→\tnb_resp_corrl( tvb, offset, tree);\n   863→\tremote_session = nb_remote_session( tvb, offset, tree);\n   864→\tlocal_session = nb_local_session( tvb, offset, tree);\n   865→\n   866→\t/*\n   867→\t * Return a combination of the remote and local session numbers,\n   868→\t * for use when reassembling.\n   869→\t */\n   870→\treturn (remote_session << 8) + local_session;\n   871→}\n   872→\n   873→\n   874→static uint32_t\n   875→dissect_netb_data_only_last( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   876→\n   877→{/* Handle the DATA ONLY LAST command */\n   878→\n   879→\tuint8_t remote_session, local_session;\n   880→\n   881→\t/*\n   882→\t * This is a complete packet, or the last frame of a fragmented\n   883→\t * packet.\n   884→\t */\n   885→\n   886→\tnetbios_data_only_flags( tvb, tree, offset + NB_FLAGS);\n   887→\n   888→\tnb_resync_indicator( tvb, offset, tree, "DATA ONLY LAST");\n   889→\tnb_xmit_corrl( tvb, offset, tree);\n   890→\tnb_resp_corrl( tvb, offset, tree);\n   891→\tremote_session = nb_remote_session( tvb, offset, tree);\n   892→\tlocal_session = nb_local_session( tvb, offset, tree);\n   893→\n   894→\t/*\n   895→\t * Return a combination of the remote and local session numbers,\n   896→\t * for use when reassembling.\n   897→\t */\n   898→\treturn (remote_session << 8) + local_session;\n   899→}\n   900→\n   901→\n   902→static uint32_t\n   903→dissect_netb_session_confirm( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   904→\n   905→{/* Handle the SESSION CONFIRM command */\n   906→\n   907→\tnetbios_add_ses_confirm_flags( tvb, tree, offset + NB_FLAGS);\n   908→\n   909→\tnb_data2( hf_netb_max_data_recv_size, tvb, offset, tree);\n   910→\tnb_xmit_corrl( tvb, offset, tree);\n   911→\tnb_resp_corrl( tvb, offset, tree);\n   912→\tnb_remote_session( tvb, offset, tree);\n   913→\tnb_local_session( tvb, offset, tree);\n   914→\n   915→\treturn 0;\n   916→}\n   917→\n   918→\n   919→static uint32_t\n   920→dissect_netb_session_end( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   921→\n   922→{/* Handle the SESSION END command */\n   923→\n   924→\tnb_data2( hf_netb_termination_indicator, tvb, offset, tree);\n   925→\tnb_remote_session( tvb, offset, tree);\n   926→\tnb_local_session( tvb, offset, tree);\n   927→\n   928→\treturn 0;\n   929→}\n   930→\n   931→\n   932→static uint32_t\n   933→dissect_netb_session_init( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   934→\n   935→{/* Handle the SESSION INITIALIZE command */\n   936→\n   937→\tnetbios_add_session_init_flags( tvb, tree, offset + NB_FLAGS);\n   938→\n   939→\tnb_data2( hf_netb_max_data_recv_size, tvb, offset, tree);\n   940→\tnb_resp_corrl( tvb, offset, tree);\n   941→\tnb_xmit_corrl( tvb, offset, tree);\n   942→\tnb_remote_session( tvb, offset, tree);\n   943→\tnb_local_session( tvb, offset, tree);\n   944→\n   945→\treturn 0;\n   946→}\n   947→\n   948→static uint32_t\n   949→dissect_netb_no_receive( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   950→\n   951→{/* Handle the NO RECEIVE command */\n   952→\n   953→\tnetbios_no_receive_flags( tvb, tree, offset + NB_FLAGS);\n   954→\n   955→\tnb_data2( hf_netb_num_data_bytes_accepted, tvb, offset, tree);\n   956→\tnb_remote_session( tvb, offset, tree);\n   957→\tnb_local_session( tvb, offset, tree);\n   958→\n   959→\treturn 0;\n   960→}\n   961→\n   962→\n   963→static uint32_t\n   964→dissect_netb_receive_outstanding( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   965→\n   966→{/* Handle the RECEIVE OUTSTANDING command */\n   967→\n   968→\tnb_data2( hf_netb_num_data_bytes_accepted, tvb, offset, tree);\n   969→\tnb_remote_session( tvb, offset, tree);\n   970→\tnb_local_session( tvb, offset, tree);\n   971→\n   972→\treturn 0;\n   973→}\n   974→\n   975→\n   976→static uint32_t\n   977→dissect_netb_receive_continue( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   978→\n   979→{/* Handle the RECEIVE CONTINUE command */\n   980→\n   981→\tnb_xmit_corrl( tvb, offset, tree);\n   982→\tnb_remote_session( tvb, offset, tree);\n   983→\tnb_local_session( tvb, offset, tree);\n   984→\n   985→\treturn 0;\n   986→}\n   987→\n   988→\n   989→static uint32_t\n   990→dissect_netb_session_alive( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\n   991→\n   992→{/* Handle the SESSION ALIVE command */\n   993→\n   994→\t/*\n   995→\t * XXX - all the fields are claimed to be "Reserved", but\n   996→\t * the session numbers appear to be non-zero in at least\n   997→\t * one capture, and they do appear to match session numbers\n   998→\t * in other messages, and I\'d expect that you had to identify\n   999→\t * sessions in this message in any case.\n  1000→\t *\n  1001→\t * We show only those fields.\n  1002→\t */\n  1003→\tnb_remote_session( tvb, offset, tree);\n  1004→\tnb_local_session( tvb, offset, tree);\n  1005→\n  1006→\treturn 0;\n  1007→}\n  1008→\n  1009→\n  1010→/************************************************************************/\n  1011→/*\t\t\t\t\t\t\t\t\t*/\n  1012→/*  The table routines called by the top level to handle commands  \t*/\n  1013→/*\t\t\t\t\t\t\t\t\t*/\n  1014→/************************************************************************/\n  1015→\n  1016→static uint32_t (*const dissect_netb[])(tvbuff_t *, packet_info *, int, proto_tree *) = {\n  1017→\n  1018→\tdissect_netb_add_group_name,\t  /* Add Group Name\t 0x00 */\n  1019→\tdissect_netb_add_name,\t\t  /* Add Name\t\t 0x01 */\n  1020→\tdissect_netb_name_in_conflict,\t  /* Name In Conflict\t 0x02 */\n  1021→\tdissect_netb_status_query,\t  /* Status Query\t 0x03 */\n  1022→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x04 */\n  1023→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x05 */\n  1024→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x06 */\n  1025→\tdissect_netb_terminate_trace,\t  /* Terminate Trace\t 0x07 */\n  1026→\tdissect_netb_datagram,\t\t  /* Datagram\t\t 0x08 */\n  1027→\tdissect_netb_datagram_bcast,\t  /* Datagram Broadcast\t 0x09 */\n  1028→\tdissect_netb_name_query,\t  /* Name Query\t\t 0x0A */\n  1029→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x0B */\n  1030→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x0C */\n  1031→\tdissect_netb_add_name_resp,\t  /* Add Name Response\t 0x0D */\n  1032→\tdissect_netb_name_resp,\t\t  /* Name Recognized\t 0x0E */\n  1033→\tdissect_netb_status_resp,\t  /* Status Response\t 0x0F */\n  1034→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x10 */\n  1035→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x11 */\n  1036→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x12 */\n  1037→\tdissect_netb_terminate_trace,\t  /* Terminate Trace\t 0x13 */\n  1038→\tdissect_netb_data_ack,\t\t  /* Data Ack\t\t 0x14 */\n  1039→\tdissect_netb_data_first_middle,\t  /* Data First Middle\t 0x15 */\n  1040→\tdissect_netb_data_only_last,\t  /* Data Only Last\t 0x16 */\n  1041→\tdissect_netb_session_confirm,\t  /* Session Confirm\t 0x17 */\n  1042→\tdissect_netb_session_end,\t  /* Session End\t 0x18 */\n  1043→\tdissect_netb_session_init,\t  /* Session Initialize\t 0x19 */\n  1044→\tdissect_netb_no_receive,\t  /* No Receive\t\t 0x1A */\n  1045→\tdissect_netb_receive_outstanding, /* Receive Outstanding 0x1B */\n  1046→\tdissect_netb_receive_continue,\t  /* Receive Continue\t 0x1C */\n  1047→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x1D */\n  1048→\tdissect_netb_unknown,\t\t  /* unknown\t\t 0x1E */\n  1049→\tdissect_netb_session_alive,\t  /* Session Alive\t 0x1f */\n  1050→\tdissect_netb_unknown,\n  1051→};\n  1052→\n  1053→static heur_dissector_list_t netbios_heur_subdissector_list;\n  1054→\n  1055→static void\n  1056→dissect_netbios_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n  1057→{\n  1058→\theur_dtbl_entry_t *hdtbl_entry;\n  1059→\n  1060→\t/*\n  1061→\t * Try the heuristic dissectors for NetBIOS; if none of them\n  1062→\t * accept the packet, dissect it as data.\n  1063→\t */\n  1064→\tif (!dissector_try_heuristic(netbios_heur_subdissector_list,\n  1065→\t\t\t\t    tvb, pinfo, tree, &hdtbl_entry, NULL))\n  1066→\t\tcall_data_dissector(tvb, pinfo, tree);\n  1067→}\n  1068→\n  1069→static int\n  1070→dissect_netbios(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n  1071→{\n  1072→\tproto_tree    *netb_tree = NULL;\n  1073→\tproto_item    *ti;\n  1074→\tuint16_t\t       hdr_len, command;\n  1075→\tconst char    *command_name;\n  1076→\tchar \t       name[(NETBIOS_NAME_LEN - 1)*4 + 1];\n  1077→\tint\t       name_type;\n  1078→\tuint16_t\t       session_id;\n  1079→\tbool           save_fragmented;\n  1080→\tint\t       len;\n  1081→\tfragment_head *fd_head;\n  1082→\ttvbuff_t      *next_tvb;\n  1083→\n  1084→\tint offset = 0;\n  1085→\n  1086→\t\t\t\t\t/* load the display labels \t*/\n  1087→\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, "NetBIOS");\n  1088→\n  1089→\n  1090→/* Find NetBIOS marker EFFF, this is done because I have seen an extra LLC */\n  1091→/* byte on our network. This only checks for one extra LLC byte. */\n  1092→\n  1093→\tif ( 0xefff != tvb_get_letohs(tvb, 2)){\n  1094→\t\t++offset;\n  1095→\t\tif ( 0xefff != tvb_get_letohs(tvb, 3)){\n  1096→\n  1097→\t\t\t/* print bad packet */\n  1098→\t\t\tcol_set_str( pinfo->cinfo, COL_INFO, "Bad packet, no 0xEFFF marker");\n  1099→\n  1100→\t\t\treturn 3;\t\t/* this is an unknown packet, no marker */\n  1101→\t\t}\n  1102→\t}\n  1103→\n  1104→\n  1105→\thdr_len = tvb_get_letohs(tvb, offset + NB_LENGTH);\n  1106→\tcommand = tvb_get_uint8( tvb, offset + NB_COMMAND);\n  1107→\t\t\t\t\t/* limit command so no table overflows */\n  1108→\tcommand = MIN(command, array_length(dissect_netb));\n  1109→\n  1110→\t\t/* print command name */\n  1111→\tcommand_name = val_to_str_ext(command, &cmd_vals_ext, "Unknown (0x%02x)");\n  1112→\tswitch ( command ) {\n  1113→\t\tcase NB_NAME_QUERY:\n  1114→\t\t\tname_type = get_netbios_name( tvb, offset + 12, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\n  1115→\t\t\tcol_add_fstr( pinfo->cinfo, COL_INFO, "%s for %s<%02x>", command_name, name, name_type);\n  1116→\t\t\tbreak;\n  1117→\n  1118→\t\tcase NB_NAME_RESP:\n  1119→\t\tcase NB_ADD_NAME:\n  1120→\t\tcase NB_ADD_GROUP:\n  1121→\t\t\tname_type = get_netbios_name( tvb, offset + 28, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\n  1122→\t\t\tcol_add_fstr( pinfo->cinfo, COL_INFO, "%s - %s<%02x>", command_name, name, name_type);\n  1123→\t\tbreak;\n  1124→\n  1125→\t\tdefault:\n  1126→\t\t\tcol_add_str( pinfo->cinfo, COL_INFO, command_name);\n  1127→\t\t\tbreak;\n  1128→\t}\n  1129→\n  1130→\tif ( tree) {\n  1131→\t\tti = proto_tree_add_item(tree, proto_netbios, tvb, 0, hdr_len, ENC_NA);\n  1132→\t\tnetb_tree = proto_item_add_subtree(ti, ett_netb);\n  1133→\n  1134→\t\tproto_tree_add_uint_format_value(netb_tree, hf_netb_hdr_len, tvb, offset, 2, hdr_len,\n  1135→\t\t\t"%d bytes", hdr_len);\n  1136→\n  1137→\t\tproto_tree_add_uint_format_value(netb_tree, hf_netb_delimiter, tvb, offset + 2, 2,\n  1138→\t\t\ttvb_get_letohs(tvb, offset + 2), "EFFF (NetBIOS)");\n  1139→\n  1140→\t\tproto_tree_add_uint(netb_tree, hf_netb_cmd, tvb, offset + NB_COMMAND, 1, command);\n  1141→\t}\n  1142→\n  1143→\t\t\t\t/* branch to handle commands */\n  1144→\tsession_id = (dissect_netb[ command])( tvb, pinfo, offset, netb_tree);\n  1145→\n  1146→\toffset += hdr_len;\t\t\t/* move past header */\n  1147→\n  1148→\tsave_fragmented = pinfo->fragmented;\n  1149→\n  1150→\t/*\n  1151→\t * Process user data in frames that have it.\n  1152→\t */\n  1153→\tswitch (command) {\n  1154→\n  1155→\tcase NB_DATAGRAM:\n  1156→\tcase NB_DATAGRAM_BCAST:\n  1157→\t\t/*\n  1158→\t\t * No fragmentation here.\n  1159→\t\t */\n  1160→\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n  1161→\t\tdissect_netbios_payload(next_tvb, pinfo, tree);\n  1162→\t\tbreak;\n  1163→\n  1164→\tcase NB_DATA_FIRST_MIDDLE:\n  1165→\tcase NB_DATA_ONLY_LAST:\n  1166→\t\t/*\n  1167→\t\t * Possibly fragmented.\n  1168→\t\t */\n  1169→\t\tlen = tvb_reported_length_remaining(tvb, offset);\n  1170→\t\tif (netbios_defragment &&\n  1171→\t\t    tvb_bytes_exist(tvb, offset, len)) {\n  1172→\t\t\tfd_head = fragment_add_seq_next(&netbios_reassembly_table,\n  1173→\t\t\t    tvb, offset,\n  1174→\t\t\t    pinfo, session_id, NULL,\n  1175→\t\t\t    len, command == NB_DATA_FIRST_MIDDLE);\n  1176→\t\t\tif (fd_head != NULL) {\n  1177→\t\t\t\tif (fd_head->next != NULL) {\n  1178→\t\t\t\t\tnext_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\n  1179→\t\t\t\t\tadd_new_data_source(pinfo,\n  1180→\t\t\t\t\t    next_tvb,\n  1181→\t\t\t\t\t    "Reassembled NetBIOS");\n  1182→\t\t\t\t\t/* Show all fragments. */\n  1183→\t\t\t\t\tif (tree) {\n  1184→\t\t\t\t\t\tproto_item *frag_tree_item;\n  1185→\n  1186→\t\t\t\t\t\tshow_fragment_seq_tree(fd_head,\n  1187→\t\t\t\t\t\t    &netbios_frag_items,\n  1188→\t\t\t\t\t\t    netb_tree, pinfo,\n  1189→\t\t\t\t\t\t    next_tvb, &frag_tree_item);\n  1190→\t\t\t\t\t}\n  1191→\t\t\t\t} else {\n  1192→\t\t\t\t\tnext_tvb = tvb_new_subset_remaining(tvb,\n  1193→\t\t\t\t\t    offset);\n  1194→\t\t\t\t}\n  1195→\t\t\t} else {\n  1196→\t\t\t\tnext_tvb = NULL;\n  1197→\t\t\t}\n  1198→\t\t} else {\n  1199→\t\t\t/*\n  1200→\t\t\t * Dissect this, regardless of whether\n  1201→\t\t\t * it\'s NB_DATA_FIRST_MIDDLE or\n  1202→\t\t\t * NB_DATA_ONLY_LAST.\n  1203→\t\t\t *\n  1204→\t\t\t * XXX - it\'d be nice to show\n  1205→\t\t\t * NB_DATA_FIRST_MIDDLE as a fragment\n  1206→\t\t\t * if it\'s not the first fragment (i.e.,\n  1207→\t\t\t * MIDDLE rather than FIRST), and show\n  1208→\t\t\t * NB_DATA_ONLY_LAST as a fragment if\n  1209→\t\t\t * it\'s part of a fragmented datagram\n  1210→\t\t\t * (i.e, LAST rather than ONLY), but\n  1211→\t\t\t * we\'d have to do reassembly to\n  1212→\t\t\t * be able to determine that.\n  1213→\t\t\t */\n  1214→\t\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n  1215→\t\t}\n  1216→\t\tif (next_tvb != NULL)\n  1217→\t\t\tdissect_netbios_payload(next_tvb, pinfo, tree);\n  1218→\t\telse {\n  1219→\t\t\tnext_tvb = tvb_new_subset_remaining (tvb, offset);\n  1220→\t\t\tcall_data_dissector(next_tvb, pinfo, tree);\n  1221→\t\t}\n  1222→\t\tbreak;\n  1223→\t}\n  1224→\tpinfo->fragmented = save_fragmented;\n  1225→\n  1226→\treturn tvb_captured_length(tvb);\n  1227→}\n  1228→\n  1229→void\n  1230→proto_register_netbios(void)\n  1231→{\n  1232→\tstatic int *ett[] = {\n  1233→\t\t&ett_netb,\n  1234→\t\t&ett_netb_name,\n  1235→\t\t&ett_netb_flags,\n  1236→\t\t&ett_netb_status,\n  1237→\t\t&ett_netb_fragments,\n  1238→\t\t&ett_netb_fragment,\n  1239→\t};\n  1240→\n  1241→\tstatic hf_register_info hf_netb[] = {\n  1242→\t\t{ &hf_netb_cmd,\n  1243→\t\t  { "Command", "netbios.command", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\n  1244→\t\t    &cmd_vals_ext, 0x0, NULL, HFILL }},\n  1245→\n  1246→\t\t{ &hf_netb_hdr_len,\n  1247→\t\t  { "Length", "netbios.hdr_len", FT_UINT16, BASE_DEC,\n  1248→\t\t    NULL, 0x0, "Header Length", HFILL }},\n  1249→\n  1250→\t\t{ &hf_netb_delimiter,\n  1251→\t\t  { "Delimiter", "netbios.delimiter", FT_UINT16, BASE_HEX,\n  1252→\t\t    NULL, 0x0, NULL, HFILL }},\n  1253→\n  1254→\t\t{ &hf_netb_xmit_corrl,\n  1255→\t\t  { "Transmit Correlator", "netbios.xmit_corrl", FT_UINT16, BASE_HEX,\n  1256→\t\t    NULL, 0x0, NULL, HFILL }},\n  1257→\n  1258→\t\t{ &hf_netb_resp_corrl,\n  1259→\t\t  { "Response Correlator", "netbios.resp_corrl", FT_UINT16, BASE_HEX,\n  1260→\t\t    NULL, 0x0, NULL, HFILL }},\n  1261→\n  1262→\t\t{ &hf_netb_call_name_type,\n  1263→\t\t  { "Caller\'s Name Type", "netbios.call_name_type", FT_UINT8, BASE_HEX,\n  1264→\t\t    VALS(name_types), 0x0, NULL, HFILL }},\n  1265→\n  1266→\t\t{ &hf_netb_nb_name_type,\n  1267→\t\t  { "NetBIOS Name Type", "netbios.nb_name_type", FT_UINT8, BASE_HEX |BASE_EXT_STRING,\n  1268→\t\t    &nb_name_type_vals_ext, 0x0, NULL, HFILL }},\n  1269→\n  1270→\t\t{ &hf_netb_nb_name,\n  1271→\t\t  { "NetBIOS Name", "netbios.nb_name", FT_STRING, BASE_NONE,\n  1272→\t\t    NULL, 0x0, NULL, HFILL }},\n  1273→\n  1274→\t\t{ &hf_netb_version,\n  1275→\t\t  { "NetBIOS Version", "netbios.version", FT_BOOLEAN,  8,\n  1276→\t\t    TFS( &netb_version_str), 0x01, NULL, HFILL }},\n  1277→\n  1278→\t\t{ &hf_netbios_no_receive_flags,\n  1279→\t\t  { "Flags", "netbios.no_receive_flags", FT_UINT8, BASE_HEX, NULL, 0x0,\n  1280→\t\t    NULL, HFILL }},\n  1281→\n  1282→\t\t{ &hf_netbios_no_receive_flags_send_no_ack,\n  1283→\t\t  { "SEND.NO.ACK data received", "netbios.no_receive_flags.send_no_ack", FT_BOOLEAN,  8,\n  1284→\t\t    TFS( &tfs_no_yes), 0x02, NULL, HFILL }},\n  1285→\n  1286→\t\t{ &hf_netb_largest_frame,\n  1287→\t\t  { "Largest Frame", "netbios.largest_frame", FT_UINT8, BASE_DEC,\n  1288→\t\t    VALS(max_frame_size_vals), 0x0E, NULL, HFILL }},\n  1289→\n  1290→\t\t{ &hf_netb_status_buffer_len,\n  1291→\t\t  { "Length of status buffer", "netbios.status_buffer_len", FT_UINT16, BASE_DEC,\n  1292→\t\t    NULL, 0x0, NULL, HFILL }},\n  1293→\n  1294→\t\t{ &hf_netb_status,\n  1295→\t\t  { "Status", "netbios.status", FT_UINT8, BASE_DEC,\n  1296→\t\t    VALS(status_vals), 0x0, NULL, HFILL }},\n  1297→\n  1298→\t\t{ &hf_netb_name_type,\n  1299→\t\t  { "Name type", "netbios.name_type", FT_UINT16, BASE_DEC,\n  1300→\t\t    VALS(name_types), 0x0, NULL, HFILL }},\n  1301→\n  1302→\t\t{ &hf_netb_max_data_recv_size,\n  1303→\t\t  { "Maximum data receive size", "netbios.max_data_recv_size", FT_UINT16, BASE_DEC,\n  1304→\t\t    NULL, 0x0, NULL, HFILL }},\n  1305→\n  1306→\t\t{ &hf_netb_termination_indicator,\n  1307→\t\t  { "Termination indicator", "netbios.termination_indicator", FT_UINT16, BASE_HEX,\n  1308→\t\t    VALS(termination_indicator_vals), 0x0, NULL, HFILL }},\n  1309→\n  1310→\t\t{ &hf_netb_num_data_bytes_accepted,\n  1311→\t\t  { "Number of data bytes accepted", "netbios.num_data_bytes_accepted", FT_UINT16, BASE_DEC,\n  1312→\t\t    NULL, 0x0, NULL, HFILL }},\n  1313→\n  1314→\t\t{ &hf_netb_local_ses_no,\n  1315→\t\t  { "Local Session No.", "netbios.local_session", FT_UINT8, BASE_HEX,\n  1316→\t\t    NULL, 0x0, NULL, HFILL }},\n  1317→\n  1318→\t\t{ &hf_netb_remote_ses_no,\n  1319→\t\t  { "Remote Session No.", "netbios.remote_session", FT_UINT8, BASE_HEX,\n  1320→\t\t    NULL, 0x0, NULL, HFILL }},\n  1321→\n  1322→\t\t{ &hf_netb_flags,\n  1323→\t\t  { "Flags", "netbios.flags", FT_UINT8, BASE_HEX,\n  1324→\t\t    NULL, 0x0, NULL, HFILL }},\n  1325→\n  1326→\t\t{ &hf_netb_flags_send_no_ack,\n  1327→\t\t  { "Handle SEND.NO.ACK", "netbios.flags.send_no_ack", FT_BOOLEAN,  8,\n  1328→\t\t    TFS( &tfs_yes_no), 0x80, NULL, HFILL }},\n  1329→\n  1330→\t\t{ &hf_netb_flags_ack,\n  1331→\t\t  { "Acknowledge", "netbios.flags.ack", FT_BOOLEAN, 8,\n  1332→\t\t    TFS( &tfs_set_notset), 0x08, NULL, HFILL }},\n  1333→\n  1334→\t\t{ &hf_netb_flags_ack_with_data,\n  1335→\t\t  { "Acknowledge with data", "netbios.flags.ack_with_data", FT_BOOLEAN, 8,\n  1336→\t\t    TFS( &tfs_allowed_not_allowed), 0x04, NULL, HFILL }},\n  1337→\n  1338→\t\t{ &hf_netb_flags_ack_expected,\n  1339→\t\t  { "Acknowledge expected", "netbios.flags.ack_expected", FT_BOOLEAN,  8,\n  1340→\t\t    TFS( &tfs_yes_no), 0x02, NULL, HFILL }},\n  1341→\n  1342→\t\t{ &hf_netb_flags_recv_cont_req,\n  1343→\t\t  { "RECEIVE_CONTINUE requested", "netbios.flags.recv_cont_req", FT_BOOLEAN,  8,\n  1344→\t\t    TFS( &tfs_yes_no), 0x01, NULL, HFILL }},\n  1345→\n  1346→\t\t{ &hf_netb_data2,\n  1347→\t\t  { "DATA2 value", "netbios.data2", FT_UINT16, BASE_HEX,\n  1348→\t\t    NULL, 0x0, NULL, HFILL }},\n  1349→\n  1350→\t\t{ &hf_netb_data2_frame,\n  1351→\t\t  { "Data length exceeds maximum frame size", "netbios.data2.frame", FT_BOOLEAN, 16,\n  1352→\t\t    TFS(&tfs_yes_no), 0x8000, NULL, HFILL }},\n  1353→\n  1354→\t\t{ &hf_netb_data2_user,\n  1355→\t\t  { "Data length exceeds user\'s buffer", "netbios.data2.user", FT_BOOLEAN, 16,\n  1356→\t\t    TFS(&tfs_yes_no), 0x4000, NULL, HFILL }},\n  1357→\n  1358→\t\t{ &hf_netb_data2_status,\n  1359→\t\t  { "Status data length", "netbios.data2.status", FT_UINT16, BASE_DEC,\n  1360→\t\t    NULL, 0x3FFF, NULL, HFILL }},\n  1361→\n  1362→\t\t{ &hf_netb_datagram_mac,\n  1363→\t\t  { "Sender\'s MAC Address", "netbios.datagram_mac", FT_ETHER, BASE_NONE,\n  1364→\t\t    NULL, 0x0, NULL, HFILL }},\n  1365→\n  1366→\t\t{ &hf_netb_datagram_bcast_mac,\n  1367→\t\t  { "Sender\'s Node Address",\t"netbios.datagram_bcast_mac", FT_ETHER, BASE_NONE,\n  1368→\t\t    NULL, 0x0, NULL, HFILL }},\n  1369→\n  1370→\t\t{ &hf_netb_resync_indicator,\n  1371→\t\t  { "Re-sync indicator", "netbios.resync_indicator", FT_UINT16, BASE_HEX,\n  1372→\t\t    NULL, 0x0, NULL, HFILL }},\n  1373→\n  1374→\t\t{ &hf_netb_status_request,\n  1375→\t\t  { "Status request", "netbios.status_request", FT_UINT8, BASE_DEC,\n  1376→\t\t    NULL, 0x0, NULL, HFILL }},\n  1377→\n  1378→\t\t{ &hf_netb_local_session_no,\n  1379→\t\t  { "Local Session No.", "netbios.local_session_no", FT_UINT8, BASE_HEX,\n  1380→\t\t    NULL, 0x0, NULL, HFILL }},\n  1381→\n  1382→\t\t{ &hf_netb_state_of_name,\n  1383→\t\t  { "State of name", "netbios.state_of_name", FT_UINT8, BASE_HEX,\n  1384→\t\t    NULL, 0x0, NULL, HFILL }},\n  1385→\n  1386→\t\t{ &hf_netb_status_response,\n  1387→\t\t  { "Status response", "netbios.status_response", FT_UINT8, BASE_DEC,\n  1388→\t\t    NULL, 0x0, NULL, HFILL }},\n  1389→\n  1390→\t\t{ &hf_netb_fragment_overlap,\n  1391→\t\t  { "Fragment overlap",\t"netbios.fragment.overlap", FT_BOOLEAN, BASE_NONE,\n  1392→\t\t    NULL, 0x0, "Fragment overlaps with other fragments", HFILL }},\n  1393→\n  1394→\t\t{ &hf_netb_fragment_overlap_conflict,\n  1395→\t\t  { "Conflicting data in fragment overlap", "netbios.fragment.overlap.conflict",\n  1396→\t\t    FT_BOOLEAN, BASE_NONE,\n  1397→\t\t    NULL, 0x0, "Overlapping fragments contained conflicting data", HFILL }},\n  1398→\n  1399→\t\t{ &hf_netb_fragment_multiple_tails,\n  1400→\t\t  { "Multiple tail fragments found", "netbios.fragment.multipletails",\n  1401→\t\t    FT_BOOLEAN, BASE_NONE,\n  1402→\t\t    NULL, 0x0, "Several tails were found when defragmenting the packet", HFILL }},\n  1403→\n  1404→\t\t{ &hf_netb_fragment_too_long_fragment,\n  1405→\t\t  { "Fragment too long",\t"netbios.fragment.toolongfragment", FT_BOOLEAN, BASE_NONE,\n  1406→\t\t    NULL, 0x0, "Fragment contained data past end of packet", HFILL }},\n  1407→\n  1408→\t\t{ &hf_netb_fragment_error,\n  1409→\t\t  { "Defragmentation error",\t"netbios.fragment.error", FT_FRAMENUM, BASE_NONE,\n  1410→\t\t    NULL, 0x0, "Defragmentation error due to illegal fragments", HFILL }},\n  1411→\n  1412→\t\t{ &hf_netb_fragment_count,\n  1413→\t\t  { "Fragment count",\t"netbios.fragment.count", FT_UINT32, BASE_DEC,\n  1414→\t\t    NULL, 0x0, NULL, HFILL }},\n  1415→\n  1416→\t\t{ &hf_netb_fragment,\n  1417→\t\t  { "NetBIOS Fragment",\t\t"netbios.fragment", FT_FRAMENUM, BASE_NONE,\n  1418→\t\t    NULL, 0x0, NULL, HFILL }},\n  1419→\n  1420→\t\t{ &hf_netb_fragments,\n  1421→\t\t  { "NetBIOS Fragments",\t"netbios.fragments", FT_NONE, BASE_NONE,\n  1422→\t\t    NULL, 0x0, NULL, HFILL }},\n  1423→\n  1424→\t\t{ &hf_netb_reassembled_length,\n  1425→\t\t  {"Reassembled NetBIOS length",\t"netbios.reassembled.length", FT_UINT32, BASE_DEC,\n  1426→\t\t   NULL, 0x0, "The total length of the reassembled payload", HFILL }},\n  1427→\t};\n  1428→\n  1429→\tstatic ei_register_info ei[] = {\n  1430→\t\t{ &ei_netb_unknown_command_data, { "netbios.unknown_command_data", PI_UNDECODED, PI_WARN, "Unknown NetBIOS command data", EXPFILL }},\n  1431→\t};\n  1432→\n  1433→\tmodule_t *netbios_module;\n  1434→\texpert_module_t* expert_netbios;\n  1435→\n  1436→\tproto_netbios = proto_register_protocol("NetBIOS", "NetBIOS", "netbios");\n  1437→\tproto_register_subtree_array(ett, array_length(ett));\n  1438→\tproto_register_field_array(proto_netbios, hf_netb, array_length(hf_netb));\n  1439→\texpert_netbios = expert_register_protocol(proto_netbios);\n  1440→\texpert_register_field_array(expert_netbios, ei, array_length(ei));\n  1441→\n  1442→\tnetbios_handle = register_dissector("netbios", dissect_netbios, proto_netbios);\n  1443→\tnetbios_cap_handle = register_capture_dissector("netbios", capture_netbios, proto_netbios);\n  1444→\n  1445→\tnetbios_heur_subdissector_list = register_heur_dissector_list_with_description("netbios", "NetBIOS payload", proto_netbios);\n  1446→\n  1447→\tnetbios_module = prefs_register_protocol(proto_netbios, NULL);\n  1448→\tprefs_register_bool_preference(netbios_module, "defragment",\n  1449→\t    "Reassemble fragmented NetBIOS messages spanning multiple frames",\n  1450→\t    "Whether the NetBIOS dissector should defragment messages spanning multiple frames",\n  1451→\t    &netbios_defragment);\n  1452→\n  1453→\treassembly_table_register(&netbios_reassembly_table,\n  1454→\t    &addresses_reassembly_table_functions);\n  1455→}\n  1456→\n  1457→void\n  1458→proto_reg_handoff_netbios(void)\n  1459→{\n  1460→\tdissector_add_uint("llc.dsap", SAP_NETBIOS, netbios_handle);\n  1461→\tcapture_dissector_add_uint("llc.dsap", SAP_NETBIOS, netbios_cap_handle);\n  1462→}\n  1463→\n  1464→\n  1465→/*\n  1466→ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n  1467→ *\n  1468→ * Local variables:\n  1469→ * c-basic-offset: 8\n  1470→ * tab-width: 8\n  1471→ * indent-tabs-mode: t\n  1472→ * End:\n  1473→ *\n  1474→ * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n  1475→ * :indentSize=8:tabSize=8:noTabs=false:\n  1476→ */\n  1477→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 8: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Now I understand the bug. Looking at the crash log and the code:\n\n1. The crash occurs at line 1144: `session_id = (dissect_netb[ command])( tvb, pinfo, offset, netb_tree);`\n2. The error says "global-buffer-overflow" on variable `dissect_netb` defined at line 1016 with size 264 bytes\n3. The `dissect_netb` array is defined at line 1016-1051 and has entries from 0x00 to 0x1f (plus one extra `dissect_netb_unknown` at the end), making it 33 entries total\n4. Each entry is a function pointer (8 bytes on 64-bit), so 33 * 8 = 264 bytes, which matches the crash info\n\nThe issue is in line 1108:\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\n\nThis limits `command` to be at most equal to `array_length(dissect_netb)` (which is 33), but it should be limiting it to `array_length(dissect_netb) - 1` (which is 32, i.e., the maximum valid index). When `command` equals `array_length(dissect_netb)`, the code accesses `dissect_netb[33]` which is one past the end of the array.\n\nThe fix should change:\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\nto:\n```c\ncommand = MIN(command, array_length(dissect_netb) - 1);\n```\n\nLet me apply this fix:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 9: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_011uw4RGoosNXzevekDpb19J', name='Edit', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-netbios.c', 'old_string': '\t\t\t\t/* limit command so no table overflows */\n\tcommand = MIN(command, array_length(dissect_netb));', 'new_string': '\t\t\t\t/* limit command so no table overflows */\n\tcommand = MIN(command, array_length(dissect_netb) - 1);'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 10: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_011uw4RGoosNXzevekDpb19J', content='The file /home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-netbios.c has been updated. Here\'s the result of running `cat -n` on a snippet of the edited file:\n  1103→\n  1104→\n  1105→\thdr_len = tvb_get_letohs(tvb, offset + NB_LENGTH);\n  1106→\tcommand = tvb_get_uint8( tvb, offset + NB_COMMAND);\n  1107→\t\t\t\t\t/* limit command so no table overflows */\n  1108→\tcommand = MIN(command, array_length(dissect_netb) - 1);\n  1109→\n  1110→\t\t/* print command name */\n  1111→\tcommand_name = val_to_str_ext(command, &cmd_vals_ext, "Unknown (0x%02x)");\n  1112→\tswitch ( command ) {', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 11: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="The fix has been applied. Here's a summary of the bug and the patch:\n\n## Bug Summary\n\n**AddressSanitizer: global-buffer-overflow** in `dissect_netbios()` at line 1144.\n\n### Root Cause\n\nThe `dissect_netb` array at line 1016 contains 33 function pointers (indices 0-32). The code at line 1108 was limiting the `command` value to prevent array overflow using:\n\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\n\nHowever, this allows `command` to be equal to `array_length(dissect_netb)` (33), which is **one past the last valid index** (32). When an attacker-controlled packet has a command byte value ≥ 33, the code would access `dissect_netb[33]`, causing a read of 8 bytes past the end of the global array.\n\n### Fix\n\nChanged the bounds check from:\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\nto:\n```c\ncommand = MIN(command, array_length(dissect_netb) - 1);\n```\n\nThis ensures `command` is clamped to the maximum valid index (32), preventing the out-of-bounds access. Invalid command values ≥ 33 will now be handled by `dissect_netb_unknown` (the last entry in the array at index 32).")], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 12: ResultMessage
================================================================================
ResultMessage(subtype='success', duration_ms=32200, duration_api_ms=45346, is_error=False, num_turns=5, session_id='c1fc151f-ee41-44f6-8d3e-e7a15225bc29', total_cost_usd=0.280097, usage={'input_tokens': 7, 'cache_creation_input_tokens': 27596, 'cache_read_input_tokens': 102216, 'output_tokens': 1154, 'server_tool_use': {'web_search_requests': 0, 'web_fetch_requests': 0}, 'service_tier': 'standard', 'cache_creation': {'ephemeral_1h_input_tokens': 0, 'ephemeral_5m_input_tokens': 27596}}, result="The fix has been applied. Here's a summary of the bug and the patch:\n\n## Bug Summary\n\n**AddressSanitizer: global-buffer-overflow** in `dissect_netbios()` at line 1144.\n\n### Root Cause\n\nThe `dissect_netb` array at line 1016 contains 33 function pointers (indices 0-32). The code at line 1108 was limiting the `command` value to prevent array overflow using:\n\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\n\nHowever, this allows `command` to be equal to `array_length(dissect_netb)` (33), which is **one past the last valid index** (32). When an attacker-controlled packet has a command byte value ≥ 33, the code would access `dissect_netb[33]`, causing a read of 8 bytes past the end of the global array.\n\n### Fix\n\nChanged the bounds check from:\n```c\ncommand = MIN(command, array_length(dissect_netb));\n```\nto:\n```c\ncommand = MIN(command, array_length(dissect_netb) - 1);\n```\n\nThis ensures `command` is clamped to the maximum valid index (32), preventing the out-of-bounds access. Invalid command values ≥ 33 will now be handled by `dissect_netb_unknown` (the last entry in the array at index 32).", structured_output=None)
