diff --git a/src/fmt.c b/src/fmt.c
index 8164e1ca..cc1ed56a 100644
--- a/src/fmt.c
+++ b/src/fmt.c
@@ -315,16 +315,28 @@ size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
         for (j = 0; minus && pr < w && j + pr < w; j++)
           n += scpy(out, param, &pad, 1);
       } else if (c == 'e' || c == 'E') {
-		  char tmp[8];
+          char tmp[40];
           double d = va_arg(*ap, double);
-          int64_t exponent = (int64_t)log10(my_fabs(d));
-          double mantissa = d / power(10, exponent);
-          k = mg_dtoa(tmp, 10, mantissa, 8, c == 'e');
-          n += scpy(out, param, tmp, k);
-          out(c, param);
-          n++;
-		  k = mg_lld(tmp, exponent, 1, 0);
-          n += scpy(out, param, tmp, k);
+          // Handle special cases: 0, NaN, Inf - delegate to mg_dtoa which handles them
+          if (d == 0.0 || xisnan(d) || xisinf(d)) {
+            k = mg_dtoa(tmp, sizeof(tmp), d, 6, true);
+            n += scpy(out, param, tmp, k);
+          } else {
+            double abs_d = my_fabs(d);
+            int64_t exponent = (int64_t)log10(abs_d);
+            // Adjust exponent for numbers < 1 to get proper mantissa
+            if (abs_d < 1.0) exponent--;
+            double mantissa = d / power(10, exponent);
+            // Ensure mantissa is in range [1, 10) or (-10, -1]
+            while (my_fabs(mantissa) >= 10.0) { mantissa /= 10.0; exponent++; }
+            while (my_fabs(mantissa) < 1.0 && mantissa != 0.0) { mantissa *= 10.0; exponent--; }
+            k = mg_dtoa(tmp, sizeof(tmp), mantissa, 6, true);
+            n += scpy(out, param, tmp, k);
+            out(c, param);
+            n++;
+            k = mg_lld(tmp, exponent, 1, 0);
+            n += scpy(out, param, tmp, k);
+          }
 	  } else if (c == '%') {
         out('%', param);
         n++;
