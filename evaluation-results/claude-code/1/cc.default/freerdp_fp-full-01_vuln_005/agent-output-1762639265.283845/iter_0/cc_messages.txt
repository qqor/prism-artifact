
================================================================================
Message 0: SystemMessage
================================================================================
SystemMessage(subtype='init', data={'type': 'system', 'subtype': 'init', 'cwd': '/home/user/aixcc/crete/.cache/official-afc-freerdp', 'session_id': 'bb99771a-92ae-4b92-9e47-16ce075647b9', 'tools': ['Task', 'Bash', 'Glob', 'Grep', 'ExitPlanMode', 'Read', 'Edit', 'Write', 'NotebookEdit', 'WebFetch', 'TodoWrite', 'WebSearch', 'BashOutput', 'KillShell', 'Skill', 'SlashCommand'], 'mcp_servers': [], 'model': 'claude-sonnet-4-5-20250929', 'permissionMode': 'bypassPermissions', 'slash_commands': ['compact', 'context', 'cost', 'init', 'pr-comments', 'release-notes', 'todos', 'review', 'security-review'], 'apiKeySource': 'ANTHROPIC_API_KEY', 'claude_code_version': '2.0.36', 'output_style': 'default', 'agents': ['general-purpose', 'statusline-setup', 'Explore', 'Plan'], 'skills': [], 'plugins': [], 'uuid': '7c2271c5-9a85-433c-a5dc-1b497f9eb894'})

================================================================================
Message 1: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="I'll analyze the crash log and create a patch to fix the AddressSanitizer SEGV bug.\n\nFrom the crash log, I can see:\n1. The crash occurs in `freerdp_is_valid_mcs_create_response` at `/src/FreeRDP/libfreerdp/core/freerdp.c:1458:16`\n2. It's a null-deref (null pointer dereference) bug\n3. The crash is triggered by a WRITE memory access to address 0x000000000700\n\nLet me first examine the source files to understand the issue.")], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 2: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_017ENwTCGg3KS1rLkLwayLrT', name='Read', input={'file_path': '/src/FreeRDP/libfreerdp/core/freerdp.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 3: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01P1822WoZA19RNRFvRdkDRK', name='Read', input={'file_path': '/src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 4: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_017ENwTCGg3KS1rLkLwayLrT', content='<tool_use_error>File does not exist.</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 5: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01P1822WoZA19RNRFvRdkDRK', content='<tool_use_error>File does not exist.</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 6: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Let me find the actual source directory structure:')], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 7: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01ENZHJDZtG6AVnohRVZSHw6', name='Bash', input={'command': 'find / -type f -name "freerdp.c" 2>/dev/null | head -20', 'description': 'Find freerdp.c file location', 'timeout': 30000})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 8: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01ENZHJDZtG6AVnohRVZSHw6', content='Command running in background with ID: 540b51', is_error=False)], parent_tool_use_id=None)

================================================================================
Message 9: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01THJk3J2L7YxiNSC4u9s6tT', name='BashOutput', input={'bash_id': '540b51'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 10: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01THJk3J2L7YxiNSC4u9s6tT', content='<status>running</status>\n\n<timestamp>2025-11-08T22:02:39.387Z</timestamp>', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 11: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01Bf1QTrRZJ4YD6tMttJi7p7', name='Bash', input={'command': 'pwd && ls -la', 'description': 'Check current directory'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 12: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01Bf1QTrRZJ4YD6tMttJi7p7', content='/home/user/aixcc/crete/.cache/official-afc-freerdp\ntotal 184\ndrwxrwxr-x 22 user user  4096 11월  9 07:01 .\ndrwxrwxr-x 29 user user  4096 10월 30 22:33 ..\ndrwxrwxr-x  3 user user  4096 11월  9 07:01 .aixcc\n-rw-rw-r--  1 user user 25713 11월  9 07:01 ChangeLog\ndrwxrwxr-x 34 user user  4096 11월  9 07:01 channels\ndrwxrwxr-x  3 user user  4096 10월 18 22:04 ci\n-rw-rw-r--  1 user user  3367 11월  9 07:01 .clang-format\n-rw-rw-r--  1 user user  6487 11월  9 07:01 .clang-tidy\ndrwxrwxr-x 11 user user  4096 11월  9 07:01 client\ndrwxrwxr-x  2 user user  4096 11월  9 07:01 cmake\n-rw-rw-r--  1 user user  3940 11월  9 07:01 CMakeCPack.cmake\n-rw-rw-r--  1 user user   345 11월  9 07:01 CMakeCPackOptions.cmake.in\n-rw-rw-r--  1 user user 18929 11월  9 07:01 CMakeLists.txt\ndrwxrwxr-x  3 user user  4096 11월  9 07:01 docs\ndrwxrwxr-x  2 user user  4096 11월  9 07:01 external\ndrwxrwxr-x  8 user user  4096 11월  9 07:01 .git\ndrwxrwxr-x  4 user user  4096 11월  9 07:01 .github\n-rw-rw-r--  1 user user    58 11월  9 07:01 .gitignore\ndrwxrwxr-x  4 user user  4096 11월  9 07:01 include\ndrwxrwxr-x 12 user user  4096 11월  9 07:01 libfreerdp\n-rw-rw-r--  1 user user 11358 11월  9 07:01 LICENSE\ndrwxrwxr-x  7 user user  4096 10월 18 22:04 packaging\ndrwxrwxr-x  6 user user  4096 11월  9 07:01 rdtk\n-rw-rw-r--  1 user user  2544 11월  9 07:01 README.md\ndrwxrwxr-x  3 user user  4096 11월  9 07:01 resources\ndrwxrwxr-x  2 user user  4096 11월  9 07:01 scripts\n-rw-rw-r--  1 user user  6096 11월  9 07:01 SECURITY.md\ndrwxrwxr-x  8 user user  4096 11월  9 07:01 server\ndrwxrwxr-x  2 user user  4096 11월  9 07:01 third-party\ndrwxrwxr-x  3 user user  4096 11월  9 07:01 tools\ndrwxrwxr-x  6 user user  4096 11월  9 07:01 uwac\ndrwxrwxr-x  6 user user  4096 11월  9 07:01 winpr', is_error=False)], parent_tool_use_id=None)

================================================================================
Message 13: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01GSSQZWqRJgkg3mU162vP9w', name='KillShell', input={'shell_id': '540b51'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 14: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01GSSQZWqRJgkg3mU162vP9w', content='{"message":"Successfully killed shell: 540b51 (find / -type f -name \\"freerdp.c\\" 2>/dev/null | head -20)","shell_id":"540b51"}', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 15: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Now let me find the correct file paths:')], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 16: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01RudWpjuE2P1zUG2PADRCp4', name='Glob', input={'pattern': '**/freerdp.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 17: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01Gdn6PMYxzS4LdsxP2M8Gcw', name='Glob', input={'pattern': '**/TestFuzzCoreServer.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 18: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01RudWpjuE2P1zUG2PADRCp4', content='/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 19: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01Gdn6PMYxzS4LdsxP2M8Gcw', content='/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/test/TestFuzzCoreServer.c', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 20: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Good! Now let me read these files:')], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 21: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01S8xN4iTjLtJJz6ZksmQ92e', name='Read', input={'file_path': '/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 22: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01SK48LDkiWgTmto1gAyg8TS', name='Read', input={'file_path': '/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/test/TestFuzzCoreServer.c'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 23: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01SK48LDkiWgTmto1gAyg8TS', content='     1→#include <freerdp/peer.h>\n     2→\n     3→#include "../fastpath.h"\n     4→#include "../surface.h"\n     5→#include "../window.h"\n     6→#include "../info.h"\n     7→#include "../multitransport.h"\n     8→\n     9→static BOOL test_server(const uint8_t* Data, size_t Size)\n    10→{\n    11→\tfreerdp_peer* client = calloc(1, sizeof(freerdp_peer));\n    12→\tif (!client)\n    13→\t\tgoto fail;\n    14→\tclient->ContextSize = sizeof(rdpContext);\n    15→\tif (!freerdp_peer_context_new(client))\n    16→\t\tgoto fail;\n    17→\n    18→\tWINPR_ASSERT(client->context);\n    19→\trdpRdp* rdp = client->context->rdp;\n    20→\tWINPR_ASSERT(rdp);\n    21→\n    22→\twStream sbuffer = { 0 };\n    23→\twStream* s = Stream_StaticConstInit(&sbuffer, Data, Size);\n    24→\n    25→\t{\n    26→\t\trdpFastPath* fastpath = rdp->fastpath;\n    27→\t\tWINPR_ASSERT(fastpath);\n    28→\n    29→\t\tfastpath_recv_updates(fastpath, s);\n    30→\t\tfastpath_recv_inputs(fastpath, s);\n    31→\n    32→\t\tUINT16 length = 0;\n    33→\t\tfastpath_read_header_rdp(fastpath, s, &length);\n    34→\t\tfastpath_decrypt(fastpath, s, &length);\n    35→\t}\n    36→\n    37→\t{\n    38→\t\tUINT16 length = 0;\n    39→\t\tUINT16 flags = 0;\n    40→\t\tUINT16 channelId = 0;\n    41→\t\tUINT16 tpktLength = 0;\n    42→\t\tUINT16 remainingLength = 0;\n    43→\t\tUINT16 type = 0;\n    44→\t\tUINT16 securityFlags = 0;\n    45→\t\tUINT32 share_id = 0;\n    46→\t\tBYTE compressed_type = 0;\n    47→\t\tBYTE btype = 0;\n    48→\t\tUINT16 compressed_len = 0;\n    49→\t\trdp_read_security_header(rdp, s, &flags, &length);\n    50→\t\trdp_read_header(rdp, s, &length, &channelId);\n    51→\t\trdp_read_share_control_header(rdp, s, &tpktLength, &remainingLength, &type, &channelId);\n    52→\t\trdp_read_share_data_header(rdp, s, &length, &btype, &share_id, &compressed_type,\n    53→\t\t                           &compressed_len);\n    54→\t\trdp_recv_message_channel_pdu(rdp, s, securityFlags);\n    55→\t}\n    56→\t{\n    57→\t\trdpUpdate* update = rdp->update;\n    58→\t\tUINT16 channelId = 0;\n    59→\t\tUINT16 length = 0;\n    60→\t\tUINT16 pduSource = 0;\n    61→\t\tUINT16 pduLength = 0;\n    62→\t\tupdate_recv_order(update, s);\n    63→\t\tupdate_recv_altsec_window_order(update, s);\n    64→\t\tupdate_recv_play_sound(update, s);\n    65→\t\tupdate_recv_pointer(update, s);\n    66→\t\tupdate_recv_surfcmds(update, s);\n    67→\t\trdp_recv_get_active_header(rdp, s, &channelId, &length);\n    68→\t\trdp_recv_demand_active(rdp, s, pduSource, length);\n    69→\t\trdp_recv_confirm_active(rdp, s, pduLength);\n    70→\t}\n    71→\t{\n    72→\t\trdpNla* nla = nla_new(rdp->context, rdp->transport);\n    73→\t\tnla_recv_pdu(nla, s);\n    74→\t\tnla_free(nla);\n    75→\t}\n    76→\t{\n    77→\t\trdp_recv_heartbeat_packet(rdp, s);\n    78→\t\trdp->state = CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE;\n    79→\t\trdp_recv_client_info(rdp, s);\n    80→\t}\n    81→\t{\n    82→\t\tfreerdp_is_valid_mcs_create_request(Data, Size);\n    83→\t\tfreerdp_is_valid_mcs_create_response(Data, Size);\n    84→\t}\n    85→\t{\n    86→\t\tmultitransport_recv_request(rdp->multitransport, s);\n    87→\t\tmultitransport_recv_response(rdp->multitransport, s);\n    88→\t}\n    89→\t{\n    90→\t\tautodetect_recv_request_packet(rdp->autodetect, RDP_TRANSPORT_TCP, s);\n    91→\t\tautodetect_recv_response_packet(rdp->autodetect, RDP_TRANSPORT_TCP, s);\n    92→\t}\n    93→\t{\n    94→\t\trdp_recv_deactivate_all(rdp, s);\n    95→\t\trdp_recv_server_synchronize_pdu(rdp, s);\n    96→\t\trdp_recv_client_synchronize_pdu(rdp, s);\n    97→\t}\n    98→fail:\n    99→\tfreerdp_peer_context_free(client);\n   100→\tfree(client);\n   101→\treturn TRUE;\n   102→}\n   103→\n   104→int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size)\n   105→{\n   106→\ttest_server(Data, Size);\n   107→\treturn 0;\n   108→}\n   109→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 24: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01S8xN4iTjLtJJz6ZksmQ92e', content='     1→/**\n     2→ * FreeRDP: A Remote Desktop Protocol Implementation\n     3→ * FreeRDP Core\n     4→ *\n     5→ * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n     6→ * Copyright 2015 Thincast Technologies GmbH\n     7→ * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n     8→ *\n     9→ * Licensed under the Apache License, Version 2.0 (the "License");\n    10→ * you may not use this file except in compliance with the License.\n    11→ * You may obtain a copy of the License at\n    12→ *\n    13→ *     http://www.apache.org/licenses/LICENSE-2.0\n    14→ *\n    15→ * Unless required by applicable law or agreed to in writing, software\n    16→ * distributed under the License is distributed on an "AS IS" BASIS,\n    17→ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    18→ * See the License for the specific language governing permissions and\n    19→ * limitations under the License.\n    20→ */\n    21→\n    22→#include <freerdp/config.h>\n    23→\n    24→#include "settings.h"\n    25→\n    26→#include <string.h>\n    27→#include <stdarg.h>\n    28→#include <time.h>\n    29→\n    30→#include "rdp.h"\n    31→#include "input.h"\n    32→#include "update.h"\n    33→#include "surface.h"\n    34→#include "transport.h"\n    35→#include "connection.h"\n    36→#include "message.h"\n    37→#include <freerdp/buildflags.h>\n    38→#include "gateway/rpc_fault.h"\n    39→\n    40→#include <winpr/assert.h>\n    41→\n    42→#include <winpr/crt.h>\n    43→#include <winpr/string.h>\n    44→#include <winpr/stream.h>\n    45→#include <winpr/wtsapi.h>\n    46→#include <winpr/ssl.h>\n    47→#include <winpr/debug.h>\n    48→\n    49→#include <freerdp/freerdp.h>\n    50→#include <freerdp/streamdump.h>\n    51→#include <freerdp/error.h>\n    52→#include <freerdp/event.h>\n    53→#include <freerdp/locale/keyboard.h>\n    54→#include <freerdp/locale/locale.h>\n    55→#include <freerdp/channels/channels.h>\n    56→#include <freerdp/version.h>\n    57→#include <freerdp/log.h>\n    58→#include <freerdp/utils/signal.h>\n    59→\n    60→#include "../cache/pointer.h"\n    61→#include "utils.h"\n    62→\n    63→#define TAG FREERDP_TAG("core")\n    64→\n    65→static void sig_abort_connect(int signum, const char* signame, void* ctx)\n    66→{\n    67→\trdpContext* context = (rdpContext*)ctx;\n    68→\n    69→\tWLog_INFO(TAG, "Signal %s [%d], terminating session %p", signame, signum, context);\n    70→\tif (context)\n    71→\t\tfreerdp_abort_connect_context(context);\n    72→}\n    73→\n    74→/** Creates a new connection based on the settings found in the "instance" parameter\n    75→ *  It will use the callbacks registered on the structure to process the pre/post connect operations\n    76→ *  that the caller requires.\n    77→ *  @see struct rdp_freerdp in freerdp.h\n    78→ *\n    79→ *  @param instance - pointer to a rdp_freerdp structure that contains base information to establish\n    80→ * the connection. On return, this function will be initialized with the new connection\'s settings.\n    81→ *\n    82→ *  @return TRUE if successful. FALSE otherwise.\n    83→ *\n    84→ */\n    85→static int freerdp_connect_begin(freerdp* instance)\n    86→{\n    87→\tBOOL rc = 0;\n    88→\trdpRdp* rdp = NULL;\n    89→\tBOOL status = TRUE;\n    90→\trdpSettings* settings = NULL;\n    91→\n    92→\tif (!instance)\n    93→\t\treturn -1;\n    94→\n    95→\tWINPR_ASSERT(instance->context);\n    96→\n    97→\t/* We always set the return code to 0 before we start the connect sequence*/\n    98→\tinstance->ConnectionCallbackState = CLIENT_STATE_INITIAL;\n    99→\tfreerdp_set_last_error_log(instance->context, FREERDP_ERROR_SUCCESS);\n   100→\tclearChannelError(instance->context);\n   101→\tif (!utils_reset_abort(instance->context->rdp))\n   102→\t\treturn -1;\n   103→\n   104→\trdp = instance->context->rdp;\n   105→\tWINPR_ASSERT(rdp);\n   106→\n   107→\tsettings = instance->context->settings;\n   108→\tWINPR_ASSERT(settings);\n   109→\n   110→\tfreerdp_channels_register_instance(instance->context->channels, instance);\n   111→\n   112→\tif (!freerdp_settings_set_default_order_support(settings))\n   113→\t\treturn -1;\n   114→\n   115→\tfreerdp_add_signal_cleanup_handler(instance->context, sig_abort_connect);\n   116→\n   117→\tIFCALLRET(instance->PreConnect, status, instance);\n   118→\tinstance->ConnectionCallbackState = CLIENT_STATE_PRECONNECT_PASSED;\n   119→\n   120→\tfreerdp_settings_print_warnings(settings);\n   121→\tif (status)\n   122→\t\tstatus = freerdp_settings_enforce_monitor_exists(settings);\n   123→\n   124→\tif (status)\n   125→\t\tstatus = freerdp_settings_check_client_after_preconnect(settings);\n   126→\n   127→\tif (status)\n   128→\t\tstatus = rdp_set_backup_settings(rdp);\n   129→\tif (status)\n   130→\t\tstatus = utils_reload_channels(instance->context);\n   131→\n   132→\tconst UINT32 cp = freerdp_settings_get_uint32(settings, FreeRDP_KeyboardCodePage);\n   133→\tint64_t KeyboardLayout = freerdp_get_keyboard_default_layout_for_locale(cp);\n   134→\tif (KeyboardLayout == 0)\n   135→\t\tKeyboardLayout = freerdp_settings_get_uint32(settings, FreeRDP_KeyboardLayout);\n   136→\n   137→\tswitch (KeyboardLayout)\n   138→\t{\n   139→\t\tcase KBD_JAPANESE:\n   140→\t\tcase KBD_JAPANESE_INPUT_SYSTEM_MS_IME2002:\n   141→\t\t{\n   142→\t\t\tif (!freerdp_settings_set_uint32(settings, FreeRDP_KeyboardType,\n   143→\t\t\t                                 WINPR_KBD_TYPE_JAPANESE))\n   144→\t\t\t\treturn -1;\n   145→\t\t\tif (!freerdp_settings_set_uint32(settings, FreeRDP_KeyboardSubType, 2))\n   146→\t\t\t\treturn -1;\n   147→\t\t\tif (!freerdp_settings_set_uint32(settings, FreeRDP_KeyboardFunctionKey, 12))\n   148→\t\t\t\treturn -1;\n   149→\t\t}\n   150→\t\tbreak;\n   151→\t\tdefault:\n   152→\t\t\tbreak;\n   153→\t}\n   154→\n   155→\tif (!status)\n   156→\t{\n   157→\t\trdpContext* context = instance->context;\n   158→\t\tWINPR_ASSERT(context);\n   159→\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_PRE_CONNECT_FAILED);\n   160→\n   161→\t\tWLog_Print(context->log, WLOG_ERROR, "freerdp_pre_connect failed: %s",\n   162→\t\t           rdp_client_connection_state_string(instance->ConnectionCallbackState));\n   163→\t\treturn 0;\n   164→\t}\n   165→\n   166→\trc = rdp_client_connect(rdp);\n   167→\n   168→\t/* --authonly tests the connection without a UI */\n   169→\tif (freerdp_settings_get_bool(rdp->settings, FreeRDP_AuthenticationOnly))\n   170→\t{\n   171→\t\trdpContext* context = rdp->context;\n   172→\t\tWINPR_ASSERT(context);\n   173→\t\tWLog_Print(context->log, WLOG_ERROR, "Authentication only, exit status %" PRId32 "", rc);\n   174→\t\treturn 0;\n   175→\t}\n   176→\n   177→\treturn rc ? 1 : 0;\n   178→}\n   179→\n   180→BOOL freerdp_connect(freerdp* instance)\n   181→{\n   182→\tBOOL status = FALSE;\n   183→\tConnectionResultEventArgs e = { 0 };\n   184→\tconst int rc = freerdp_connect_begin(instance);\n   185→\trdpRdp* rdp = NULL;\n   186→\tUINT status2 = ERROR_INTERNAL_ERROR;\n   187→\n   188→\tWINPR_ASSERT(instance);\n   189→\tWINPR_ASSERT(instance->context);\n   190→\n   191→\trdp = instance->context->rdp;\n   192→\tWINPR_ASSERT(rdp);\n   193→\tWINPR_ASSERT(rdp->settings);\n   194→\n   195→\tif (rc > 0)\n   196→\t/* Pointers might have changed in between */\n   197→\t{\n   198→\t\trdp_update_internal* up = update_cast(rdp->update);\n   199→\n   200→\t\tif (freerdp_settings_get_bool(rdp->settings, FreeRDP_DumpRemoteFx))\n   201→\t\t{\n   202→\t\t\tup->pcap_rfx = pcap_open(\n   203→\t\t\t    freerdp_settings_get_string(rdp->settings, FreeRDP_DumpRemoteFxFile), TRUE);\n   204→\n   205→\t\t\tif (up->pcap_rfx)\n   206→\t\t\t\tup->dump_rfx = TRUE;\n   207→\t\t}\n   208→\n   209→\t\tpointer_cache_register_callbacks(instance->context->update);\n   210→\t\tstatus = IFCALLRESULT(TRUE, instance->PostConnect, instance);\n   211→\t\tinstance->ConnectionCallbackState = CLIENT_STATE_POSTCONNECT_PASSED;\n   212→\n   213→\t\tif (status)\n   214→\t\t\tstatus2 = freerdp_channels_post_connect(instance->context->channels, instance);\n   215→\t}\n   216→\telse\n   217→\t{\n   218→\t\tstatus2 = CHANNEL_RC_OK;\n   219→\t\tif (freerdp_get_last_error(instance->context) == FREERDP_ERROR_CONNECT_TRANSPORT_FAILED)\n   220→\t\t\tstatus = freerdp_reconnect(instance);\n   221→\t\telse\n   222→\t\t\tgoto freerdp_connect_finally;\n   223→\t}\n   224→\n   225→\tif (!status || (status2 != CHANNEL_RC_OK) || !update_post_connect(instance->context->update))\n   226→\t{\n   227→\t\trdpContext* context = instance->context;\n   228→\t\tWINPR_ASSERT(context);\n   229→\t\tWLog_Print(context->log, WLOG_ERROR, "freerdp_post_connect failed");\n   230→\n   231→\t\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_POST_CONNECT_FAILED);\n   232→\n   233→\t\tstatus = FALSE;\n   234→\t\tgoto freerdp_connect_finally;\n   235→\t}\n   236→\n   237→\tif (rdp->settings->PlayRemoteFx)\n   238→\t{\n   239→\t\twStream* s = NULL;\n   240→\t\trdp_update_internal* update = update_cast(instance->context->update);\n   241→\t\tpcap_record record = { 0 };\n   242→\n   243→\t\tWINPR_ASSERT(update);\n   244→\t\tupdate->pcap_rfx = pcap_open(rdp->settings->PlayRemoteFxFile, FALSE);\n   245→\t\tstatus = FALSE;\n   246→\n   247→\t\tif (!update->pcap_rfx)\n   248→\t\t\tgoto freerdp_connect_finally;\n   249→\t\telse\n   250→\t\t\tupdate->play_rfx = TRUE;\n   251→\n   252→\t\tstatus = TRUE;\n   253→\n   254→\t\twhile (pcap_has_next_record(update->pcap_rfx) && status)\n   255→\t\t{\n   256→\t\t\tpcap_get_next_record_header(update->pcap_rfx, &record);\n   257→\n   258→\t\t\ts = transport_take_from_pool(rdp->transport, record.length);\n   259→\t\t\tif (!s)\n   260→\t\t\t\tbreak;\n   261→\n   262→\t\t\trecord.data = Stream_Buffer(s);\n   263→\t\t\tpcap_get_next_record_content(update->pcap_rfx, &record);\n   264→\t\t\tStream_SetLength(s, record.length);\n   265→\t\t\tStream_SetPosition(s, 0);\n   266→\n   267→\t\t\tif (!update_begin_paint(&update->common))\n   268→\t\t\t\tstatus = FALSE;\n   269→\t\t\telse\n   270→\t\t\t{\n   271→\t\t\t\tif (update_recv_surfcmds(&update->common, s) < 0)\n   272→\t\t\t\t\tstatus = FALSE;\n   273→\n   274→\t\t\t\tif (!update_end_paint(&update->common))\n   275→\t\t\t\t\tstatus = FALSE;\n   276→\t\t\t}\n   277→\n   278→\t\t\tStream_Release(s);\n   279→\t\t}\n   280→\n   281→\t\tpcap_close(update->pcap_rfx);\n   282→\t\tupdate->pcap_rfx = NULL;\n   283→\t\tgoto freerdp_connect_finally;\n   284→\t}\n   285→\n   286→\tif (rdp->errorInfo == ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES)\n   287→\t\tfreerdp_set_last_error_log(instance->context, FREERDP_ERROR_INSUFFICIENT_PRIVILEGES);\n   288→\n   289→\ttransport_set_connected_event(rdp->transport);\n   290→\n   291→freerdp_connect_finally:\n   292→\tEventArgsInit(&e, "freerdp");\n   293→\te.result = status ? 0 : -1;\n   294→\tPubSub_OnConnectionResult(rdp->pubSub, instance->context, &e);\n   295→\n   296→\tif (!status)\n   297→\t\tfreerdp_disconnect(instance);\n   298→\n   299→\treturn status;\n   300→}\n   301→\n   302→BOOL freerdp_abort_connect(freerdp* instance)\n   303→{\n   304→\tif (!instance)\n   305→\t\treturn FALSE;\n   306→\n   307→\treturn freerdp_abort_connect_context(instance->context);\n   308→}\n   309→\n   310→BOOL freerdp_abort_connect_context(rdpContext* context)\n   311→{\n   312→\tif (!context)\n   313→\t\treturn FALSE;\n   314→\n   315→\tfreerdp_set_last_error_if_not(context, FREERDP_ERROR_CONNECT_CANCELLED);\n   316→\n   317→\treturn utils_abort_connect(context->rdp);\n   318→}\n   319→\n   320→#if defined(WITH_FREERDP_DEPRECATED)\n   321→BOOL freerdp_get_fds(freerdp* instance, void** rfds, int* rcount, void** wfds, int* wcount)\n   322→{\n   323→\trdpRdp* rdp = NULL;\n   324→\n   325→\tWINPR_ASSERT(instance);\n   326→\tWINPR_ASSERT(instance->context);\n   327→\n   328→\trdp = instance->context->rdp;\n   329→\tWINPR_ASSERT(rdp);\n   330→\n   331→\ttransport_get_fds(rdp->transport, rfds, rcount);\n   332→\treturn TRUE;\n   333→}\n   334→#endif\n   335→\n   336→BOOL freerdp_check_fds(freerdp* instance)\n   337→{\n   338→\tint status = 0;\n   339→\trdpRdp* rdp = NULL;\n   340→\n   341→\tif (!instance)\n   342→\t\treturn FALSE;\n   343→\n   344→\tif (!instance->context)\n   345→\t\treturn FALSE;\n   346→\n   347→\tif (!instance->context->rdp)\n   348→\t\treturn FALSE;\n   349→\n   350→\trdp = instance->context->rdp;\n   351→\tstatus = rdp_check_fds(rdp);\n   352→\n   353→\tif (status < 0)\n   354→\t{\n   355→\t\tTerminateEventArgs e;\n   356→\t\trdpContext* context = instance->context;\n   357→\t\tWINPR_ASSERT(context);\n   358→\n   359→\t\tWLog_Print(context->log, WLOG_DEBUG, "rdp_check_fds() - %i", status);\n   360→\t\tEventArgsInit(&e, "freerdp");\n   361→\t\te.code = 0;\n   362→\t\tPubSub_OnTerminate(rdp->pubSub, context, &e);\n   363→\t\treturn FALSE;\n   364→\t}\n   365→\n   366→\treturn TRUE;\n   367→}\n   368→\n   369→DWORD freerdp_get_event_handles(rdpContext* context, HANDLE* events, DWORD count)\n   370→{\n   371→\tDWORD nCount = 0;\n   372→\n   373→\tWINPR_ASSERT(context);\n   374→\tWINPR_ASSERT(context->rdp);\n   375→\tWINPR_ASSERT(events || (count == 0));\n   376→\n   377→\tnCount += transport_get_event_handles(context->rdp->transport, events, count);\n   378→\n   379→\tif (nCount == 0)\n   380→\t\treturn 0;\n   381→\n   382→\tif (events && (nCount < count + 2))\n   383→\t{\n   384→\t\tevents[nCount++] = freerdp_channels_get_event_handle(context->instance);\n   385→\t\tevents[nCount++] = getChannelErrorEventHandle(context);\n   386→\t\tevents[nCount++] = utils_get_abort_event(context->rdp);\n   387→\t}\n   388→\telse\n   389→\t\treturn 0;\n   390→\n   391→\tconst SSIZE_T rc = freerdp_client_channel_get_registered_event_handles(\n   392→\t    context->channels, &events[nCount], count - nCount);\n   393→\tif (rc < 0)\n   394→\t\treturn 0;\n   395→\treturn nCount + (DWORD)rc;\n   396→}\n   397→\n   398→/* Resend mouse cursor position to prevent session lock in prevent-session-lock mode */\n   399→static BOOL freerdp_prevent_session_lock(rdpContext* context)\n   400→{\n   401→\tWINPR_ASSERT(context);\n   402→\tWINPR_ASSERT(context->input);\n   403→\n   404→\trdp_input_internal* in = input_cast(context->input);\n   405→\n   406→\tUINT32 FakeMouseMotionInterval =\n   407→\t    freerdp_settings_get_uint32(context->settings, FreeRDP_FakeMouseMotionInterval);\n   408→\tif (FakeMouseMotionInterval && in->lastInputTimestamp)\n   409→\t{\n   410→\t\tconst time_t now = time(NULL);\n   411→\t\tif (WINPR_ASSERTING_INT_CAST(size_t, now) - in->lastInputTimestamp >\n   412→\t\t    FakeMouseMotionInterval)\n   413→\t\t{\n   414→\t\t\tWLog_Print(context->log, WLOG_DEBUG,\n   415→\t\t\t           "fake mouse move: x=%d y=%d lastInputTimestamp=%" PRIu64 " "\n   416→\t\t\t           "FakeMouseMotionInterval=%" PRIu32,\n   417→\t\t\t           in->lastX, in->lastY, in->lastInputTimestamp, FakeMouseMotionInterval);\n   418→\n   419→\t\t\tBOOL status = freerdp_input_send_mouse_event(context->input, PTR_FLAGS_MOVE, in->lastX,\n   420→\t\t\t                                             in->lastY);\n   421→\t\t\tif (!status)\n   422→\t\t\t{\n   423→\t\t\t\tif (freerdp_get_last_error(context) == FREERDP_ERROR_SUCCESS)\n   424→\t\t\t\t\tWLog_Print(context->log, WLOG_ERROR,\n   425→\t\t\t\t\t           "freerdp_prevent_session_lock() failed - %" PRIi32 "", status);\n   426→\n   427→\t\t\t\treturn FALSE;\n   428→\t\t\t}\n   429→\n   430→\t\t\treturn status;\n   431→\t\t}\n   432→\t}\n   433→\n   434→\treturn TRUE;\n   435→}\n   436→\n   437→BOOL freerdp_check_event_handles(rdpContext* context)\n   438→{\n   439→\tWINPR_ASSERT(context);\n   440→\n   441→\tBOOL status = freerdp_check_fds(context->instance);\n   442→\n   443→\tif (!status)\n   444→\t{\n   445→\t\tif (freerdp_get_last_error(context) == FREERDP_ERROR_SUCCESS)\n   446→\t\t\tWLog_Print(context->log, WLOG_ERROR, "freerdp_check_fds() failed - %" PRIi32 "",\n   447→\t\t\t           status);\n   448→\n   449→\t\treturn FALSE;\n   450→\t}\n   451→\n   452→\tstatus = freerdp_channels_check_fds(context->channels, context->instance);\n   453→\n   454→\tif (!status)\n   455→\t{\n   456→\t\tif (freerdp_get_last_error(context) == FREERDP_ERROR_SUCCESS)\n   457→\t\t\tWLog_Print(context->log, WLOG_ERROR,\n   458→\t\t\t           "freerdp_channels_check_fds() failed - %" PRIi32 "", status);\n   459→\n   460→\t\treturn FALSE;\n   461→\t}\n   462→\n   463→\tstatus = checkChannelErrorEvent(context);\n   464→\n   465→\tif (!status)\n   466→\t{\n   467→\t\tif (freerdp_get_last_error(context) == FREERDP_ERROR_SUCCESS)\n   468→\t\t\tWLog_Print(context->log, WLOG_ERROR, "checkChannelErrorEvent() failed - %" PRIi32 "",\n   469→\t\t\t           status);\n   470→\n   471→\t\treturn FALSE;\n   472→\t}\n   473→\n   474→\tstatus = freerdp_prevent_session_lock(context);\n   475→\n   476→\treturn status;\n   477→}\n   478→\n   479→wMessageQueue* freerdp_get_message_queue(freerdp* instance, DWORD id)\n   480→{\n   481→\twMessageQueue* queue = NULL;\n   482→\n   483→\tWINPR_ASSERT(instance);\n   484→\n   485→\trdpContext* context = instance->context;\n   486→\tWINPR_ASSERT(context);\n   487→\n   488→\tswitch (id)\n   489→\t{\n   490→\t\tcase FREERDP_UPDATE_MESSAGE_QUEUE:\n   491→\t\t{\n   492→\t\t\trdp_update_internal* update = update_cast(context->update);\n   493→\t\t\tqueue = update->queue;\n   494→\t\t}\n   495→\t\tbreak;\n   496→\n   497→\t\tcase FREERDP_INPUT_MESSAGE_QUEUE:\n   498→\t\t{\n   499→\t\t\trdp_input_internal* input = input_cast(context->input);\n   500→\t\t\tqueue = input->queue;\n   501→\t\t}\n   502→\t\tbreak;\n   503→\t\tdefault:\n   504→\t\t\tbreak;\n   505→\t}\n   506→\n   507→\treturn queue;\n   508→}\n   509→\n   510→HANDLE freerdp_get_message_queue_event_handle(freerdp* instance, DWORD id)\n   511→{\n   512→\tHANDLE event = NULL;\n   513→\twMessageQueue* queue = freerdp_get_message_queue(instance, id);\n   514→\n   515→\tif (queue)\n   516→\t\tevent = MessageQueue_Event(queue);\n   517→\n   518→\treturn event;\n   519→}\n   520→\n   521→int freerdp_message_queue_process_message(freerdp* instance, DWORD id, wMessage* message)\n   522→{\n   523→\tint status = -1;\n   524→\trdpContext* context = NULL;\n   525→\n   526→\tWINPR_ASSERT(instance);\n   527→\n   528→\tcontext = instance->context;\n   529→\tWINPR_ASSERT(context);\n   530→\n   531→\tswitch (id)\n   532→\t{\n   533→\t\tcase FREERDP_UPDATE_MESSAGE_QUEUE:\n   534→\t\t\tstatus = update_message_queue_process_message(context->update, message);\n   535→\t\t\tbreak;\n   536→\n   537→\t\tcase FREERDP_INPUT_MESSAGE_QUEUE:\n   538→\t\t\tstatus = input_message_queue_process_message(context->input, message);\n   539→\t\t\tbreak;\n   540→\t\tdefault:\n   541→\t\t\tbreak;\n   542→\t}\n   543→\n   544→\treturn status;\n   545→}\n   546→\n   547→int freerdp_message_queue_process_pending_messages(freerdp* instance, DWORD id)\n   548→{\n   549→\tint status = -1;\n   550→\trdpContext* context = NULL;\n   551→\n   552→\tWINPR_ASSERT(instance);\n   553→\n   554→\tcontext = instance->context;\n   555→\tWINPR_ASSERT(context);\n   556→\n   557→\tswitch (id)\n   558→\t{\n   559→\t\tcase FREERDP_UPDATE_MESSAGE_QUEUE:\n   560→\t\t\tstatus = update_message_queue_process_pending_messages(context->update);\n   561→\t\t\tbreak;\n   562→\n   563→\t\tcase FREERDP_INPUT_MESSAGE_QUEUE:\n   564→\t\t\tstatus = input_message_queue_process_pending_messages(context->input);\n   565→\t\t\tbreak;\n   566→\t\tdefault:\n   567→\t\t\tbreak;\n   568→\t}\n   569→\n   570→\treturn status;\n   571→}\n   572→\n   573→static BOOL freerdp_send_channel_data(freerdp* instance, UINT16 channelId, const BYTE* data,\n   574→                                      size_t size)\n   575→{\n   576→\tWINPR_ASSERT(instance);\n   577→\tWINPR_ASSERT(instance->context);\n   578→\tWINPR_ASSERT(instance->context->rdp);\n   579→\treturn rdp_send_channel_data(instance->context->rdp, channelId, data, size);\n   580→}\n   581→\n   582→static BOOL freerdp_send_channel_packet(freerdp* instance, UINT16 channelId, size_t totalSize,\n   583→                                        UINT32 flags, const BYTE* data, size_t chunkSize)\n   584→{\n   585→\tWINPR_ASSERT(instance);\n   586→\tWINPR_ASSERT(instance->context);\n   587→\tWINPR_ASSERT(instance->context->rdp);\n   588→\treturn rdp_channel_send_packet(instance->context->rdp, channelId, totalSize, flags, data,\n   589→\t                               chunkSize);\n   590→}\n   591→\n   592→BOOL freerdp_disconnect(freerdp* instance)\n   593→{\n   594→\tBOOL rc = TRUE;\n   595→\trdpRdp* rdp = NULL;\n   596→\trdp_update_internal* up = NULL;\n   597→\n   598→\tif (!instance || !instance->context)\n   599→\t\treturn FALSE;\n   600→\n   601→\trdp = instance->context->rdp;\n   602→\tutils_abort_connect(rdp);\n   603→\n   604→\tif (!rdp_client_disconnect(rdp))\n   605→\t\trc = FALSE;\n   606→\n   607→\tup = update_cast(rdp->update);\n   608→\n   609→\tupdate_post_disconnect(rdp->update);\n   610→\n   611→\tIFCALL(instance->PostDisconnect, instance);\n   612→\n   613→\tif (up->pcap_rfx)\n   614→\t{\n   615→\t\tup->dump_rfx = FALSE;\n   616→\t\tpcap_close(up->pcap_rfx);\n   617→\t\tup->pcap_rfx = NULL;\n   618→\t}\n   619→\n   620→\tfreerdp_channels_close(instance->context->channels, instance);\n   621→\n   622→\tIFCALL(instance->PostFinalDisconnect, instance);\n   623→\n   624→\tfreerdp_del_signal_cleanup_handler(instance->context, sig_abort_connect);\n   625→\treturn rc;\n   626→}\n   627→\n   628→BOOL freerdp_disconnect_before_reconnect(freerdp* instance)\n   629→{\n   630→\tWINPR_ASSERT(instance);\n   631→\treturn freerdp_disconnect_before_reconnect_context(instance->context);\n   632→}\n   633→\n   634→BOOL freerdp_disconnect_before_reconnect_context(rdpContext* context)\n   635→{\n   636→\trdpRdp* rdp = NULL;\n   637→\n   638→\tWINPR_ASSERT(context);\n   639→\n   640→\trdp = context->rdp;\n   641→\treturn rdp_client_disconnect_and_clear(rdp);\n   642→}\n   643→\n   644→BOOL freerdp_reconnect(freerdp* instance)\n   645→{\n   646→\trdpRdp* rdp = NULL;\n   647→\n   648→\tWINPR_ASSERT(instance);\n   649→\tWINPR_ASSERT(instance->context);\n   650→\n   651→\tif (freerdp_get_last_error(instance->context) == FREERDP_ERROR_CONNECT_CANCELLED)\n   652→\t\treturn FALSE;\n   653→\n   654→\trdp = instance->context->rdp;\n   655→\n   656→\tif (!utils_reset_abort(instance->context->rdp))\n   657→\t\treturn FALSE;\n   658→\treturn rdp_client_reconnect(rdp);\n   659→}\n   660→\n   661→BOOL freerdp_shall_disconnect(freerdp* instance)\n   662→{\n   663→\tif (!instance)\n   664→\t\treturn FALSE;\n   665→\n   666→\treturn freerdp_shall_disconnect_context(instance->context);\n   667→}\n   668→\n   669→BOOL freerdp_shall_disconnect_context(const rdpContext* context)\n   670→{\n   671→\tif (!context)\n   672→\t\treturn FALSE;\n   673→\n   674→\treturn utils_abort_event_is_set(context->rdp);\n   675→}\n   676→\n   677→BOOL freerdp_focus_required(freerdp* instance)\n   678→{\n   679→\trdpRdp* rdp = NULL;\n   680→\tBOOL bRetCode = FALSE;\n   681→\n   682→\tWINPR_ASSERT(instance);\n   683→\tWINPR_ASSERT(instance->context);\n   684→\n   685→\trdp = instance->context->rdp;\n   686→\tWINPR_ASSERT(rdp);\n   687→\n   688→\tif (rdp->resendFocus)\n   689→\t{\n   690→\t\tbRetCode = TRUE;\n   691→\t\trdp->resendFocus = FALSE;\n   692→\t}\n   693→\n   694→\treturn bRetCode;\n   695→}\n   696→\n   697→void freerdp_set_focus(freerdp* instance)\n   698→{\n   699→\trdpRdp* rdp = NULL;\n   700→\n   701→\tWINPR_ASSERT(instance);\n   702→\tWINPR_ASSERT(instance->context);\n   703→\n   704→\trdp = instance->context->rdp;\n   705→\tWINPR_ASSERT(rdp);\n   706→\n   707→\trdp->resendFocus = TRUE;\n   708→}\n   709→\n   710→void freerdp_get_version(int* major, int* minor, int* revision)\n   711→{\n   712→\tif (major != NULL)\n   713→\t\t*major = FREERDP_VERSION_MAJOR;\n   714→\n   715→\tif (minor != NULL)\n   716→\t\t*minor = FREERDP_VERSION_MINOR;\n   717→\n   718→\tif (revision != NULL)\n   719→\t\t*revision = FREERDP_VERSION_REVISION;\n   720→}\n   721→\n   722→const char* freerdp_get_version_string(void)\n   723→{\n   724→\treturn FREERDP_VERSION_FULL;\n   725→}\n   726→\n   727→const char* freerdp_get_build_config(void)\n   728→{\n   729→\tWINPR_PRAGMA_DIAG_PUSH\n   730→\tWINPR_PRAGMA_DIAG_IGNORED_OVERLENGTH_STRINGS\n   731→\tstatic const char build_config[] =\n   732→\t    "Build configuration: " FREERDP_BUILD_CONFIG "\\n"\n   733→\t    "Build type:          " FREERDP_BUILD_TYPE "\\n"\n   734→\t    "CFLAGS:              " FREERDP_CFLAGS "\\n"\n   735→\t    "Compiler:            " FREERDP_COMPILER_ID ", " FREERDP_COMPILER_VERSION "\\n"\n   736→\t    "Target architecture: " FREERDP_TARGET_ARCH "\\n";\n   737→\tWINPR_PRAGMA_DIAG_POP\n   738→\treturn build_config;\n   739→}\n   740→\n   741→const char* freerdp_get_build_revision(void)\n   742→{\n   743→\treturn FREERDP_GIT_REVISION;\n   744→}\n   745→\n   746→static wEventType FreeRDP_Events[] = {\n   747→\tDEFINE_EVENT_ENTRY(WindowStateChange),   DEFINE_EVENT_ENTRY(ResizeWindow),\n   748→\tDEFINE_EVENT_ENTRY(LocalResizeWindow),   DEFINE_EVENT_ENTRY(EmbedWindow),\n   749→\tDEFINE_EVENT_ENTRY(PanningChange),       DEFINE_EVENT_ENTRY(ZoomingChange),\n   750→\tDEFINE_EVENT_ENTRY(ErrorInfo),           DEFINE_EVENT_ENTRY(Terminate),\n   751→\tDEFINE_EVENT_ENTRY(ConnectionResult),    DEFINE_EVENT_ENTRY(ChannelConnected),\n   752→\tDEFINE_EVENT_ENTRY(ChannelDisconnected), DEFINE_EVENT_ENTRY(MouseEvent),\n   753→\tDEFINE_EVENT_ENTRY(Activated),           DEFINE_EVENT_ENTRY(Timer),\n   754→\tDEFINE_EVENT_ENTRY(GraphicsReset)\n   755→};\n   756→\n   757→/** Allocator function for a rdp context.\n   758→ *  The function will allocate a rdpRdp structure using rdp_new(), then copy\n   759→ *  its contents to the appropriate fields in the rdp_freerdp structure given in parameters.\n   760→ *  It will also initialize the \'context\' field in the rdp_freerdp structure as needed.\n   761→ *  If the caller has set the ContextNew callback in the \'instance\' parameter, it will be called at\n   762→ * the end of the function.\n   763→ *\n   764→ *  @param instance - Pointer to the rdp_freerdp structure that will be initialized with the new\n   765→ * context.\n   766→ */\n   767→BOOL freerdp_context_new(freerdp* instance)\n   768→{\n   769→\treturn freerdp_context_new_ex(instance, NULL);\n   770→}\n   771→\n   772→BOOL freerdp_context_new_ex(freerdp* instance, rdpSettings* settings)\n   773→{\n   774→\trdpRdp* rdp = NULL;\n   775→\trdpContext* context = NULL;\n   776→\tBOOL ret = TRUE;\n   777→\n   778→\tWINPR_ASSERT(instance);\n   779→\n   780→\tinstance->context = context = (rdpContext*)calloc(1, instance->ContextSize);\n   781→\n   782→\tif (!context)\n   783→\t\treturn FALSE;\n   784→\n   785→\tcontext->log = WLog_Get(TAG);\n   786→\tif (!context->log)\n   787→\t\tgoto fail;\n   788→\n   789→\t/* Set to external settings, prevents rdp_new from creating its own instance */\n   790→\tcontext->settings = settings;\n   791→\tcontext->instance = instance;\n   792→\tcontext->ServerMode = FALSE;\n   793→\tcontext->disconnectUltimatum = 0;\n   794→\n   795→\tcontext->metrics = metrics_new(context);\n   796→\n   797→\tif (!context->metrics)\n   798→\t\tgoto fail;\n   799→\n   800→\trdp = rdp_new(context);\n   801→\n   802→\tif (!rdp)\n   803→\t\tgoto fail;\n   804→\n   805→\tcontext->rdp = rdp;\n   806→\tcontext->pubSub = rdp->pubSub;\n   807→\n   808→\tif (!context->pubSub)\n   809→\t\tgoto fail;\n   810→\n   811→\tPubSub_AddEventTypes(rdp->pubSub, FreeRDP_Events, ARRAYSIZE(FreeRDP_Events));\n   812→\n   813→#if defined(WITH_FREERDP_DEPRECATED)\n   814→\tinstance->input = rdp->input;\n   815→\tinstance->update = rdp->update;\n   816→\tinstance->settings = rdp->settings;\n   817→\tinstance->autodetect = rdp->autodetect;\n   818→#endif\n   819→\n   820→\tinstance->heartbeat = rdp->heartbeat;\n   821→\tcontext->graphics = graphics_new(context);\n   822→\n   823→\tif (!context->graphics)\n   824→\t\tgoto fail;\n   825→\n   826→\tcontext->input = rdp->input;\n   827→\tcontext->update = rdp->update;\n   828→\tcontext->settings = rdp->settings;\n   829→\tcontext->autodetect = rdp->autodetect;\n   830→\n   831→\tif (!(context->errorDescription = calloc(1, 500)))\n   832→\t{\n   833→\t\tWLog_Print(context->log, WLOG_ERROR, "calloc failed!");\n   834→\t\tgoto fail;\n   835→\t}\n   836→\n   837→\tif (!(context->channelErrorEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n   838→\t{\n   839→\t\tWLog_Print(context->log, WLOG_ERROR, "CreateEvent failed!");\n   840→\t\tgoto fail;\n   841→\t}\n   842→\n   843→\tupdate_register_client_callbacks(rdp->update);\n   844→\n   845→\tif (!(context->channels = freerdp_channels_new(instance)))\n   846→\t\tgoto fail;\n   847→\n   848→\tcontext->dump = stream_dump_new();\n   849→\tif (!context->dump)\n   850→\t\tgoto fail;\n   851→\n   852→\tIFCALLRET(instance->ContextNew, ret, instance, context);\n   853→\n   854→\tif (ret)\n   855→\t\treturn TRUE;\n   856→\n   857→fail:\n   858→\tfreerdp_context_free(instance);\n   859→\treturn FALSE;\n   860→}\n   861→\n   862→BOOL freerdp_context_reset(freerdp* instance)\n   863→{\n   864→\tif (!instance)\n   865→\t\treturn FALSE;\n   866→\n   867→\tWINPR_ASSERT(instance->context);\n   868→\trdpRdp* rdp = instance->context->rdp;\n   869→\n   870→\treturn rdp_reset_runtime_settings(rdp);\n   871→}\n   872→\n   873→/** Deallocator function for a rdp context.\n   874→ *  The function will deallocate the resources from the \'instance\' parameter that were allocated\n   875→ * from a call to freerdp_context_new(). If the ContextFree callback is set in the \'instance\'\n   876→ * parameter, it will be called before deallocation occurs.\n   877→ *\n   878→ *  @param instance - Pointer to the rdp_freerdp structure that was initialized by a call to\n   879→ * freerdp_context_new(). On return, the fields associated to the context are invalid.\n   880→ */\n   881→void freerdp_context_free(freerdp* instance)\n   882→{\n   883→\trdpContext* ctx = NULL;\n   884→\n   885→\tif (!instance)\n   886→\t\treturn;\n   887→\n   888→\tif (!instance->context)\n   889→\t\treturn;\n   890→\n   891→\tctx = instance->context;\n   892→\n   893→\tIFCALL(instance->ContextFree, instance, ctx);\n   894→\trdp_free(ctx->rdp);\n   895→\tctx->rdp = NULL;\n   896→\tctx->settings = NULL; /* owned by rdpRdp */\n   897→\n   898→\tgraphics_free(ctx->graphics);\n   899→\tctx->graphics = NULL;\n   900→\n   901→\tmetrics_free(ctx->metrics);\n   902→\tctx->metrics = NULL;\n   903→\n   904→\tif (ctx->channelErrorEvent)\n   905→\t\t(void)CloseHandle(ctx->channelErrorEvent);\n   906→\tctx->channelErrorEvent = NULL;\n   907→\n   908→\tfree(ctx->errorDescription);\n   909→\tctx->errorDescription = NULL;\n   910→\n   911→\tfreerdp_channels_free(ctx->channels);\n   912→\tctx->channels = NULL;\n   913→\n   914→\tfreerdp_client_codecs_free(ctx->codecs);\n   915→\tctx->codecs = NULL;\n   916→\n   917→\tstream_dump_free(ctx->dump);\n   918→\tctx->dump = NULL;\n   919→\n   920→\tctx->input = NULL;      /* owned by rdpRdp */\n   921→\tctx->update = NULL;     /* owned by rdpRdp */\n   922→\tctx->settings = NULL;   /* owned by rdpRdp */\n   923→\tctx->autodetect = NULL; /* owned by rdpRdp */\n   924→\n   925→\tfree(ctx);\n   926→\tinstance->context = NULL;\n   927→#if defined(WITH_FREERDP_DEPRECATED)\n   928→\tinstance->input = NULL;      /* owned by rdpRdp */\n   929→\tinstance->update = NULL;     /* owned by rdpRdp */\n   930→\tinstance->settings = NULL;   /* owned by rdpRdp */\n   931→\tinstance->autodetect = NULL; /* owned by rdpRdp */\n   932→#endif\n   933→\tinstance->heartbeat = NULL; /* owned by rdpRdp */\n   934→}\n   935→\n   936→int freerdp_get_disconnect_ultimatum(rdpContext* context)\n   937→{\n   938→\tWINPR_ASSERT(context);\n   939→\treturn context->disconnectUltimatum;\n   940→}\n   941→\n   942→UINT32 freerdp_error_info(freerdp* instance)\n   943→{\n   944→\tWINPR_ASSERT(instance);\n   945→\tWINPR_ASSERT(instance->context);\n   946→\tWINPR_ASSERT(instance->context->rdp);\n   947→\treturn instance->context->rdp->errorInfo;\n   948→}\n   949→\n   950→void freerdp_set_error_info(rdpRdp* rdp, UINT32 error)\n   951→{\n   952→\tif (!rdp)\n   953→\t\treturn;\n   954→\n   955→\trdp_set_error_info(rdp, error);\n   956→}\n   957→\n   958→BOOL freerdp_send_error_info(rdpRdp* rdp)\n   959→{\n   960→\tif (!rdp)\n   961→\t\treturn FALSE;\n   962→\n   963→\treturn rdp_send_error_info(rdp);\n   964→}\n   965→\n   966→UINT32 freerdp_get_last_error(rdpContext* context)\n   967→{\n   968→\tWINPR_ASSERT(context);\n   969→\treturn context->LastError;\n   970→}\n   971→\n   972→const char* freerdp_get_last_error_name(UINT32 code)\n   973→{\n   974→\tconst char* name = NULL;\n   975→\tconst UINT32 cls = GET_FREERDP_ERROR_CLASS(code);\n   976→\tconst UINT32 type = GET_FREERDP_ERROR_TYPE(code);\n   977→\n   978→\tswitch (cls)\n   979→\t{\n   980→\t\tcase FREERDP_ERROR_ERRBASE_CLASS:\n   981→\t\t\tname = freerdp_get_error_base_name(type);\n   982→\t\t\tbreak;\n   983→\n   984→\t\tcase FREERDP_ERROR_ERRINFO_CLASS:\n   985→\t\t\tname = freerdp_get_error_info_name(type);\n   986→\t\t\tbreak;\n   987→\n   988→\t\tcase FREERDP_ERROR_CONNECT_CLASS:\n   989→\t\t\tname = freerdp_get_error_connect_name(type);\n   990→\t\t\tbreak;\n   991→\n   992→\t\tdefault:\n   993→\t\t\tname = rpc_error_to_string(code);\n   994→\t\t\tbreak;\n   995→\t}\n   996→\n   997→\treturn name;\n   998→}\n   999→\n  1000→const char* freerdp_get_last_error_string(UINT32 code)\n  1001→{\n  1002→\tconst char* string = NULL;\n  1003→\tconst UINT32 cls = GET_FREERDP_ERROR_CLASS(code);\n  1004→\tconst UINT32 type = GET_FREERDP_ERROR_TYPE(code);\n  1005→\n  1006→\tswitch (cls)\n  1007→\t{\n  1008→\t\tcase FREERDP_ERROR_ERRBASE_CLASS:\n  1009→\t\t\tstring = freerdp_get_error_base_string(type);\n  1010→\t\t\tbreak;\n  1011→\n  1012→\t\tcase FREERDP_ERROR_ERRINFO_CLASS:\n  1013→\t\t\tstring = freerdp_get_error_info_string(type);\n  1014→\t\t\tbreak;\n  1015→\n  1016→\t\tcase FREERDP_ERROR_CONNECT_CLASS:\n  1017→\t\t\tstring = freerdp_get_error_connect_string(type);\n  1018→\t\t\tbreak;\n  1019→\n  1020→\t\tdefault:\n  1021→\t\t\tstring = rpc_error_to_string(code);\n  1022→\t\t\tbreak;\n  1023→\t}\n  1024→\n  1025→\treturn string;\n  1026→}\n  1027→\n  1028→const char* freerdp_get_last_error_category(UINT32 code)\n  1029→{\n  1030→\tconst char* string = NULL;\n  1031→\tconst UINT32 cls = GET_FREERDP_ERROR_CLASS(code);\n  1032→\tconst UINT32 type = GET_FREERDP_ERROR_TYPE(code);\n  1033→\n  1034→\tswitch (cls)\n  1035→\t{\n  1036→\t\tcase FREERDP_ERROR_ERRBASE_CLASS:\n  1037→\t\t\tstring = freerdp_get_error_base_category(type);\n  1038→\t\t\tbreak;\n  1039→\n  1040→\t\tcase FREERDP_ERROR_ERRINFO_CLASS:\n  1041→\t\t\tstring = freerdp_get_error_info_category(type);\n  1042→\t\t\tbreak;\n  1043→\n  1044→\t\tcase FREERDP_ERROR_CONNECT_CLASS:\n  1045→\t\t\tstring = freerdp_get_error_connect_category(type);\n  1046→\t\t\tbreak;\n  1047→\n  1048→\t\tdefault:\n  1049→\t\t\tstring = rpc_error_to_category(code);\n  1050→\t\t\tbreak;\n  1051→\t}\n  1052→\n  1053→\treturn string;\n  1054→}\n  1055→\n  1056→void freerdp_set_last_error_ex(rdpContext* context, UINT32 lastError, const char* fkt,\n  1057→                               const char* file, int line)\n  1058→{\n  1059→\tWINPR_ASSERT(context);\n  1060→\tWINPR_ASSERT(line >= 0);\n  1061→\n  1062→\tif (lastError)\n  1063→\t{\n  1064→\t\tif (WLog_IsLevelActive(context->log, WLOG_ERROR))\n  1065→\t\t{\n  1066→\t\t\tWLog_PrintMessage(context->log, WLOG_MESSAGE_TEXT, WLOG_ERROR, (size_t)line, file, fkt,\n  1067→\t\t\t                  "%s [0x%08" PRIX32 "]", freerdp_get_last_error_name(lastError),\n  1068→\t\t\t                  lastError);\n  1069→\t\t}\n  1070→\t}\n  1071→\n  1072→\tif (lastError == FREERDP_ERROR_SUCCESS)\n  1073→\t{\n  1074→\t\tif (WLog_IsLevelActive(context->log, WLOG_DEBUG))\n  1075→\t\t\tWLog_PrintMessage(context->log, WLOG_MESSAGE_TEXT, WLOG_DEBUG, (size_t)line, file, fkt,\n  1076→\t\t\t                  "resetting error state");\n  1077→\t}\n  1078→\telse if (context->LastError != FREERDP_ERROR_SUCCESS)\n  1079→\t{\n  1080→\t\tif (WLog_IsLevelActive(context->log, WLOG_ERROR))\n  1081→\t\t{\n  1082→\t\t\tWLog_PrintMessage(context->log, WLOG_MESSAGE_TEXT, WLOG_ERROR, (size_t)line, file, fkt,\n  1083→\t\t\t                  "TODO: Trying to set error code %s, but %s already set!",\n  1084→\t\t\t                  freerdp_get_last_error_name(lastError),\n  1085→\t\t\t                  freerdp_get_last_error_name(context->LastError));\n  1086→\t\t}\n  1087→\t}\n  1088→\tcontext->LastError = lastError;\n  1089→}\n  1090→\n  1091→const char* freerdp_get_logon_error_info_type_ex(UINT32 type, char* buffer, size_t size)\n  1092→{\n  1093→\tconst char* str = freerdp_get_logon_error_info_type(type);\n  1094→\t(void)_snprintf(buffer, size, "%s(0x%04" PRIx32 ")", str, type);\n  1095→\treturn buffer;\n  1096→}\n  1097→\n  1098→const char* freerdp_get_logon_error_info_type(UINT32 type)\n  1099→{\n  1100→\tswitch (type)\n  1101→\t{\n  1102→\t\tcase LOGON_MSG_DISCONNECT_REFUSED:\n  1103→\t\t\treturn "LOGON_MSG_DISCONNECT_REFUSED";\n  1104→\n  1105→\t\tcase LOGON_MSG_NO_PERMISSION:\n  1106→\t\t\treturn "LOGON_MSG_NO_PERMISSION";\n  1107→\n  1108→\t\tcase LOGON_MSG_BUMP_OPTIONS:\n  1109→\t\t\treturn "LOGON_MSG_BUMP_OPTIONS";\n  1110→\n  1111→\t\tcase LOGON_MSG_RECONNECT_OPTIONS:\n  1112→\t\t\treturn "LOGON_MSG_RECONNECT_OPTIONS";\n  1113→\n  1114→\t\tcase LOGON_MSG_SESSION_TERMINATE:\n  1115→\t\t\treturn "LOGON_MSG_SESSION_TERMINATE";\n  1116→\n  1117→\t\tcase LOGON_MSG_SESSION_CONTINUE:\n  1118→\t\t\treturn "LOGON_MSG_SESSION_CONTINUE";\n  1119→\n  1120→\t\tdefault:\n  1121→\t\t\treturn "UNKNOWN";\n  1122→\t}\n  1123→}\n  1124→\n  1125→const char* freerdp_get_logon_error_info_data(UINT32 data)\n  1126→{\n  1127→\tswitch (data)\n  1128→\t{\n  1129→\t\tcase LOGON_FAILED_BAD_PASSWORD:\n  1130→\t\t\treturn "LOGON_FAILED_BAD_PASSWORD";\n  1131→\n  1132→\t\tcase LOGON_FAILED_UPDATE_PASSWORD:\n  1133→\t\t\treturn "LOGON_FAILED_UPDATE_PASSWORD";\n  1134→\n  1135→\t\tcase LOGON_FAILED_OTHER:\n  1136→\t\t\treturn "LOGON_FAILED_OTHER";\n  1137→\n  1138→\t\tcase LOGON_WARNING:\n  1139→\t\t\treturn "LOGON_WARNING";\n  1140→\n  1141→\t\tdefault:\n  1142→\t\t\treturn "SESSION_ID";\n  1143→\t}\n  1144→}\n  1145→\n  1146→const char* freerdp_get_logon_error_info_data_ex(UINT32 data, char* buffer, size_t size)\n  1147→{\n  1148→\tconst char* str = freerdp_get_logon_error_info_data(data);\n  1149→\t(void)_snprintf(buffer, size, "%s(0x%04" PRIx32 ")", str, data);\n  1150→\treturn buffer;\n  1151→}\n  1152→\n  1153→/** Allocator function for the rdp_freerdp structure.\n  1154→ *  @return an allocated structure filled with 0s. Need to be deallocated using freerdp_free()\n  1155→ */\n  1156→freerdp* freerdp_new(void)\n  1157→{\n  1158→\tfreerdp* instance = NULL;\n  1159→\tinstance = (freerdp*)calloc(1, sizeof(freerdp));\n  1160→\n  1161→\tif (!instance)\n  1162→\t\treturn NULL;\n  1163→\n  1164→\tinstance->ContextSize = sizeof(rdpContext);\n  1165→\tinstance->SendChannelData = freerdp_send_channel_data;\n  1166→\tinstance->SendChannelPacket = freerdp_send_channel_packet;\n  1167→\tinstance->ReceiveChannelData = freerdp_channels_data;\n  1168→\treturn instance;\n  1169→}\n  1170→\n  1171→/** Deallocator function for the rdp_freerdp structure.\n  1172→ *  @param instance - pointer to the rdp_freerdp structure to deallocate.\n  1173→ *                    On return, this pointer is not valid anymore.\n  1174→ */\n  1175→void freerdp_free(freerdp* instance)\n  1176→{\n  1177→\tfree(instance);\n  1178→}\n  1179→\n  1180→ULONG freerdp_get_transport_sent(rdpContext* context, BOOL resetCount)\n  1181→{\n  1182→\tWINPR_ASSERT(context);\n  1183→\tWINPR_ASSERT(context->rdp);\n  1184→\treturn transport_get_bytes_sent(context->rdp->transport, resetCount);\n  1185→}\n  1186→\n  1187→BOOL freerdp_nla_impersonate(rdpContext* context)\n  1188→{\n  1189→\trdpNla* nla = NULL;\n  1190→\n  1191→\tif (!context)\n  1192→\t\treturn FALSE;\n  1193→\n  1194→\tif (!context->rdp)\n  1195→\t\treturn FALSE;\n  1196→\n  1197→\tif (!context->rdp->transport)\n  1198→\t\treturn FALSE;\n  1199→\n  1200→\tnla = transport_get_nla(context->rdp->transport);\n  1201→\treturn nla_impersonate(nla);\n  1202→}\n  1203→\n  1204→BOOL freerdp_nla_revert_to_self(rdpContext* context)\n  1205→{\n  1206→\trdpNla* nla = NULL;\n  1207→\n  1208→\tif (!context)\n  1209→\t\treturn FALSE;\n  1210→\n  1211→\tif (!context->rdp)\n  1212→\t\treturn FALSE;\n  1213→\n  1214→\tif (!context->rdp->transport)\n  1215→\t\treturn FALSE;\n  1216→\n  1217→\tnla = transport_get_nla(context->rdp->transport);\n  1218→\treturn nla_revert_to_self(nla);\n  1219→}\n  1220→\n  1221→UINT32 freerdp_get_nla_sspi_error(rdpContext* context)\n  1222→{\n  1223→\tWINPR_ASSERT(context);\n  1224→\tWINPR_ASSERT(context->rdp);\n  1225→\tWINPR_ASSERT(context->rdp->transport);\n  1226→\n  1227→\trdpNla* nla = transport_get_nla(context->rdp->transport);\n  1228→\n  1229→\treturn (UINT32)nla_get_sspi_error(nla);\n  1230→}\n  1231→\n  1232→BOOL freerdp_nla_encrypt(rdpContext* context, const SecBuffer* inBuffer, SecBuffer* outBuffer)\n  1233→{\n  1234→\tWINPR_ASSERT(context);\n  1235→\tWINPR_ASSERT(context->rdp);\n  1236→\n  1237→\trdpNla* nla = context->rdp->nla;\n  1238→\treturn nla_encrypt(nla, inBuffer, outBuffer);\n  1239→}\n  1240→\n  1241→BOOL freerdp_nla_decrypt(rdpContext* context, const SecBuffer* inBuffer, SecBuffer* outBuffer)\n  1242→{\n  1243→\tWINPR_ASSERT(context);\n  1244→\tWINPR_ASSERT(context->rdp);\n  1245→\n  1246→\trdpNla* nla = context->rdp->nla;\n  1247→\treturn nla_decrypt(nla, inBuffer, outBuffer);\n  1248→}\n  1249→\n  1250→SECURITY_STATUS freerdp_nla_QueryContextAttributes(rdpContext* context, DWORD ulAttr, PVOID pBuffer)\n  1251→{\n  1252→\tWINPR_ASSERT(context);\n  1253→\tWINPR_ASSERT(context->rdp);\n  1254→\n  1255→\treturn nla_QueryContextAttributes(context->rdp->nla, ulAttr, pBuffer);\n  1256→}\n  1257→\n  1258→HANDLE getChannelErrorEventHandle(rdpContext* context)\n  1259→{\n  1260→\tWINPR_ASSERT(context);\n  1261→\treturn context->channelErrorEvent;\n  1262→}\n  1263→\n  1264→BOOL checkChannelErrorEvent(rdpContext* context)\n  1265→{\n  1266→\tWINPR_ASSERT(context);\n  1267→\n  1268→\tif (WaitForSingleObject(context->channelErrorEvent, 0) == WAIT_OBJECT_0)\n  1269→\t{\n  1270→\t\tWLog_Print(context->log, WLOG_ERROR, "%s. Error was %" PRIu32 "", context->errorDescription,\n  1271→\t\t           context->channelErrorNum);\n  1272→\t\treturn FALSE;\n  1273→\t}\n  1274→\n  1275→\treturn TRUE;\n  1276→}\n  1277→\n  1278→/**\n  1279→ * Function description\n  1280→ *\n  1281→ * @return 0 on success, otherwise a Win32 error code\n  1282→ */\n  1283→UINT getChannelError(rdpContext* context)\n  1284→{\n  1285→\tWINPR_ASSERT(context);\n  1286→\treturn context->channelErrorNum;\n  1287→}\n  1288→\n  1289→const char* getChannelErrorDescription(rdpContext* context)\n  1290→{\n  1291→\tWINPR_ASSERT(context);\n  1292→\treturn context->errorDescription;\n  1293→}\n  1294→\n  1295→void clearChannelError(rdpContext* context)\n  1296→{\n  1297→\tWINPR_ASSERT(context);\n  1298→\tcontext->channelErrorNum = 0;\n  1299→\tmemset(context->errorDescription, 0, 500);\n  1300→\t(void)ResetEvent(context->channelErrorEvent);\n  1301→}\n  1302→\n  1303→WINPR_ATTR_FORMAT_ARG(3, 4)\n  1304→void setChannelError(rdpContext* context, UINT errorNum, WINPR_FORMAT_ARG const char* format, ...)\n  1305→{\n  1306→\tva_list ap = { 0 };\n  1307→\tva_start(ap, format);\n  1308→\n  1309→\tWINPR_ASSERT(context);\n  1310→\n  1311→\tcontext->channelErrorNum = errorNum;\n  1312→\t(void)vsnprintf(context->errorDescription, 499, format, ap);\n  1313→\tva_end(ap);\n  1314→\t(void)SetEvent(context->channelErrorEvent);\n  1315→}\n  1316→\n  1317→const char* freerdp_nego_get_routing_token(rdpContext* context, DWORD* length)\n  1318→{\n  1319→\tif (!context || !context->rdp)\n  1320→\t\treturn NULL;\n  1321→\n  1322→\treturn (const char*)nego_get_routing_token(context->rdp->nego, length);\n  1323→}\n  1324→\n  1325→BOOL freerdp_io_callback_set_event(rdpContext* context, BOOL set)\n  1326→{\n  1327→\tWINPR_ASSERT(context);\n  1328→\treturn rdp_io_callback_set_event(context->rdp, set);\n  1329→}\n  1330→\n  1331→const rdpTransportIo* freerdp_get_io_callbacks(rdpContext* context)\n  1332→{\n  1333→\tWINPR_ASSERT(context);\n  1334→\treturn rdp_get_io_callbacks(context->rdp);\n  1335→}\n  1336→\n  1337→BOOL freerdp_set_io_callbacks(rdpContext* context, const rdpTransportIo* io_callbacks)\n  1338→{\n  1339→\tWINPR_ASSERT(context);\n  1340→\treturn rdp_set_io_callbacks(context->rdp, io_callbacks);\n  1341→}\n  1342→\n  1343→BOOL freerdp_set_io_callback_context(rdpContext* context, void* usercontext)\n  1344→{\n  1345→\tWINPR_ASSERT(context);\n  1346→\treturn rdp_set_io_callback_context(context->rdp, usercontext);\n  1347→}\n  1348→\n  1349→void* freerdp_get_io_callback_context(rdpContext* context)\n  1350→{\n  1351→\tWINPR_ASSERT(context);\n  1352→\treturn rdp_get_io_callback_context(context->rdp);\n  1353→}\n  1354→\n  1355→CONNECTION_STATE freerdp_get_state(const rdpContext* context)\n  1356→{\n  1357→\tWINPR_ASSERT(context);\n  1358→\treturn rdp_get_state(context->rdp);\n  1359→}\n  1360→\n  1361→const char* freerdp_state_string(CONNECTION_STATE state)\n  1362→{\n  1363→\treturn rdp_state_string(state);\n  1364→}\n  1365→\n  1366→BOOL freerdp_is_active_state(const rdpContext* context)\n  1367→{\n  1368→\tWINPR_ASSERT(context);\n  1369→\treturn rdp_is_active_state(context->rdp);\n  1370→}\n  1371→\n  1372→BOOL freerdp_channels_from_mcs(rdpSettings* settings, const rdpContext* context)\n  1373→{\n  1374→\tWINPR_ASSERT(context);\n  1375→\treturn rdp_channels_from_mcs(settings, context->rdp);\n  1376→}\n  1377→\n  1378→HANDLE freerdp_abort_event(rdpContext* context)\n  1379→{\n  1380→\tWINPR_ASSERT(context);\n  1381→\treturn utils_get_abort_event(context->rdp);\n  1382→}\n  1383→\n  1384→static void test_mcs_free(rdpMcs* mcs)\n  1385→{\n  1386→\tif (!mcs)\n  1387→\t\treturn;\n  1388→\n  1389→\trdpTransport* transport = mcs->transport;\n  1390→\trdpContext* context = transport_get_context(transport);\n  1391→\tif (context)\n  1392→\t{\n  1393→\t\trdpSettings* settings = context->settings;\n  1394→\t\tfreerdp_settings_free(settings);\n  1395→\t}\n  1396→\tfree(context);\n  1397→\ttransport_free(transport);\n  1398→\n  1399→\tmcs_free(mcs);\n  1400→}\n  1401→\n  1402→static rdpMcs* test_mcs_new(void)\n  1403→{\n  1404→\trdpTransport* transport = NULL;\n  1405→\trdpSettings* settings = freerdp_settings_new(0);\n  1406→\trdpContext* context = calloc(1, sizeof(rdpContext));\n  1407→\n  1408→\tif (!settings)\n  1409→\t\tgoto fail;\n  1410→\tif (!freerdp_settings_set_bool(settings, FreeRDP_TransportDumpReplay, TRUE))\n  1411→\t\tgoto fail;\n  1412→\n  1413→\tif (!context)\n  1414→\t\tgoto fail;\n  1415→\tcontext->settings = settings;\n  1416→\ttransport = transport_new(context);\n  1417→\tif (!transport)\n  1418→\t\tgoto fail;\n  1419→\treturn mcs_new(transport);\n  1420→\n  1421→fail:\n  1422→\ttransport_free(transport);\n  1423→\tfree(context);\n  1424→\tfreerdp_settings_free(settings);\n  1425→\n  1426→\treturn NULL;\n  1427→}\n  1428→\n  1429→BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n  1430→{\n  1431→\n  1432→\twStream sbuffer = { 0 };\n  1433→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1434→\n  1435→\tWINPR_ASSERT(data || (size == 0));\n  1436→\tWINPR_ASSERT(s);\n  1437→\n  1438→\trdpMcs* mcs = test_mcs_new();\n  1439→\tWINPR_ASSERT(mcs);\n  1440→\n  1441→\tBOOL result = mcs_recv_connect_initial(mcs, s);\n  1442→\ttest_mcs_free(mcs);\n  1443→\treturn result;\n  1444→}\n  1445→\n  1446→BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n  1447→{\n  1448→\n  1449→\twStream sbuffer = { 0 };\n  1450→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1451→\n  1452→\tWINPR_ASSERT(data || (size == 0));\n  1453→\tWINPR_ASSERT(s);\n  1454→\n  1455→\trdpMcs* mcs = test_mcs_new();\n  1456→\tWINPR_ASSERT(mcs);\n  1457→\n  1458→\tBOOL result = mcs_recv_connect_response(mcs, s);\n  1459→\ttest_mcs_free(mcs);\n  1460→\treturn result;\n  1461→}\n  1462→\n  1463→BOOL freerdp_persist_credentials(rdpContext* context)\n  1464→{\n  1465→\tif (!context)\n  1466→\t\treturn FALSE;\n  1467→\tWINPR_ASSERT(context->rdp);\n  1468→\treturn utils_persist_credentials(context->rdp->originalSettings, context->rdp->settings);\n  1469→}\n  1470→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 25: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="Now I can see the issue. Looking at the crash log and the code:\n\n1. The crash occurs at line 1458 in `freerdp.c` in the function `freerdp_is_valid_mcs_create_response`\n2. The function calls `mcs_recv_connect_response(mcs, s)` at line 1458\n3. The issue is that `test_mcs_new()` can return NULL if allocation fails, but `freerdp_is_valid_mcs_create_response` doesn't check if `mcs` is NULL before using it\n\nLet me check the `test_mcs_new()` function more carefully. Looking at lines 1402-1427, I can see that `test_mcs_new()` can indeed return NULL if any allocation fails (line 1426).\n\nThe bug is that at line 1455, we assert `mcs` is not NULL, but if it is NULL, the ASSERT will be a no-op in release builds, and then line 1458 will try to dereference the NULL pointer causing the crash.\n\nThe same issue exists in `freerdp_is_valid_mcs_create_request` at lines 1438-1443.\n\nLet me create a patch to fix both functions:")], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 26: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01CNaG52amRbweZuvPzPA1RJ', name='Edit', input={'file_path': '/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c', 'old_string': 'BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}', 'new_string': 'BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tif (!mcs)\n\t\treturn FALSE;\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 27: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01CNaG52amRbweZuvPzPA1RJ', content="The file /home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1425→\n  1426→\treturn NULL;\n  1427→}\n  1428→\n  1429→BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n  1430→{\n  1431→\n  1432→\twStream sbuffer = { 0 };\n  1433→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1434→\n  1435→\tWINPR_ASSERT(data || (size == 0));\n  1436→\tWINPR_ASSERT(s);\n  1437→\n  1438→\trdpMcs* mcs = test_mcs_new();\n  1439→\tif (!mcs)\n  1440→\t\treturn FALSE;\n  1441→\n  1442→\tBOOL result = mcs_recv_connect_initial(mcs, s);\n  1443→\ttest_mcs_free(mcs);\n  1444→\treturn result;\n  1445→}\n  1446→\n  1447→BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n  1448→{\n  1449→", is_error=None)], parent_tool_use_id=None)

================================================================================
Message 28: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_011tKoq7af8FkPVNmsc4NV2L', name='Edit', input={'file_path': '/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c', 'old_string': 'BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_response(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}', 'new_string': 'BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tif (!mcs)\n\t\treturn FALSE;\n\n\tBOOL result = mcs_recv_connect_response(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}'})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 29: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_011tKoq7af8FkPVNmsc4NV2L', content="The file /home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1443→\ttest_mcs_free(mcs);\n  1444→\treturn result;\n  1445→}\n  1446→\n  1447→BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n  1448→{\n  1449→\n  1450→\twStream sbuffer = { 0 };\n  1451→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1452→\n  1453→\tWINPR_ASSERT(data || (size == 0));\n  1454→\tWINPR_ASSERT(s);\n  1455→\n  1456→\trdpMcs* mcs = test_mcs_new();\n  1457→\tif (!mcs)\n  1458→\t\treturn FALSE;\n  1459→\n  1460→\tBOOL result = mcs_recv_connect_response(mcs, s);\n  1461→\ttest_mcs_free(mcs);\n  1462→\treturn result;\n  1463→}\n  1464→\n  1465→BOOL freerdp_persist_credentials(rdpContext* context)\n  1466→{\n  1467→\tif (!context)", is_error=None)], parent_tool_use_id=None)

================================================================================
Message 30: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Perfect! Now let me verify the changes by reading the modified sections:')], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 31: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01GDV5Jdssio6LCLnMLgQFiv', name='Read', input={'file_path': '/home/user/aixcc/crete/.cache/official-afc-freerdp/libfreerdp/core/freerdp.c', 'offset': 1429, 'limit': 35})], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 32: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01GDV5Jdssio6LCLnMLgQFiv', content='  1429→BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n  1430→{\n  1431→\n  1432→\twStream sbuffer = { 0 };\n  1433→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1434→\n  1435→\tWINPR_ASSERT(data || (size == 0));\n  1436→\tWINPR_ASSERT(s);\n  1437→\n  1438→\trdpMcs* mcs = test_mcs_new();\n  1439→\tif (!mcs)\n  1440→\t\treturn FALSE;\n  1441→\n  1442→\tBOOL result = mcs_recv_connect_initial(mcs, s);\n  1443→\ttest_mcs_free(mcs);\n  1444→\treturn result;\n  1445→}\n  1446→\n  1447→BOOL freerdp_is_valid_mcs_create_response(const BYTE* data, size_t size)\n  1448→{\n  1449→\n  1450→\twStream sbuffer = { 0 };\n  1451→\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n  1452→\n  1453→\tWINPR_ASSERT(data || (size == 0));\n  1454→\tWINPR_ASSERT(s);\n  1455→\n  1456→\trdpMcs* mcs = test_mcs_new();\n  1457→\tif (!mcs)\n  1458→\t\treturn FALSE;\n  1459→\n  1460→\tBOOL result = mcs_recv_connect_response(mcs, s);\n  1461→\ttest_mcs_free(mcs);\n  1462→\treturn result;\n  1463→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 33: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="Excellent! The patch has been successfully applied. Let me create a summary of the changes:\n\n## Summary\n\nI've successfully fixed the **AddressSanitizer SEGV (null-deref)** bug in the FreeRDP code. \n\n### Root Cause\nThe crash occurred in `freerdp_is_valid_mcs_create_response()` at line 1458 of `/libfreerdp/core/freerdp.c`. The function called `test_mcs_new()` which could return `NULL` if memory allocation failed, but the code only had a `WINPR_ASSERT(mcs)` check. In release builds, this assertion is a no-op, allowing the NULL pointer to be dereferenced at line 1458 when calling `mcs_recv_connect_response(mcs, s)`.\n\n### Fix Applied\nI replaced the `WINPR_ASSERT(mcs)` with a proper NULL check in both affected functions:\n\n1. **`freerdp_is_valid_mcs_create_request()`** (lines 1439-1440)\n2. **`freerdp_is_valid_mcs_create_response()`** (lines 1457-1458)\n\nBoth functions now check if `mcs` is NULL and return `FALSE` early instead of attempting to dereference the NULL pointer.\n\n### Changes Made\n```c\n// Before:\nrdpMcs* mcs = test_mcs_new();\nWINPR_ASSERT(mcs);\nBOOL result = mcs_recv_connect_response(mcs, s);  // NULL deref here!\n\n// After:\nrdpMcs* mcs = test_mcs_new();\nif (!mcs)\n    return FALSE;\nBOOL result = mcs_recv_connect_response(mcs, s);  // Safe now\n```\n\nThis fix prevents the null pointer dereference and allows the fuzzer to continue testing without crashing on allocation failures.")], model='claude-sonnet-4-5-20250929', parent_tool_use_id=None)

================================================================================
Message 34: ResultMessage
================================================================================
ResultMessage(subtype='success', duration_ms=92845, duration_api_ms=77847, is_error=False, num_turns=14, session_id='bb99771a-92ae-4b92-9e47-16ce075647b9', total_cost_usd=0.22821369999999996, usage={'input_tokens': 1713, 'cache_creation_input_tokens': 27352, 'cache_read_input_tokens': 229069, 'output_tokens': 2644, 'server_tool_use': {'web_search_requests': 0, 'web_fetch_requests': 0}, 'service_tier': 'standard', 'cache_creation': {'ephemeral_1h_input_tokens': 0, 'ephemeral_5m_input_tokens': 27352}}, result="Excellent! The patch has been successfully applied. Let me create a summary of the changes:\n\n## Summary\n\nI've successfully fixed the **AddressSanitizer SEGV (null-deref)** bug in the FreeRDP code. \n\n### Root Cause\nThe crash occurred in `freerdp_is_valid_mcs_create_response()` at line 1458 of `/libfreerdp/core/freerdp.c`. The function called `test_mcs_new()` which could return `NULL` if memory allocation failed, but the code only had a `WINPR_ASSERT(mcs)` check. In release builds, this assertion is a no-op, allowing the NULL pointer to be dereferenced at line 1458 when calling `mcs_recv_connect_response(mcs, s)`.\n\n### Fix Applied\nI replaced the `WINPR_ASSERT(mcs)` with a proper NULL check in both affected functions:\n\n1. **`freerdp_is_valid_mcs_create_request()`** (lines 1439-1440)\n2. **`freerdp_is_valid_mcs_create_response()`** (lines 1457-1458)\n\nBoth functions now check if `mcs` is NULL and return `FALSE` early instead of attempting to dereference the NULL pointer.\n\n### Changes Made\n```c\n// Before:\nrdpMcs* mcs = test_mcs_new();\nWINPR_ASSERT(mcs);\nBOOL result = mcs_recv_connect_response(mcs, s);  // NULL deref here!\n\n// After:\nrdpMcs* mcs = test_mcs_new();\nif (!mcs)\n    return FALSE;\nBOOL result = mcs_recv_connect_response(mcs, s);  // Safe now\n```\n\nThis fix prevents the null pointer dereference and allows the fuzzer to continue testing without crashing on allocation failures.")
