
================================================================================
Message 0: SystemMessage
================================================================================
SystemMessage(subtype='init', data={'type': 'system', 'subtype': 'init', 'cwd': '/home/user/crete/.cache/official-afc-wireshark', 'session_id': 'e3ee9f66-d216-4ba4-a879-2ca3b41cbc40', 'tools': ['Task', 'Bash', 'Glob', 'Grep', 'ExitPlanMode', 'Read', 'Edit', 'Write', 'NotebookEdit', 'WebFetch', 'TodoWrite', 'WebSearch', 'BashOutput', 'KillShell', 'Skill', 'SlashCommand', 'EnterPlanMode'], 'mcp_servers': [], 'model': 'claude-opus-4-5-20251101', 'permissionMode': 'bypassPermissions', 'slash_commands': ['compact', 'context', 'cost', 'init', 'pr-comments', 'release-notes', 'todos', 'review', 'security-review'], 'apiKeySource': 'none', 'claude_code_version': '2.0.53', 'output_style': 'default', 'agents': ['general-purpose', 'statusline-setup', 'Explore', 'Plan'], 'skills': [], 'plugins': [], 'uuid': '0839d8f5-0626-45ef-ab10-b63907b45ee3'})

================================================================================
Message 1: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01G9dUV4f4wUxDazbbsPNhyt', name='Read', input={'file_path': '/src/wireshark/epan/dissectors/packet-irc.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 2: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01G9dUV4f4wUxDazbbsPNhyt', content='<tool_use_error>File does not exist.</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 3: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Let me search for the packet-irc.c file in the workspace:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 4: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01251mid8mSeaTG2tZzo94hG', name='Glob', input={'pattern': '**/packet-irc.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 5: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01251mid8mSeaTG2tZzo94hG', content='/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 6: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_016FA11YTNSYxWKkr5wBdfKE', name='Read', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 7: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_016FA11YTNSYxWKkr5wBdfKE', content='     1→/* packet-irc.c\n     2→ *\n     3→ * Wireshark - Network traffic analyzer\n     4→ * By Gerald Combs <gerald@wireshark.org>\n     5→ * Copyright 1998 Gerald Combs\n     6→ *\n     7→ * Copied from packet-tftp.c\n     8→ *\n     9→ * SPDX-License-Identifier: GPL-2.0-or-later\n    10→ */\n    11→\n    12→/*\n    13→ * Routines for IRC packet dissection\n    14→ *\n    15→ * See\n    16→ *\n    17→ *  http://www.irchelp.org/irchelp/rfc/\n    18→ *\n    19→ * and the RFCs and other documents it mentions, such as RFC 1459, RFCs\n    20→ * 2810, 2811, 2812, and 2813,\n    21→ *\n    22→ * For CTCP, see :\n    23→ *  http://www.irchelp.org/irchelp/rfc/ctcpspec.html\n    24→ *  http://web.archive.org/web/20031203073050/http://www.invlogic.com/irc/ctcp.html\n    25→ *  https://www.ietf.org/archive/id/draft-oakley-irc-ctcp-02.txt\n    26→ */\n    27→\n    28→ #include "config.h"\n    29→\n    30→ #include <epan/packet.h>\n    31→ #include <epan/expert.h>\n    32→ #include <wsutil/array.h>\n    33→ \n    34→ void proto_register_irc(void);\n    35→ void proto_reg_handoff_irc(void);\n    36→ \n    37→ static int proto_irc;\n    38→ static int proto_irc_ctcp;\n    39→ static int hf_irc_request;\n    40→ static int hf_irc_request_prefix;\n    41→ static int hf_irc_request_command;\n    42→ static int hf_irc_request_command_pass;\n    43→ static int hf_irc_request_command_pass_password;\n    44→ static int hf_irc_request_command_nick;\n    45→ static int hf_irc_request_command_nick_nick;\n    46→ static int hf_irc_request_command_user;\n    47→ static int hf_irc_request_command_user_user;\n    48→ static int hf_irc_request_command_user_host;\n    49→ static int hf_irc_request_command_user_server;\n    50→ static int hf_irc_request_command_user_real;\n    51→ static int hf_irc_request_command_ping;\n    52→ static int hf_irc_request_command_ping_server;\n    53→ static int hf_irc_request_command_pong;\n    54→ static int hf_irc_request_command_pong_server;\n    55→ static int hf_irc_request_command_quit;\n    56→ static int hf_irc_request_command_quit_message;\n    57→ static int hf_irc_request_command_join;\n    58→ static int hf_irc_request_command_join_channel;\n    59→ static int hf_irc_request_command_part;\n    60→ static int hf_irc_request_command_part_channel;\n    61→ static int hf_irc_request_command_part_message;\n    62→ static int hf_irc_request_command_privmsg;\n    63→ static int hf_irc_request_command_privmsg_target;\n    64→ static int hf_irc_request_command_privmsg_message;\n    65→ static int hf_irc_request_command_notice;\n    66→ static int hf_irc_request_command_notice_target;\n    67→ static int hf_irc_request_command_notice_message;\n    68→ static int hf_irc_request_command_mode;\n    69→ static int hf_irc_request_command_topic;\n    70→ static int hf_irc_request_command_topic_target;\n    71→ static int hf_irc_request_command_topic_topic;\n    72→ static int hf_irc_request_command_names;\n    73→ static int hf_irc_request_command_names_channel;\n    74→ static int hf_irc_request_command_list;\n    75→ static int hf_irc_request_command_list_channel;\n    76→ static int hf_irc_request_command_who;\n    77→ static int hf_irc_request_command_whois;\n    78→ static int hf_irc_request_command_whois_name;\n    79→ static int hf_irc_request_command_whowas;\n    80→ static int hf_irc_request_command_invite;\n    81→ static int hf_irc_request_command_kick;\n    82→ static int hf_irc_request_command_away;\n    83→ static int hf_irc_request_command_ison;\n    84→ static int hf_irc_request_command_time;\n    85→ static int hf_irc_request_command_motd;\n    86→ static int hf_irc_request_command_version;\n    87→ static int hf_irc_request_command_stats;\n    88→ static int hf_irc_request_command_links;\n    89→ static int hf_irc_request_command_param;\n    90→ static int hf_irc_request_command_trace;\n    91→ static int hf_irc_request_command_admin;\n    92→ static int hf_irc_request_command_info;\n    93→ static int hf_irc_request_trailer;\n    94→ static int hf_irc_response;\n    95→ static int hf_irc_response_prefix;\n    96→ static int hf_irc_response_command;\n    97→ static int hf_irc_response_num_command;\n    98→ static int hf_irc_response_command_param;\n    99→ static int hf_irc_response_trailer;\n   100→ //static int hf_irc_ctcp;\n   101→ static int hf_irc_ctcp_command;\n   102→ static int hf_irc_ctcp_params;\n   103→ \n   104→ static int ett_irc;\n   105→ static int ett_irc_request;\n   106→ static int ett_irc_request_command;\n   107→ static int ett_irc_request_command_pass;\n   108→ static int ett_irc_request_command_nick;\n   109→ static int ett_irc_request_command_user;\n   110→ static int ett_irc_request_command_ping;\n   111→ static int ett_irc_request_command_pong;\n   112→ static int ett_irc_request_command_quit;\n   113→ static int ett_irc_request_command_join;\n   114→ static int ett_irc_request_command_part;\n   115→ static int ett_irc_request_command_privmsg;\n   116→ static int ett_irc_request_command_notice;\n   117→ static int ett_irc_request_command_topic;\n   118→ static int ett_irc_request_command_names;\n   119→ static int ett_irc_request_command_list;\n   120→ static int ett_irc_request_command_whois;\n   121→ static int ett_irc_response;\n   122→ static int ett_irc_response_command;\n   123→ \n   124→ static expert_field ei_irc_missing_end_delimiter;\n   125→ static expert_field ei_irc_numeric_request_command;\n   126→ static expert_field ei_irc_response_command;\n   127→ static expert_field ei_irc_prefix_missing_ending_space;\n   128→ static expert_field ei_irc_request_command;\n   129→ static expert_field ei_irc_tag_data_invalid;\n   130→ \n   131→ /* This must be a null-terminated string */\n   132→ static const uint8_t TAG_DELIMITER[] = {0x01, 0x00};\n   133→ /* patterns used for tvb_ws_mempbrk_pattern_uint8 */\n   134→ static ws_mempbrk_pattern pbrk_tag_delimiter;\n   135→ \n   136→ static dissector_handle_t ctcp_handle;\n   137→ \n   138→ #define TCP_PORT_RANGE          "6667,57000" /* Not IANA registered */\n   139→ #define CHANNELLEN              50\n   140→ \n   141→ static int\n   142→ dissect_irc_ctcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n   143→ {\n   144→     proto_tree   *ctcp_tree;\n   145→     proto_item   *ti;\n   146→     const uint8_t *str_command, *str_params;\n   147→     int          space_offset = -1;\n   148→ \n   149→     ti = proto_tree_add_item(tree, proto_irc, tvb, 0, -1, ENC_ASCII|ENC_NA);\n   150→     ctcp_tree = proto_item_add_subtree(ti, ett_irc);\n   151→ \n   152→     space_offset = tvb_find_uint8(tvb, 1, -1, \' \');\n   153→     if (space_offset == -1) {\n   154→         proto_tree_add_item_ret_string(ctcp_tree, hf_irc_ctcp_command, tvb, 0, tvb_reported_length(tvb), ENC_ASCII|ENC_NA, pinfo->pool, &str_command);\n   155→     }\n   156→     else {\n   157→         proto_tree_add_item_ret_string(ctcp_tree, hf_irc_ctcp_command, tvb, 0, space_offset, ENC_ASCII|ENC_NA, pinfo->pool, &str_command);\n   158→         proto_tree_add_item_ret_string(ctcp_tree, hf_irc_ctcp_params, tvb, space_offset+1, tvb_reported_length(tvb)-space_offset-1, ENC_ASCII|ENC_NA, pinfo->pool, &str_params);\n   159→     }\n   160→ \n   161→     return tvb_captured_length(tvb);\n   162→ }\n   163→ \n   164→ static void\n   165→ dissect_irc_tag_data(proto_tree *tree, proto_item *item, tvbuff_t *tvb, int offset, int datalen, packet_info *pinfo, const uint8_t* command)\n   166→ {\n   167→     unsigned char found_start_needle = 0,\n   168→            found_end_needle   = 0;\n   169→     int    tag_start_offset, tag_end_offset;\n   170→     tvbuff_t *next_tvb;\n   171→ \n   172→     tag_start_offset = tvb_ws_mempbrk_pattern_uint8(tvb, offset, datalen, &pbrk_tag_delimiter, &found_start_needle);\n   173→     if (tag_start_offset == -1)\n   174→     {\n   175→         /* no tag data */\n   176→         return;\n   177→     }\n   178→ \n   179→     tag_end_offset = tvb_ws_mempbrk_pattern_uint8(tvb, tag_start_offset+1, datalen, &pbrk_tag_delimiter, &found_end_needle);\n   180→     if (tag_end_offset == -1)\n   181→     {\n   182→         expert_add_info(pinfo, item, &ei_irc_missing_end_delimiter);\n   183→         return;\n   184→     }\n   185→ \n   186→     if ((strcmp(command, "NOTICE") != 0) &&\n   187→        (strcmp(command, "PRIVMSG") != 0))\n   188→     {\n   189→         expert_add_info(pinfo, item, &ei_irc_tag_data_invalid);\n   190→     }\n   191→ \n   192→     /* Placeholder to call CTCP dissector, strip out delimiter */\n   193→     if(tree) {\n   194→         next_tvb = tvb_new_subset_length(tvb, tag_start_offset+1, datalen-2 );\n   195→         dissect_irc_ctcp(next_tvb, pinfo, tree, NULL);\n   196→     }\n   197→ }\n   198→ \n   199→ static void\n   200→ dissect_irc_pass(tvbuff_t *tvb, proto_item *item, int offset)\n   201→ {\n   202→     int end = tvb_captured_length_remaining(tvb, offset);\n   203→     if (end <= 0)\n   204→         return;\n   205→ \n   206→     end = offset + end;\n   207→     \n   208→     proto_tree *tree = proto_item_add_subtree(item, ett_irc_request_command_pass);\n   209→     proto_tree_add_item(tree, hf_irc_request_command_pass_password, tvb, offset, end-offset, ENC_ASCII);\n   210→ \n   211→     return;\n   212→ }\n   213→ \n   214→ static void\n   215→ dissect_irc_nick(tvbuff_t *tvb, proto_item *item, int offset)\n   216→ {\n   217→     /* The password */\n   218→     int end = tvb_captured_length_remaining(tvb, offset);\n   219→     if (end <= 0)\n   220→         return;\n   221→ \n   222→     end = offset + end;\n   223→     \n   224→     proto_tree *tree = proto_item_add_subtree(item, ett_irc_request_command_nick);\n   225→     proto_tree_add_item(tree, hf_irc_request_command_pass, tvb, offset, end-offset, ENC_ASCII);\n   226→ \n   227→     return;\n   228→ }\n   229→ \n   230→ static void\n   231→ dissect_irc_user(tvbuff_t *tvb, proto_item *item, int offset)\n   232→ {\n   233→     proto_tree *tree;\n   234→     int param_end;\n   235→     int end_offset;\n   236→     int end = tvb_captured_length_remaining(tvb, offset);\n   237→     if (end <= 0)\n   238→         return;\n   239→ \n   240→     end_offset = offset + end;\n   241→ \n   242→     tree = proto_item_add_subtree(item, ett_irc_request_command_user);\n   243→ \n   244→     int current_offset = offset;\n   245→     param_end = tvb_find_uint8(tvb, current_offset, end, \' \');\n   246→     if (param_end == -1)\n   247→         return;\n   248→ \n   249→     proto_tree_add_item(tree, hf_irc_request_command_user_user, tvb, current_offset, param_end-current_offset, ENC_ASCII);\n   250→     current_offset = param_end + 1;\n   251→ \n   252→     param_end = tvb_find_uint8(tvb, current_offset, end_offset-current_offset, \' \');\n   253→     if (param_end == -1)\n   254→         return;\n   255→ \n   256→     proto_tree_add_item(tree, hf_irc_request_command_user_host, tvb, current_offset, param_end-current_offset, ENC_ASCII);\n   257→     current_offset = param_end + 1;\n   258→ \n   259→     param_end = tvb_find_uint8(tvb, current_offset, end_offset-current_offset, \' \');\n   260→     if (param_end == -1)\n   261→         return;\n   262→ \n   263→     proto_tree_add_item(tree, hf_irc_request_command_user_server, tvb, current_offset, param_end-current_offset, ENC_ASCII);\n   264→     current_offset = param_end + 1;\n   265→ \n   266→     if (tvb_get_uint8(tvb, current_offset) == \':\') {\n   267→         current_offset++;\n   268→         end = tvb_captured_length_remaining(tvb, current_offset);\n   269→         proto_tree_add_item(tree, hf_irc_request_command_user_real, tvb, current_offset, end, ENC_ASCII);\n   270→     }\n   271→ }\n   272→ \n   273→ static void\n   274→ dissect_irc_ping(tvbuff_t *tvb, proto_item *item, int offset)\n   275→ {\n   276→     proto_tree *tree;\n   277→     int end;\n   278→ \n   279→     if (tvb_get_uint8(tvb, offset) != \':\')\n   280→         return;\n   281→     \n   282→     offset++;\n   283→     end = tvb_captured_length_remaining(tvb, offset);\n   284→     if (end <= 0)\n   285→         return;\n   286→     \n   287→     tree = proto_item_add_subtree(item, ett_irc_request_command_ping);\n   288→ \n   289→     proto_tree_add_item(tree, hf_irc_request_command_ping_server, tvb, offset, end, ENC_ASCII);\n   290→ }\n   291→ \n   292→ static void\n   293→ dissect_irc_pong(tvbuff_t *tvb, proto_item *item, int offset)\n   294→ {\n   295→     proto_tree *tree;\n   296→     int end;\n   297→ \n   298→     if (tvb_get_uint8(tvb, offset) != \':\')\n   299→         return;\n   300→     \n   301→     offset++;\n   302→     end = tvb_captured_length_remaining(tvb, offset);\n   303→     if (end <= 0)\n   304→         return;\n   305→     \n   306→     tree = proto_item_add_subtree(item, ett_irc_request_command_pong);\n   307→ \n   308→     proto_tree_add_item(tree, hf_irc_request_command_pong_server, tvb, offset, end, ENC_ASCII);\n   309→ }\n   310→ \n   311→ static void\n   312→ dissect_irc_quit(tvbuff_t *tvb, proto_item *item, int offset)\n   313→ {\n   314→     proto_tree *tree;\n   315→     int end;\n   316→ \n   317→     if (tvb_get_uint8(tvb, offset) != \':\')\n   318→         return;\n   319→     \n   320→     offset++;\n   321→     end = tvb_captured_length_remaining(tvb, offset);\n   322→     if (end <= 0)\n   323→         return;\n   324→     \n   325→     tree = proto_item_add_subtree(item, ett_irc_request_command_quit);\n   326→ \n   327→     proto_tree_add_item(tree, hf_irc_request_command_quit_message, tvb, offset, end, ENC_ASCII);\n   328→ }\n   329→ \n   330→ static void\n   331→ dissect_irc_join(tvbuff_t *tvb, proto_item *item, int offset)\n   332→ {\n   333→     proto_tree *tree;\n   334→     int start_offset;\n   335→     int end_offset;\n   336→     int length;\n   337→     uint8_t *channel_name;\n   338→ \n   339→     if (tvb_get_uint8(tvb, offset) != \'#\')\n   340→         return;\n   341→     \n   342→     start_offset = offset;\n   343→ \n   344→     channel_name = malloc(CHANNELLEN+1);\n   345→ \n   346→     if (channel_name == NULL ) {\n   347→         return;\n   348→     }\n   349→ \n   350→     tree = proto_item_add_subtree(item, ett_irc_request_command_join);\n   351→     \n   352→     /* Parse the channels to join*/\n   353→     while(tvb_offset_exists(tvb, start_offset) ) {\n   354→         // Find the comma\n   355→         length = tvb_captured_length_remaining(tvb, start_offset);\n   356→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   357→ \n   358→         if ( end_offset == -1 ) {\n   359→             proto_tree_add_item(tree, hf_irc_request_command_join_channel, tvb, start_offset, length, ENC_ASCII);\n   360→             \n   361→             memset(channel_name, 0, CHANNELLEN+1);\n   362→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   363→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   364→ \n   365→             free(channel_name);\n   366→             return;\n   367→         }\n   368→ \n   369→         memset(channel_name, 0, CHANNELLEN+1);\n   370→         tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   371→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   372→ \n   373→         proto_tree_add_item(tree, hf_irc_request_command_join_channel, tvb, start_offset, length, ENC_ASCII);\n   374→         start_offset = end_offset + 1;\n   375→     }\n   376→ \n   377→     free(channel_name);\n   378→     return;\n   379→ }\n   380→ \n   381→ static void\n   382→ dissect_irc_part(tvbuff_t *tvb, proto_item *item, int offset)\n   383→ {\n   384→     proto_tree *tree;\n   385→     int start_offset;\n   386→     int end_offset;\n   387→     int length;\n   388→     uint8_t *channel_name;\n   389→ \n   390→     if (tvb_get_uint8(tvb, offset) != \'#\')\n   391→         return;\n   392→     \n   393→     channel_name = malloc(CHANNELLEN+1);\n   394→ \n   395→     if (channel_name == NULL ) {\n   396→         return;\n   397→     }\n   398→ \n   399→     start_offset = offset;\n   400→ \n   401→     tree = proto_item_add_subtree(item, ett_irc_request_command_part);\n   402→ \n   403→     while(tvb_offset_exists(tvb, start_offset) ) {\n   404→         length = tvb_captured_length_remaining(tvb, start_offset);\n   405→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   406→ \n   407→         if ( end_offset == -1 ) {\n   408→             int start_message = tvb_find_uint8(tvb, start_offset, length, \':\');\n   409→ \n   410→             if ( start_message == -1 ) {\n   411→                 proto_tree_add_item(tree, hf_irc_request_command_part_channel, tvb, start_offset, length, ENC_ASCII);\n   412→                 \n   413→                 memset(channel_name, 0, CHANNELLEN+1);\n   414→                 tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   415→                 proto_item_append_text(tree, "Channel: %s", channel_name);\n   416→ \n   417→                 free(channel_name);\n   418→                 return;\n   419→             }\n   420→ \n   421→             length = start_message-start_offset;\n   422→ \n   423→             proto_tree_add_item(tree, hf_irc_request_command_part_channel, tvb, start_offset, length, ENC_ASCII);\n   424→             \n   425→             memset(channel_name, 0, CHANNELLEN+1);\n   426→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   427→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   428→ \n   429→             start_message++;\n   430→             length = tvb_captured_length_remaining(tvb, start_message);\n   431→             proto_tree_add_item(tree, hf_irc_request_command_part_message, tvb, start_message, length, ENC_ASCII);\n   432→ \n   433→             free(channel_name);\n   434→             return;\n   435→         }\n   436→ \n   437→         memset(channel_name, 0, CHANNELLEN+1);\n   438→         tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   439→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   440→ \n   441→         proto_tree_add_item(tree, hf_irc_request_command_join_channel, tvb, start_offset, length, ENC_ASCII);\n   442→         start_offset = end_offset + 1;\n   443→     }\n   444→ \n   445→     free(channel_name);\n   446→     return;\n   447→ }\n   448→ \n   449→ static void\n   450→ dissect_irc_privmsg(tvbuff_t *tvb, proto_item *item, int offset)\n   451→ {\n   452→     proto_tree *tree;\n   453→     int start_message;\n   454→     int length;\n   455→ \n   456→     length = tvb_captured_length_remaining(tvb, offset);\n   457→ \n   458→     start_message = tvb_find_uint8(tvb, offset, length, \':\');\n   459→ \n   460→     if ( start_message == -1)\n   461→         return;\n   462→     \n   463→     tree = proto_item_add_subtree(item, ett_irc_request_command_privmsg);\n   464→ \n   465→     proto_tree_add_item(tree, hf_irc_request_command_privmsg_target, tvb, offset, start_message-offset, ENC_ASCII);\n   466→     start_message++;\n   467→ \n   468→     length = tvb_captured_length_remaining(tvb, start_message);\n   469→     proto_tree_add_item(tree, hf_irc_request_command_privmsg_message, tvb, start_message, length, ENC_ASCII);\n   470→ \n   471→     return;\n   472→ }\n   473→ \n   474→ static void\n   475→ dissect_irc_notice(tvbuff_t *tvb, proto_item *item, int offset)\n   476→ {\n   477→     proto_tree *tree;\n   478→     int start_message;\n   479→     int length;\n   480→ \n   481→     length = tvb_captured_length_remaining(tvb, offset);\n   482→ \n   483→     start_message = tvb_find_uint8(tvb, offset, length, \':\');\n   484→ \n   485→     if ( start_message == -1)\n   486→         return;\n   487→     \n   488→     tree = proto_item_add_subtree(item, ett_irc_request_command_notice);\n   489→ \n   490→     proto_tree_add_item(tree, hf_irc_request_command_notice_target, tvb, offset, start_message-offset, ENC_ASCII);\n   491→     start_message++;\n   492→ \n   493→     length = tvb_captured_length_remaining(tvb, start_message);\n   494→     proto_tree_add_item(tree, hf_irc_request_command_notice_message, tvb, start_message, length, ENC_ASCII);\n   495→ \n   496→     return;\n   497→ }\n   498→ \n   499→ static void\n   500→ dissect_irc_topic(tvbuff_t *tvb, proto_item *item, int offset)\n   501→ {\n   502→     proto_tree *tree;\n   503→     int start_topic;\n   504→     int length;\n   505→ \n   506→     tree = proto_item_add_subtree(item, ett_irc_request_command_topic);\n   507→ \n   508→     length = tvb_captured_length_remaining(tvb, offset);\n   509→     start_topic = tvb_find_uint8(tvb, offset, length, \':\');\n   510→ \n   511→     if ( start_topic == -1) {\n   512→         proto_tree_add_item(tree, hf_irc_request_command_topic_target, tvb, offset, length, ENC_ASCII);\n   513→         return;\n   514→     }\n   515→     \n   516→     proto_tree_add_item(tree, hf_irc_request_command_topic_target, tvb, offset, start_topic-offset-1, ENC_ASCII);\n   517→     start_topic++;\n   518→ \n   519→     length = tvb_captured_length_remaining(tvb, start_topic);\n   520→     proto_tree_add_item(tree, hf_irc_request_command_topic_topic, tvb, start_topic, length, ENC_ASCII);\n   521→ \n   522→     return;\n   523→ }\n   524→ \n   525→ static void\n   526→ dissect_irc_names(tvbuff_t *tvb, proto_item *item, int offset)\n   527→ {\n   528→     proto_tree *tree;\n   529→     int start_offset;\n   530→     int end_offset;\n   531→     int length;\n   532→     uint8_t *channel_name;\n   533→ \n   534→     if (tvb_get_uint8(tvb, offset) != \'#\')\n   535→         return;\n   536→     \n   537→     channel_name = malloc(CHANNELLEN+1);\n   538→ \n   539→     if (channel_name == NULL ) {\n   540→         return;\n   541→     }\n   542→ \n   543→     start_offset = offset;\n   544→ \n   545→     tree = proto_item_add_subtree(item, ett_irc_request_command_names);\n   546→ \n   547→     while(tvb_offset_exists(tvb, start_offset) ) {\n   548→         length = tvb_captured_length_remaining(tvb, start_offset);\n   549→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   550→ \n   551→         if ( end_offset == -1 ) {\n   552→             proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, length, ENC_ASCII);\n   553→             \n   554→             memset(channel_name, 0, CHANNELLEN+1);\n   555→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   556→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   557→ \n   558→             free(channel_name);\n   559→             return;\n   560→         }\n   561→ \n   562→         memset(channel_name, 0, CHANNELLEN+1);\n   563→         tvb_memcpy(tvb, channel_name, start_offset, length);\n   564→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   565→ \n   566→         proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   567→         start_offset = end_offset + 1;\n   568→     }\n   569→ \n   570→     free(channel_name);\n   571→     return;\n   572→ }\n   573→ \n   574→ static void\n   575→ dissect_irc_list(tvbuff_t *tvb, proto_item *item, int offset)\n   576→ {\n   577→     proto_tree *tree;\n   578→     int start_offset;\n   579→     int end_offset;\n   580→     int length;\n   581→     uint8_t *channel_name;\n   582→ \n   583→     if (tvb_get_uint8(tvb, offset) != \'#\')\n   584→         return;\n   585→     \n   586→     channel_name = malloc(CHANNELLEN+1);\n   587→ \n   588→     if (channel_name == NULL ) {\n   589→         return;\n   590→     }\n   591→ \n   592→     start_offset = offset;\n   593→ \n   594→     tree = proto_item_add_subtree(item, ett_irc_request_command_list);\n   595→ \n   596→     while(tvb_offset_exists(tvb, start_offset) ) {\n   597→         length = tvb_captured_length_remaining(tvb, start_offset);\n   598→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   599→ \n   600→         if ( end_offset == -1 ) {\n   601→             proto_tree_add_item(tree, hf_irc_request_command_list_channel, tvb, start_offset, length, ENC_ASCII);\n   602→             \n   603→             memset(channel_name, 0, CHANNELLEN+1);\n   604→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   605→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   606→ \n   607→             free(channel_name);\n   608→ \n   609→             return;\n   610→         }\n   611→ \n   612→         memset(channel_name, 0, CHANNELLEN+1);\n   613→         tvb_memcpy(tvb, channel_name, start_offset, (end_offset-start_offset < CHANNELLEN) ? end_offset-start_offset : CHANNELLEN);\n   614→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   615→ \n   616→         proto_tree_add_item(tree, hf_irc_request_command_list_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   617→         start_offset = end_offset + 1;\n   618→     }\n   619→ \n   620→     free(channel_name);\n   621→     return;\n   622→ }\n   623→ \n   624→ static void\n   625→ dissect_irc_whois(tvbuff_t *tvb, proto_item *item, int offset)\n   626→ {\n   627→     proto_tree *tree;\n   628→     int start_offset;\n   629→     int end_offset;\n   630→     int length;\n   631→ \n   632→     tree = proto_item_add_subtree(item, ett_irc_request_command_whois);\n   633→     start_offset = offset;\n   634→ \n   635→     while(tvb_offset_exists(tvb, start_offset) ) {\n   636→         length = tvb_captured_length_remaining(tvb, start_offset);\n   637→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   638→ \n   639→         if ( end_offset == -1 ) {\n   640→             proto_tree_add_item(tree, hf_irc_request_command_whois_name, tvb, start_offset, length, ENC_ASCII);\n   641→             return;\n   642→         }\n   643→ \n   644→         proto_tree_add_item(tree, hf_irc_request_command_whois_name, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   645→         start_offset = end_offset + 1;\n   646→     }\n   647→ \n   648→     return;\n   649→ }\n   650→ \n   651→ static void\n   652→ dissect_irc_request_command(proto_tree *request_tree, tvbuff_t *tvb, int offset, const uint8_t *str_command)\n   653→ {\n   654→     int end_offset;\n   655→     proto_item *ti;\n   656→ \n   657→     if (!str_command)\n   658→         return;\n   659→ \n   660→     end_offset = tvb_find_uint8(tvb, offset, tvb_captured_length_remaining(tvb, offset), \' \');\n   661→ \n   662→     if(end_offset == -1)\n   663→         return;\n   664→ \n   665→     if (strcmp(str_command, "PASS") == 0) {\n   666→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_pass, tvb, offset, end_offset-offset, ENC_ASCII);\n   667→         dissect_irc_pass(tvb, ti, end_offset+1);\n   668→     } else if (strcmp(str_command, "NICK") == 0) {\n   669→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_nick, tvb, offset, end_offset-offset, ENC_ASCII);\n   670→         dissect_irc_nick(tvb, ti, end_offset+1);\n   671→     } else if (strcmp(str_command, "USER") == 0) {\n   672→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_user, tvb, offset, end_offset-offset, ENC_ASCII);\n   673→         dissect_irc_user(tvb, ti, end_offset+1);\n   674→     } else if (strcmp(str_command, "PING") == 0) {\n   675→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_ping, tvb, offset, end_offset-offset, ENC_ASCII);\n   676→         dissect_irc_ping(tvb, ti, end_offset+1);\n   677→     } else if (strcmp(str_command, "PONG") == 0) {\n   678→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_pong, tvb, offset, end_offset-offset, ENC_ASCII);\n   679→         dissect_irc_pong(tvb, ti, end_offset+1);\n   680→     } else if (strcmp(str_command, "QUIT") == 0) {\n   681→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_quit, tvb, offset, end_offset-offset, ENC_ASCII);\n   682→         dissect_irc_quit(tvb, ti, end_offset+1);\n   683→     } else if (strcmp(str_command, "JOIN") == 0) {\n   684→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_join, tvb, offset, end_offset-offset, ENC_ASCII);\n   685→         dissect_irc_join(tvb, ti, end_offset+1);\n   686→     } else if (strcmp(str_command, "PART") == 0) {\n   687→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_part, tvb, offset, end_offset-offset, ENC_ASCII);\n   688→         dissect_irc_part(tvb, ti, end_offset+1);\n   689→     } else if (strcmp(str_command, "PRIVMSG") == 0) {\n   690→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_privmsg, tvb, offset, end_offset-offset, ENC_ASCII);\n   691→         dissect_irc_privmsg(tvb, ti, end_offset+1);\n   692→     } else if (strcmp(str_command, "NOTICE") == 0) {\n   693→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_notice, tvb, offset, end_offset-offset, ENC_ASCII);\n   694→         dissect_irc_notice(tvb, ti, end_offset+1);\n   695→     } else if (strcmp(str_command, "MODE") == 0) {\n   696→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_mode, tvb, offset, end_offset-offset, ENC_ASCII);\n   697→     } else if (strcmp(str_command, "TOPIC") == 0) {\n   698→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_topic, tvb, offset, end_offset-offset, ENC_ASCII);\n   699→         dissect_irc_topic(tvb, ti, end_offset+1);\n   700→     } else if (strcmp(str_command, "NAMES") == 0) {\n   701→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_names, tvb, offset, end_offset-offset, ENC_ASCII);\n   702→         dissect_irc_names(tvb, ti, end_offset+1);\n   703→     } else if (strcmp(str_command, "LIST") == 0) {\n   704→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_list, tvb, offset, end_offset-offset, ENC_ASCII);\n   705→         dissect_irc_list(tvb, ti, end_offset+1);\n   706→     } else if (strcmp(str_command, "WHO") == 0) {\n   707→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_who, tvb, offset, end_offset-offset, ENC_ASCII);\n   708→     } else if (strcmp(str_command, "WHOIS") == 0) {\n   709→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_whois, tvb, offset, end_offset-offset, ENC_ASCII);\n   710→         dissect_irc_whois(tvb, ti, end_offset+1);\n   711→     } else if (strcmp(str_command, "WHOWAS") == 0) {\n   712→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_whowas, tvb, offset, end_offset-offset, ENC_ASCII);\n   713→     } else if (strcmp(str_command, "INVITE") == 0) {\n   714→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_invite, tvb, offset, end_offset-offset, ENC_ASCII);\n   715→     } else if (strcmp(str_command, "KICK") == 0) {\n   716→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_kick, tvb, offset, end_offset-offset, ENC_ASCII);\n   717→     } else if (strcmp(str_command, "AWAY") == 0) {\n   718→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_away, tvb, offset, end_offset-offset, ENC_ASCII);\n   719→     } else if (strcmp(str_command, "ISON") == 0) {\n   720→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_who, tvb, offset, end_offset-offset, ENC_ASCII);\n   721→     } else if (strcmp(str_command, "TIME") == 0) {\n   722→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_time, tvb, offset, end_offset-offset, ENC_ASCII);\n   723→     } else if (strcmp(str_command, "MOTD") == 0) {\n   724→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_motd, tvb, offset, end_offset-offset, ENC_ASCII);\n   725→     } else if (strcmp(str_command, "VERSION") == 0) {\n   726→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_version, tvb, offset, end_offset-offset, ENC_ASCII);\n   727→     } else if (strcmp(str_command, "STATS") == 0) {\n   728→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_stats, tvb, offset, end_offset-offset, ENC_ASCII);\n   729→     } else if (strcmp(str_command, "LINKS") == 0) {\n   730→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_links, tvb, offset, end_offset-offset, ENC_ASCII);\n   731→     } else if (strcmp(str_command, "TRACE") == 0) {\n   732→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_trace, tvb, offset, end_offset-offset, ENC_ASCII);\n   733→     } else if (strcmp(str_command, "ADMIN") == 0) {\n   734→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_admin, tvb, offset, end_offset-offset, ENC_ASCII);\n   735→     } else if (strcmp(str_command, "INFO") == 0) {\n   736→         ti = proto_tree_add_item(request_tree, hf_irc_request_command_info, tvb, offset, end_offset-offset, ENC_ASCII);\n   737→     } else {\n   738→         proto_tree_add_string_format_value(request_tree, hf_irc_request_command, tvb, offset, end_offset-offset, str_command,\n   739→                                            "Unknown or unhandled command: %s", str_command);\n   740→     }\n   741→ }\n   742→ \n   743→ static void\n   744→ dissect_irc_request(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int linelen)\n   745→ {\n   746→     proto_tree   *request_tree, *command_tree = NULL;\n   747→     proto_item   *request_item;\n   748→     intstart_offset                = offset;\n   749→     int           end_offset                  = start_offset+linelen;\n   750→     int           eop_offset                  = -1,\n   751→                   eoc_offset                  = -1,\n   752→                   eocp_offset,\n   753→                   tag_start_offset, tag_end_offset;\n   754→     const uint8_t *str_command;\n   755→     unsigned char found_tag_needle            = 0;\n   756→     bool          first_command_param         = true;\n   757→ \n   758→     request_item = proto_tree_add_item(tree, hf_irc_request, tvb, offset, linelen, ENC_ASCII);\n   759→     if (linelen <= 0)\n   760→         return;\n   761→ \n   762→     request_tree = proto_item_add_subtree(request_item, ett_irc_request );\n   763→ \n   764→     /* Check if message has a prefix */\n   765→     if (tvb_get_uint8(tvb, offset) == \':\')\n   766→     {\n   767→         /* find the end of the prefix */\n   768→         eop_offset = tvb_find_uint8(tvb, offset+1, linelen-1, \' \');\n   769→         if (eop_offset == -1)\n   770→         {\n   771→             expert_add_info(pinfo, request_item, &ei_irc_prefix_missing_ending_space);\n   772→             return;\n   773→         }\n   774→ \n   775→         proto_tree_add_item(request_tree, hf_irc_request_prefix, tvb, offset+1, eop_offset-offset-1, ENC_ASCII);\n   776→         offset = eop_offset+1;\n   777→     }\n   778→ \n   779→     /* clear out any whitespace before command */\n   780→     while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n   781→     {\n   782→         offset++;\n   783→     }\n   784→     if (offset == end_offset)\n   785→     {\n   786→         expert_add_info(pinfo, request_item, &ei_irc_request_command);\n   787→         return;\n   788→     }\n   789→ \n   790→     eoc_offset = tvb_find_uint8(tvb, offset, end_offset-offset, \' \');\n   791→     if (eoc_offset == -1)\n   792→     {\n   793→         const uint8_t* col_str;\n   794→ \n   795→         proto_tree_add_item_ret_string(request_tree, hf_irc_request_command, tvb, offset, end_offset-offset, ENC_ASCII|ENC_NA, pinfo->pool, &col_str);\n   796→         col_append_fstr( pinfo->cinfo, COL_INFO, " (%s)", col_str);\n   797→ \n   798→         /* Warn if there is a "numeric" command */\n   799→         if ((end_offset-offset == 3) &&\n   800→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset))) &&\n   801→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset+1))) &&\n   802→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset+2))))\n   803→         {\n   804→             expert_add_info(pinfo, request_item, &ei_irc_numeric_request_command);\n   805→         }\n   806→         return;\n   807→     }\n   808→ \n   809→     proto_tree_add_item_ret_string(request_tree, hf_irc_request_command, tvb, offset, eoc_offset-offset, ENC_ASCII|ENC_NA, pinfo->pool, &str_command);\n   810→     col_append_fstr( pinfo->cinfo, COL_INFO, " (%s)", str_command);\n   811→     dissect_irc_request_command(request_tree, tvb, offset, str_command);\n   812→ \n   813→     /* Warn if there is a "numeric" command */\n   814→     if ((eoc_offset-offset == 3) &&\n   815→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset))) &&\n   816→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset+1))) &&\n   817→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset+2))))\n   818→     {\n   819→         expert_add_info(pinfo, request_item, &ei_irc_numeric_request_command);\n   820→     }\n   821→ \n   822→     offset = eoc_offset+1;\n   823→ \n   824→     /* clear out any whitespace before command parameter */\n   825→     while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n   826→     {\n   827→         offset++;\n   828→     }\n   829→     if (offset == end_offset)\n   830→     {\n   831→         /* No command parameters */\n   832→         return;\n   833→     }\n   834→ \n   835→     /* Check if message has a trailer */\n   836→     if (tvb_get_uint8(tvb, offset) == \':\')\n   837→     {\n   838→         proto_tree_add_item(request_tree, hf_irc_request_trailer, tvb, offset+1, end_offset-offset-1, ENC_ASCII);\n   839→         dissect_irc_tag_data(request_tree, request_item, tvb, offset+1, end_offset-offset-1, pinfo, str_command);\n   840→         return;\n   841→     }\n   842→ \n   843→     while(offset < end_offset)\n   844→     {\n   845→         eocp_offset = tvb_find_uint8(tvb, offset, end_offset-offset, \' \');\n   846→         tag_start_offset = tvb_ws_mempbrk_pattern_uint8(tvb, offset, end_offset-offset, &pbrk_tag_delimiter, &found_tag_needle);\n   847→ \n   848→         /* Create subtree when the first parameter is found */\n   849→         if (first_command_param)\n   850→         {\n   851→             command_tree = proto_tree_add_subtree(request_tree, tvb, offset, end_offset-offset,\n   852→                                              ett_irc_request_command, NULL, "Command parameters");\n   853→             first_command_param = false;\n   854→         }\n   855→ \n   856→         if (((eocp_offset == -1) && (tag_start_offset == -1)) ||\n   857→             ((eocp_offset != -1) && (tag_start_offset == -1)) ||\n   858→             (eocp_offset < tag_start_offset))\n   859→         {\n   860→             /* regular message should be dissected */\n   861→ \n   862→             if (eocp_offset == -1)\n   863→             {\n   864→                 proto_tree_add_item(command_tree, hf_irc_request_command_param, tvb, offset, end_offset-offset, ENC_ASCII);\n   865→                 return;\n   866→             }\n   867→ \n   868→             proto_tree_add_item(command_tree, hf_irc_request_command_param, tvb, offset, eocp_offset-offset, ENC_ASCII);\n   869→             offset = eocp_offset+1;\n   870→ \n   871→             /* clear out any whitespace before next command parameter */\n   872→             while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n   873→             {\n   874→                 offset++;\n   875→             }\n   876→             if (offset == end_offset)\n   877→             {\n   878→                 break;\n   879→             }\n   880→ \n   881→             /* Check if message has a trailer */\n   882→             if (tvb_get_uint8(tvb, offset) == \':\')\n   883→             {\n   884→                 proto_tree_add_item(request_tree, hf_irc_request_trailer, tvb, offset+1, end_offset-offset-1, ENC_ASCII);\n   885→                 dissect_irc_tag_data(request_tree, request_item, tvb, offset+1, end_offset-offset-1, pinfo, str_command);\n   886→                 return;\n   887→             }\n   888→         }\n   889→         else if (((eocp_offset == -1) && (tag_start_offset != -1)) ||\n   890→                (eocp_offset > tag_start_offset))\n   891→         {\n   892→             /* tag data dissected */\n   893→ \n   894→             found_tag_needle = 0;\n   895→             tag_end_offset = tvb_ws_mempbrk_pattern_uint8(tvb, tag_start_offset+1, end_offset-tag_start_offset-1, &pbrk_tag_delimiter, &found_tag_needle);\n   896→             if (tag_end_offset == -1)\n   897→             {\n   898→                 expert_add_info(pinfo, request_item, &ei_irc_missing_end_delimiter);\n   899→                 return;\n   900→             }\n   901→ \n   902→             dissect_irc_tag_data(request_tree, request_item, tvb, tag_start_offset, tag_end_offset-tag_start_offset, pinfo, str_command);\n   903→             offset = tag_end_offset+1;\n   904→         }\n   905→     }\n   906→ }\n   907→ \n   908→ static void\n   909→ dissect_irc_response(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int linelen)\n   910→ {\n   911→     proto_tree   *response_tree, *command_tree = NULL;\n   912→     proto_item   *response_item, *hidden_item;\n   913→     int           start_offset                 = offset;\n   914→     int           end_offset                   = start_offset+linelen;\n   915→     int           eop_offset                   = -1,\n   916→                   eoc_offset                   = -1,\n   917→                   eocp_offset,\n   918→                   tag_start_offset, tag_end_offset;\n   919→     const uint8_t* str_command;\n   920→     uint16_t      num_command;\n   921→     unsigned char found_tag_needle             = 0;\n   922→     bool          first_command_param          = true;\n   923→ \n   924→     response_item = proto_tree_add_item(tree, hf_irc_response, tvb, offset, linelen, ENC_ASCII);\n   925→     if (linelen <= 0)\n   926→         return;\n   927→ \n   928→     response_tree = proto_item_add_subtree(response_item, ett_irc_response );\n   929→ \n   930→     /* Check if message has a prefix */\n   931→     if (tvb_get_uint8(tvb, offset) == \':\')\n   932→     {\n   933→         /* find the end of the prefix */\n   934→         eop_offset = tvb_find_uint8(tvb, offset+1, linelen-1, \' \');\n   935→         if (eop_offset == -1)\n   936→         {\n   937→             expert_add_info(pinfo, response_item, &ei_irc_prefix_missing_ending_space);\n   938→             return;\n   939→         }\n   940→ \n   941→         proto_tree_add_item(response_tree, hf_irc_response_prefix, tvb, offset+1, eop_offset-offset-1, ENC_ASCII);\n   942→         offset = eop_offset+1;\n   943→     }\n   944→ \n   945→     /* clear out any whitespace before command */\n   946→     while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n   947→     {\n   948→         offset++;\n   949→     }\n   950→     if (offset == end_offset)\n   951→     {\n   952→         expert_add_info(pinfo, response_item, &ei_irc_response_command);\n   953→         return;\n   954→     }\n   955→ \n   956→     eoc_offset = tvb_find_uint8(tvb, offset, end_offset-offset, \' \');\n   957→     if (eoc_offset == -1)\n   958→     {\n   959→         const uint8_t* col_str;\n   960→         proto_tree_add_item_ret_string(response_tree, hf_irc_response_command, tvb, offset, end_offset-offset, ENC_ASCII|ENC_NA, pinfo->pool, &col_str);\n   961→         col_append_fstr( pinfo->cinfo, COL_INFO, " (%s)", col_str);\n   962→ \n   963→         /* if response command is numeric, allow it to be filtered as an integer */\n   964→         if ((end_offset-offset == 3) &&\n   965→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset))) &&\n   966→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset+1))) &&\n   967→             (g_ascii_isdigit(tvb_get_uint8(tvb, offset+2))))\n   968→         {\n   969→             num_command = ((tvb_get_uint8(tvb, offset)-0x30)*100) + ((tvb_get_uint8(tvb, offset+1)-0x30)*10) + (tvb_get_uint8(tvb, offset+2)-0x30);\n   970→             hidden_item = proto_tree_add_uint(response_tree, hf_irc_response_num_command, tvb, offset, end_offset-offset, num_command);\n   971→             proto_item_set_hidden(hidden_item);\n   972→         }\n   973→         return;\n   974→     }\n   975→ \n   976→     proto_tree_add_item_ret_string(response_tree, hf_irc_response_command, tvb, offset, eoc_offset-offset, ENC_ASCII|ENC_NA, pinfo->pool, &str_command);\n   977→     col_append_fstr( pinfo->cinfo, COL_INFO, " (%s)", str_command);\n   978→ \n   979→     /* if response command is numeric, allow it to be filtered as an integer */\n   980→     if ((eoc_offset-offset == 3) &&\n   981→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset))) &&\n   982→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset+1))) &&\n   983→        (g_ascii_isdigit(tvb_get_uint8(tvb, offset+2))))\n   984→     {\n   985→         num_command = ((tvb_get_uint8(tvb, offset)-0x30)*100) + ((tvb_get_uint8(tvb, offset+1)-0x30)*10) + (tvb_get_uint8(tvb, offset+2)-0x30);\n   986→         hidden_item = proto_tree_add_uint(response_tree, hf_irc_response_num_command, tvb, offset, eoc_offset-offset, num_command);\n   987→         proto_item_set_hidden(hidden_item);\n   988→     }\n   989→ \n   990→     offset = eoc_offset+1;\n   991→ \n   992→     /* clear out any whitespace before command parameter */\n   993→     while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n   994→     {\n   995→         offset++;\n   996→     }\n   997→     if (offset == end_offset)\n   998→     {\n   999→         /* No command parameters */\n  1000→         return;\n  1001→     }\n  1002→ \n  1003→     /* Check if message has a trailer */\n  1004→     if (tvb_get_uint8(tvb, offset) == \':\')\n  1005→     {\n  1006→         proto_tree_add_item(response_tree, hf_irc_response_trailer, tvb, offset+1, end_offset-offset-1, ENC_ASCII);\n  1007→         dissect_irc_tag_data(response_tree, response_item, tvb, offset+1, end_offset-offset-1, pinfo, str_command);\n  1008→         return;\n  1009→     }\n  1010→ \n  1011→     while(offset < end_offset)\n  1012→     {\n  1013→         eocp_offset = tvb_find_uint8(tvb, offset, end_offset-offset, \' \');\n  1014→         tag_start_offset = tvb_ws_mempbrk_pattern_uint8(tvb, offset, end_offset-offset, &pbrk_tag_delimiter, &found_tag_needle);\n  1015→ \n  1016→         /* Create subtree when the first parameter is found */\n  1017→         if (first_command_param)\n  1018→         {\n  1019→             command_tree = proto_tree_add_subtree(response_tree, tvb, offset, end_offset-offset,\n  1020→                                         ett_irc_response_command , NULL, "Command parameters");\n  1021→             first_command_param = false;\n  1022→         }\n  1023→ \n  1024→         if ((tag_start_offset == -1) || (eocp_offset < tag_start_offset))\n  1025→         {\n  1026→             /* regular message should be dissected */\n  1027→ \n  1028→             if (eocp_offset == -1)\n  1029→             {\n  1030→                 proto_tree_add_item(command_tree, hf_irc_response_command_param, tvb, offset, end_offset-offset, ENC_ASCII);\n  1031→                 return;\n  1032→             }\n  1033→ \n  1034→             proto_tree_add_item(command_tree, hf_irc_response_command_param, tvb, offset, eocp_offset-offset, ENC_ASCII);\n  1035→             offset = eocp_offset+1;\n  1036→ \n  1037→             /* clear out any whitespace before next command parameter */\n  1038→             while(offset < end_offset && tvb_get_uint8(tvb, offset) == \' \')\n  1039→             {\n  1040→                 offset++;\n  1041→             }\n  1042→             if (offset == end_offset)\n  1043→             {\n  1044→                 break;\n  1045→             }\n  1046→ \n  1047→             /* Check if message has a trailer */\n  1048→             if (tvb_get_uint8(tvb, offset) == \':\')\n  1049→             {\n  1050→                 proto_tree_add_item(response_tree, hf_irc_response_trailer, tvb, offset+1, end_offset-offset-1, ENC_ASCII);\n  1051→                 dissect_irc_tag_data(response_tree, response_item, tvb, offset+1, end_offset-offset-1, pinfo, str_command);\n  1052→                 return;\n  1053→             }\n  1054→         }\n  1055→         else if ((eocp_offset == -1) || (eocp_offset > tag_start_offset))\n  1056→         {\n  1057→             /* tag data dissected */\n  1058→ \n  1059→             found_tag_needle = 0;\n  1060→             tag_end_offset = tvb_ws_mempbrk_pattern_uint8(tvb, tag_start_offset+1, end_offset-tag_start_offset-1, &pbrk_tag_delimiter, &found_tag_needle);\n  1061→             if (tag_end_offset == -1)\n  1062→             {\n  1063→                 expert_add_info(pinfo, response_item, &ei_irc_missing_end_delimiter);\n  1064→                 return;\n  1065→             }\n  1066→ \n  1067→             dissect_irc_tag_data(response_tree, response_item, tvb, tag_start_offset, tag_end_offset-tag_start_offset, pinfo, str_command);\n  1068→             offset = tag_end_offset+1;\n  1069→         }\n  1070→     }\n  1071→ }\n  1072→ \n  1073→ static int\n  1074→ dissect_irc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n  1075→ {\n  1076→     proto_tree *irc_tree, *ti;\n  1077→     int         offset = 0;\n  1078→     int         next_offset;\n  1079→     int         linelen;\n  1080→ \n  1081→     col_set_str(pinfo->cinfo, COL_PROTOCOL, "IRC");\n  1082→ \n  1083→     col_set_str(pinfo->cinfo, COL_INFO,\n  1084→         (pinfo->match_uint == pinfo->destport) ? "Request" : "Response");\n  1085→ \n  1086→     ti = proto_tree_add_item(tree, proto_irc, tvb, 0, -1, ENC_NA);\n  1087→     irc_tree = proto_item_add_subtree(ti, ett_irc);\n  1088→ \n  1089→     /*\n  1090→      * Process the packet data, a line at a time.\n  1091→      */\n  1092→     while (tvb_offset_exists(tvb, offset))\n  1093→     {\n  1094→         /*\n  1095→          * Find the end of the line.\n  1096→          */\n  1097→         linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, false);\n  1098→         if (next_offset == offset) {\n  1099→             /*\n  1100→              * XXX - we really want the "show data a\n  1101→              * line at a time" loops in various\n  1102→              * dissectors to do reassembly and to\n  1103→              * throw an exception if there\'s no\n  1104→              * line ending in the current packet\n  1105→              * and we\'re not doing reassembly.\n  1106→              */\n  1107→             break;\n  1108→         }\n  1109→ \n  1110→         if (linelen != 0)\n  1111→         {\n  1112→             if (pinfo->match_uint == pinfo->destport)\n  1113→             {\n  1114→                 dissect_irc_request(irc_tree, tvb, pinfo, offset, linelen);\n  1115→             }\n  1116→             else\n  1117→             {\n  1118→                 dissect_irc_response(irc_tree, tvb, pinfo, offset, linelen);\n  1119→             }\n  1120→         }\n  1121→         offset = next_offset;\n  1122→     }\n  1123→     return tvb_captured_length(tvb);\n  1124→ }\n  1125→ \n  1126→ void\n  1127→ proto_register_irc(void)\n  1128→ {\n  1129→     static hf_register_info hf[] = {\n  1130→         { &hf_irc_response, { "Response", "irc.response", FT_STRING, BASE_NONE,\n  1131→           NULL, 0x0, "Line of response message",HFILL }},\n  1132→ \n  1133→         { &hf_irc_request, { "Request", "irc.request", FT_STRING, BASE_NONE,\n  1134→           NULL, 0x0, "Line of request message", HFILL }},\n  1135→ \n  1136→         { &hf_irc_request_prefix, { "Prefix", "irc.request.prefix", FT_STRING, BASE_NONE,\n  1137→           NULL, 0x0, "Request prefix", HFILL }},\n  1138→ \n  1139→         { &hf_irc_request_command, { "Command", "irc.request.command", FT_STRING, BASE_NONE,\n  1140→           NULL, 0x0, "Request command", HFILL }},\n  1141→         \n  1142→         { &hf_irc_request_command_pass, { "PASS Command", "irc.request.command.pass", FT_STRING, BASE_NONE,\n  1143→           NULL, 0x0, NULL, HFILL }},\n  1144→         \n  1145→         { &hf_irc_request_command_pass_password, { "Password", "irc.request.command.pass.password", FT_STRING, BASE_NONE,\n  1146→           NULL, 0x0, NULL, HFILL }},\n  1147→         \n  1148→         { &hf_irc_request_command_nick, { "NICK Command", "irc.request.command.nick", FT_STRING, BASE_NONE,\n  1149→           NULL, 0x0, NULL, HFILL }},\n  1150→         \n  1151→         { &hf_irc_request_command_nick_nick, { "Nickname", "irc.request.command.nick.nick", FT_STRING, BASE_NONE,\n  1152→           NULL, 0x0, NULL, HFILL }},\n  1153→ \n  1154→         { &hf_irc_request_command_user, { "USER Command", "irc.request.command.user", FT_STRING, BASE_NONE,\n  1155→           NULL, 0x0, NULL, HFILL }},\n  1156→         \n  1157→         { &hf_irc_request_command_user_user, { "User", "irc.request.command.user.user", FT_STRING, BASE_NONE,\n  1158→           NULL, 0x0, NULL, HFILL }},\n  1159→         \n  1160→         { &hf_irc_request_command_user_host, { "Host", "irc.request.command.user.host", FT_STRING, BASE_NONE,\n  1161→           NULL, 0x0, NULL, HFILL }},\n  1162→                 \n  1163→         { &hf_irc_request_command_user_server, { "Server", "irc.request.command.user.server", FT_STRING, BASE_NONE,\n  1164→           NULL, 0x0, NULL, HFILL }},\n  1165→                     \n  1166→         { &hf_irc_request_command_user_real, { "Real", "irc.request.command.user.real", FT_STRING, BASE_NONE,\n  1167→           NULL, 0x0, NULL, HFILL }},\n  1168→         \n  1169→         { &hf_irc_request_command_ping, { "PING Command", "irc.request.command.ping", FT_STRING, BASE_NONE,\n  1170→           NULL, 0x0, NULL, HFILL }},\n  1171→         \n  1172→         { &hf_irc_request_command_ping_server, { "Server", "irc.request.command.ping.server", FT_STRING, BASE_NONE,\n  1173→           NULL, 0x0, NULL, HFILL }},\n  1174→ \n  1175→         { &hf_irc_request_command_pong, { "PONG Command", "irc.request.command.pong", FT_STRING, BASE_NONE,\n  1176→           NULL, 0x0, NULL, HFILL }},\n  1177→ \n  1178→         { &hf_irc_request_command_pong_server, { "Server", "irc.request.command.pong.server", FT_STRING, BASE_NONE,\n  1179→           NULL, 0x0, NULL, HFILL }},\n  1180→         \n  1181→         { &hf_irc_request_command_quit, { "QUIT Command", "irc.request.command.quit", FT_STRING, BASE_NONE,\n  1182→           NULL, 0x0, NULL, HFILL }},\n  1183→ \n  1184→         { &hf_irc_request_command_quit_message, { "Message", "irc.request.command.quit.message", FT_STRING, BASE_NONE,\n  1185→           NULL, 0x0, NULL, HFILL }},\n  1186→           \n  1187→         { &hf_irc_request_command_join, { "JOIN Command", "irc.request.command.join", FT_STRING, BASE_NONE,\n  1188→           NULL, 0x0, NULL, HFILL }},\n  1189→   \n  1190→         { &hf_irc_request_command_join_channel, { "Join", "irc.request.command.join.channel", FT_STRING, BASE_NONE,\n  1191→           NULL, 0x0, NULL, HFILL }},\n  1192→ \n  1193→         { &hf_irc_request_command_part, { "PART Command", "irc.request.command.part", FT_STRING, BASE_NONE,\n  1194→           NULL, 0x0, NULL, HFILL }},\n  1195→         \n  1196→         { &hf_irc_request_command_part_channel, { "Channel", "irc.request.command.part.channel", FT_STRING, BASE_NONE,\n  1197→           NULL, 0x0, NULL, HFILL }},\n  1198→         \n  1199→         { &hf_irc_request_command_part_message, { "Message", "irc.request.command.part.message", FT_STRING, BASE_NONE,\n  1200→           NULL, 0x0, NULL, HFILL }},\n  1201→           \n  1202→         { &hf_irc_request_command_privmsg, { "PRIVMSG Command", "irc.request.command.privmsg", FT_STRING, BASE_NONE,\n  1203→           NULL, 0x0, NULL, HFILL }},\n  1204→         \n  1205→         { &hf_irc_request_command_privmsg_target, { "Target", "irc.request.command.privmsg.target", FT_STRING, BASE_NONE,\n  1206→           NULL, 0x0, NULL, HFILL }},\n  1207→             \n  1208→         { &hf_irc_request_command_privmsg_message, { "Message", "irc.request.command.privmsg.message", FT_STRING, BASE_NONE,\n  1209→           NULL, 0x0, NULL, HFILL }},\n  1210→   \n  1211→         { &hf_irc_request_command_notice, { "NOTICE Command", "irc.request.command.notice", FT_STRING, BASE_NONE,\n  1212→           NULL, 0x0, NULL, HFILL }},\n  1213→         \n  1214→         { &hf_irc_request_command_notice_target, { "Target", "irc.request.command.notice.target", FT_STRING, BASE_NONE,\n  1215→           NULL, 0x0, NULL, HFILL }},\n  1216→         \n  1217→         { &hf_irc_request_command_notice_message, { "Message", "irc.request.command.notice.message", FT_STRING, BASE_NONE,\n  1218→           NULL, 0x0, NULL, HFILL }},\n  1219→ \n  1220→         { &hf_irc_request_command_mode, { "MODE Command", "irc.request.command.mode", FT_STRING, BASE_NONE,\n  1221→           NULL, 0x0, "Request command: MODE", HFILL }},\n  1222→           \n  1223→         { &hf_irc_request_command_topic, { "TOPIC Command", "irc.request.command.topic", FT_STRING, BASE_NONE,\n  1224→           NULL, 0x0, NULL, HFILL }},\n  1225→         \n  1226→         { &hf_irc_request_command_topic_target, { "Target", "irc.request.command.topic.target", FT_STRING, BASE_NONE,\n  1227→           NULL, 0x0, NULL, HFILL }},\n  1228→         \n  1229→         { &hf_irc_request_command_topic_topic, { "Topic", "irc.request.command.topic.topic", FT_STRING, BASE_NONE,\n  1230→           NULL, 0x0, NULL, HFILL }},\n  1231→   \n  1232→         { &hf_irc_request_command_names, { "NAMES Command", "irc.request.command.names", FT_STRING, BASE_NONE,\n  1233→           NULL, 0x0, NULL, HFILL }},\n  1234→ \n  1235→         { &hf_irc_request_command_names_channel, { "Channel", "irc.request.command.names.channel", FT_STRING, BASE_NONE,\n  1236→           NULL, 0x0, NULL, HFILL }},\n  1237→           \n  1238→         { &hf_irc_request_command_list, { "LIST Command", "irc.request.command.list", FT_STRING, BASE_NONE,\n  1239→           NULL, 0x0, NULL, HFILL }},\n  1240→ \n  1241→         { &hf_irc_request_command_list_channel, { "Channel", "irc.request.command.list.channel", FT_STRING, BASE_NONE,\n  1242→           NULL, 0x0, NULL, HFILL }},\n  1243→   \n  1244→         { &hf_irc_request_command_who, { "WHO Command", "irc.request.command.who", FT_STRING, BASE_NONE,\n  1245→           NULL, 0x0, "Request command: WHO", HFILL }},\n  1246→           \n  1247→         { &hf_irc_request_command_whois, { "WHOIS Command", "irc.request.command.whois", FT_STRING, BASE_NONE,\n  1248→           NULL, 0x0, NULL, HFILL }},\n  1249→         \n  1250→         { &hf_irc_request_command_whois_name, { "Name", "irc.request.command.whois.name", FT_STRING, BASE_NONE,\n  1251→           NULL, 0x0, NULL, HFILL }},\n  1252→ \n  1253→         { &hf_irc_request_command_whowas, { "WHOWAS Command", "irc.request.command.whowas", FT_STRING, BASE_NONE,\n  1254→           NULL, 0x0, "Request command: WHOWAS", HFILL }},\n  1255→     \n  1256→         { &hf_irc_request_command_invite, { "INVITE Command", "irc.request.command.invite", FT_STRING, BASE_NONE,\n  1257→           NULL, 0x0, "Request command: INVITE", HFILL }},\n  1258→             \n  1259→         { &hf_irc_request_command_kick, { "KICK Command", "irc.request.command.kick", FT_STRING, BASE_NONE,\n  1260→           NULL, 0x0, "Request command: KICK", HFILL }},\n  1261→     \n  1262→         { &hf_irc_request_command_away, { "AWAY Command", "irc.request.command.away", FT_STRING, BASE_NONE,\n  1263→           NULL, 0x0, "Request command: AWAY", HFILL }},\n  1264→ \n  1265→         { &hf_irc_request_command_ison, { "ISON Command", "irc.request.command.ison", FT_STRING, BASE_NONE,\n  1266→           NULL, 0x0, "Request command: ISON", HFILL }},\n  1267→             \n  1268→         { &hf_irc_request_command_time, { "TIME Command", "irc.request.command.time", FT_STRING, BASE_NONE,\n  1269→           NULL, 0x0, "Request command: TIME", HFILL }},\n  1270→     \n  1271→         { &hf_irc_request_command_motd, { "MOTD Command", "irc.request.command.motd", FT_STRING, BASE_NONE,\n  1272→           NULL, 0x0, "Request command: MOTD", HFILL }},\n  1273→             \n  1274→         { &hf_irc_request_command_version, { "VERSION Command", "irc.request.command.version", FT_STRING, BASE_NONE,\n  1275→           NULL, 0x0, "Request command: VERSION", HFILL }},\n  1276→     \n  1277→         { &hf_irc_request_command_stats, { "STATS Command", "irc.request.command.stats", FT_STRING, BASE_NONE,\n  1278→           NULL, 0x0, "Request command: STATS", HFILL }},\n  1279→             \n  1280→         { &hf_irc_request_command_links, { "LINKS Command", "irc.request.command.links", FT_STRING, BASE_NONE,\n  1281→           NULL, 0x0, "Request command: LINKS", HFILL }},\n  1282→       \n  1283→         { &hf_irc_request_command_trace, { "TRACE Command", "irc.request.command.trace", FT_STRING, BASE_NONE,\n  1284→           NULL, 0x0, "Request command: TRACE", HFILL }},\n  1285→               \n  1286→         { &hf_irc_request_command_admin, { "ADMIN Command", "irc.request.command.admin", FT_STRING, BASE_NONE,\n  1287→           NULL, 0x0, "Request command: ADMIN", HFILL }},\n  1288→       \n  1289→         { &hf_irc_request_command_info, { "INFO Command", "irc.request.command.info", FT_STRING, BASE_NONE,\n  1290→           NULL, 0x0, "Request command: INFO", HFILL }},\n  1291→ \n  1292→         { &hf_irc_request_command_param, { "Parameter", "irc.request.command_parameter", FT_STRING, BASE_NONE,\n  1293→           NULL, 0x0, "Request command parameter", HFILL }},\n  1294→ \n  1295→         { &hf_irc_request_trailer, { "Trailer", "irc.request.trailer", FT_STRING, BASE_NONE,\n  1296→           NULL, 0x0, "Request trailer", HFILL }},\n  1297→ \n  1298→         { &hf_irc_response_prefix, { "Prefix", "irc.response.prefix", FT_STRING, BASE_NONE,\n  1299→           NULL, 0x0, "Response prefix", HFILL }},\n  1300→ \n  1301→         { &hf_irc_response_command, { "Command", "irc.response.command", FT_STRING, BASE_NONE,\n  1302→           NULL, 0x0, "Response command", HFILL }},\n  1303→ \n  1304→         { &hf_irc_response_num_command, { "Command", "irc.response.num_command", FT_UINT16, BASE_DEC,\n  1305→           NULL, 0x0, "Response (numeric) command", HFILL }},\n  1306→ \n  1307→         { &hf_irc_response_command_param, { "Parameter", "irc.response.command_parameter", FT_STRING, BASE_NONE,\n  1308→           NULL, 0x0, "Response command parameter", HFILL }},\n  1309→ \n  1310→         { &hf_irc_response_trailer, { "Trailer", "irc.response.trailer", FT_STRING, BASE_NONE,\n  1311→           NULL, 0x0, "Response trailer", HFILL }},\n  1312→ \n  1313→         //{ &hf_irc_ctcp, { "CTCP", "irc.ctcp", FT_STRING, BASE_NONE,\n  1314→         //  NULL, 0x0, NULL, HFILL }},\n  1315→ \n  1316→         { &hf_irc_ctcp_command, { "Command", "irc.ctcp.command", FT_STRING, BASE_NONE,\n  1317→           NULL, 0x0, "CTCP command", HFILL }},\n  1318→ \n  1319→         { &hf_irc_ctcp_params, { "Parameters", "irc.ctcp.parameters", FT_STRING, BASE_NONE,\n  1320→           NULL, 0x0, "CTCP parameters", HFILL }},\n  1321→     };\n  1322→ \n  1323→     static int *ett[] = {\n  1324→         &ett_irc,\n  1325→         &ett_irc_request,\n  1326→         &ett_irc_request_command,\n  1327→         &ett_irc_request_command_pass,\n  1328→         &ett_irc_request_command_nick,\n  1329→         &ett_irc_request_command_user,\n  1330→         &ett_irc_request_command_ping,\n  1331→         &ett_irc_request_command_pong,\n  1332→         &ett_irc_request_command_quit,\n  1333→         &ett_irc_request_command_join,\n  1334→         &ett_irc_request_command_part,\n  1335→         &ett_irc_request_command_privmsg,\n  1336→         &ett_irc_request_command_notice,\n  1337→         &ett_irc_request_command_topic,\n  1338→         &ett_irc_request_command_names,\n  1339→         &ett_irc_request_command_list,\n  1340→         &ett_irc_request_command_whois,\n  1341→         &ett_irc_response,\n  1342→         &ett_irc_response_command\n  1343→     };\n  1344→ \n  1345→     static ei_register_info ei[] = {\n  1346→         { &ei_irc_missing_end_delimiter, { "irc.missing_end_delimiter", PI_MALFORMED, PI_ERROR, "Missing ending tag delimiter (0x01)", EXPFILL }},\n  1347→         { &ei_irc_tag_data_invalid, { "irc.tag_data_invalid", PI_PROTOCOL, PI_WARN, "Tag data outside of NOTICE or PRIVMSG command", EXPFILL }},\n  1348→         { &ei_irc_prefix_missing_ending_space, { "irc.prefix_missing_ending_space", PI_MALFORMED, PI_ERROR, "Prefix missing ending <space>", EXPFILL }},\n  1349→         { &ei_irc_request_command, { "irc.request.command.missing", PI_MALFORMED, PI_ERROR, "Request has no command", EXPFILL }},\n  1350→         { &ei_irc_numeric_request_command, { "irc.request.command.numeric", PI_PROTOCOL, PI_WARN, "Numeric command not allowed in request", EXPFILL }},\n  1351→         { &ei_irc_response_command, { "irc.response.command.missing", PI_MALFORMED, PI_ERROR, "Response has no command", EXPFILL }},\n  1352→     };\n  1353→ \n  1354→     expert_module_t* expert_irc;\n  1355→ \n  1356→     proto_irc = proto_register_protocol("Internet Relay Chat", "IRC", "irc");\n  1357→     register_dissector("irc", dissect_irc, proto_irc);\n  1358→     proto_register_field_array(proto_irc, hf, array_length(hf));\n  1359→     proto_register_subtree_array(ett, array_length(ett));\n  1360→     expert_irc = expert_register_protocol(proto_irc);\n  1361→     expert_register_field_array(expert_irc, ei, array_length(ei));\n  1362→ \n  1363→     /* subdissector code */\n  1364→     proto_irc_ctcp = proto_register_protocol_in_name_only("Client To Client Protocol", "CTCP", "irc.ctcp", proto_irc, FT_PROTOCOL);\n  1365→ \n  1366→     /* compile patterns */\n  1367→     ws_mempbrk_compile(&pbrk_tag_delimiter, TAG_DELIMITER);\n  1368→ }\n  1369→ \n  1370→ void\n  1371→ proto_reg_handoff_irc(void)\n  1372→ {\n  1373→     dissector_add_uint_range_with_preference("tcp.port", TCP_PORT_RANGE, find_dissector("irc"));\n  1374→ \n  1375→     ctcp_handle = create_dissector_handle(dissect_irc_ctcp, proto_irc_ctcp);\n  1376→ }\n  1377→ \n  1378→ /*\n  1379→  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n  1380→  *\n  1381→  * Local variables:\n  1382→  * c-basic-offset: 4\n  1383→  * tab-width: 8\n  1384→  * indent-tabs-mode: nil\n  1385→  * End:\n  1386→  *\n  1387→  * vi: set shiftwidth=4 tabstop=8 expandtab:\n  1388→  * :indentSize=4:tabSize=8:noTabs=true:\n  1389→  */\n  1390→ \n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 8: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="Now I can analyze the crash. Looking at the crash log and the code:\n\n1. The crash occurs in `dissect_irc_names` at line 563 (`tvb_memcpy`)\n2. The crash is a heap-buffer-overflow - writing 132 bytes to a 51-byte buffer\n3. Looking at line 537, `channel_name` is allocated with `malloc(CHANNELLEN+1)` which is `50+1 = 51` bytes\n4. The problematic code is at line 563:\n```c\ntvb_memcpy(tvb, channel_name, start_offset, length);\n```\n\nThis `tvb_memcpy` doesn't limit `length` to `CHANNELLEN` like the other `tvb_memcpy` calls do (e.g., line 555 uses `(length < CHANNELLEN) ? length : CHANNELLEN`).\n\nLooking at the test input:\n```\nNAMES #aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,#hello\n```\n\nThe input contains a very long channel name (over 50 characters), and the second `tvb_memcpy` (line 563) copies `length` bytes without checking if it exceeds `CHANNELLEN`.\n\nThe fix is to limit the copy size at line 563 to use `(length < CHANNELLEN) ? length : CHANNELLEN` instead of just `length`, similar to how line 555 already does it.\n\nLet me apply the fix:")], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 9: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01Udf4cg9v6MJPaueqTPM42x', name='Edit', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', 'old_string': '        memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, length);\n        proto_item_append_text(tree, "Channel: %s", channel_name);\n\n        proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);', 'new_string': '        memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n        proto_item_append_text(tree, "Channel: %s", channel_name);\n\n        proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 10: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01Udf4cg9v6MJPaueqTPM42x', content='<tool_use_error>String to replace not found in file.\nString:         memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, length);\n        proto_item_append_text(tree, "Channel: %s", channel_name);\n\n        proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 11: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Let me re-read that section of the file more carefully to get the exact text:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 12: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_012Mzk4PHdTSu5tkxnXaRccn', name='Read', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', 'offset': 555, 'limit': 20})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 13: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_012Mzk4PHdTSu5tkxnXaRccn', content='   555→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   556→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   557→ \n   558→             free(channel_name);\n   559→             return;\n   560→         }\n   561→ \n   562→         memset(channel_name, 0, CHANNELLEN+1);\n   563→         tvb_memcpy(tvb, channel_name, start_offset, length);\n   564→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   565→ \n   566→         proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   567→         start_offset = end_offset + 1;\n   568→     }\n   569→ \n   570→     free(channel_name);\n   571→     return;\n   572→ }\n   573→ \n   574→ static void\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 14: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='Now I see the exact text. Let me apply the fix:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 15: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01FSGxjUND54zvBGYTT3FvBJ', name='Edit', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', 'old_string': '        memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, length);\n        proto_item_append_text(tree, "Channel: %s", channel_name);', 'new_string': '        memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n        proto_item_append_text(tree, "Channel: %s", channel_name);'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 16: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01FSGxjUND54zvBGYTT3FvBJ', content='<tool_use_error>String to replace not found in file.\nString:         memset(channel_name, 0, CHANNELLEN+1);\n        tvb_memcpy(tvb, channel_name, start_offset, length);\n        proto_item_append_text(tree, "Channel: %s", channel_name);</tool_use_error>', is_error=True)], parent_tool_use_id=None)

================================================================================
Message 17: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01KEdqdsyk4w5invZpmPVZzt', name='Bash', input={'command': "sed -n '560,570p' /home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c | cat -A", 'description': 'View file content with special characters'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 18: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01KEdqdsyk4w5invZpmPVZzt', content='         }$\n $\n         memset(channel_name, 0, CHANNELLEN+1);$\n         tvb_memcpy(tvb, channel_name, start_offset, length);$\n         proto_item_append_text(tree, "Channel: %s", channel_name);$\n $\n         proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);$\n         start_offset = end_offset + 1;$\n     }$\n $\n     free(channel_name);$', is_error=False)], parent_tool_use_id=None)

================================================================================
Message 19: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='I see - there are 9 spaces (not 8) at the beginning. Let me check more carefully:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 20: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01Krp1k5HazRqmEccVqi5Vfy', name='Bash', input={'command': "sed -n '562,564p' /home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c | xxd | head -40", 'description': 'Show hex dump of the file lines'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 21: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01Krp1k5HazRqmEccVqi5Vfy', content='00000000: 2020 2020 2020 2020 206d 656d 7365 7428           memset(\n00000010: 6368 616e 6e65 6c5f 6e61 6d65 2c20 302c  channel_name, 0,\n00000020: 2043 4841 4e4e 454c 4c45 4e2b 3129 3b0a   CHANNELLEN+1);.\n00000030: 2020 2020 2020 2020 2074 7662 5f6d 656d           tvb_mem\n00000040: 6370 7928 7476 622c 2063 6861 6e6e 656c  cpy(tvb, channel\n00000050: 5f6e 616d 652c 2073 7461 7274 5f6f 6666  _name, start_off\n00000060: 7365 742c 206c 656e 6774 6829 3b0a 2020  set, length);.  \n00000070: 2020 2020 2020 2070 726f 746f 5f69 7465         proto_ite\n00000080: 6d5f 6170 7065 6e64 5f74 6578 7428 7472  m_append_text(tr\n00000090: 6565 2c20 2243 6861 6e6e 656c 3a20 2573  ee, "Channel: %s\n000000a0: 222c 2063 6861 6e6e 656c 5f6e 616d 6529  ", channel_name)\n000000b0: 3b0a                                     ;.', is_error=False)], parent_tool_use_id=None)

================================================================================
Message 22: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='I see - 9 spaces indentation. Let me try with the exact content:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 23: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01HG3WYUudAK8ZiKG2PxYAu1', name='Edit', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', 'old_string': '         memset(channel_name, 0, CHANNELLEN+1);\n         tvb_memcpy(tvb, channel_name, start_offset, length);\n         proto_item_append_text(tree, "Channel: %s", channel_name);', 'new_string': '         memset(channel_name, 0, CHANNELLEN+1);\n         tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n         proto_item_append_text(tree, "Channel: %s", channel_name);'})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 24: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01HG3WYUudAK8ZiKG2PxYAu1', content='The file /home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c has been updated. Here\'s the result of running `cat -n` on a snippet of the edited file:\n   558→             free(channel_name);\n   559→             return;\n   560→         }\n   561→ \n   562→         memset(channel_name, 0, CHANNELLEN+1);\n   563→         tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   564→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   565→ \n   566→         proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   567→         start_offset = end_offset + 1;\n   568→     }', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 25: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text='The fix has been applied. Let me verify the change was applied correctly by showing the context around the fixed line:')], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 26: AssistantMessage
================================================================================
AssistantMessage(content=[ToolUseBlock(id='toolu_01CxS1cUadJuBpyDKVf7oXM7', name='Read', input={'file_path': '/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c', 'offset': 525, 'limit': 50})], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 27: UserMessage
================================================================================
UserMessage(content=[ToolResultBlock(tool_use_id='toolu_01CxS1cUadJuBpyDKVf7oXM7', content='   525→ static void\n   526→ dissect_irc_names(tvbuff_t *tvb, proto_item *item, int offset)\n   527→ {\n   528→     proto_tree *tree;\n   529→     int start_offset;\n   530→     int end_offset;\n   531→     int length;\n   532→     uint8_t *channel_name;\n   533→ \n   534→     if (tvb_get_uint8(tvb, offset) != \'#\')\n   535→         return;\n   536→     \n   537→     channel_name = malloc(CHANNELLEN+1);\n   538→ \n   539→     if (channel_name == NULL ) {\n   540→         return;\n   541→     }\n   542→ \n   543→     start_offset = offset;\n   544→ \n   545→     tree = proto_item_add_subtree(item, ett_irc_request_command_names);\n   546→ \n   547→     while(tvb_offset_exists(tvb, start_offset) ) {\n   548→         length = tvb_captured_length_remaining(tvb, start_offset);\n   549→         end_offset = tvb_find_uint8(tvb, start_offset, length, \',\');\n   550→ \n   551→         if ( end_offset == -1 ) {\n   552→             proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, length, ENC_ASCII);\n   553→             \n   554→             memset(channel_name, 0, CHANNELLEN+1);\n   555→             tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   556→             proto_item_append_text(tree, "Channel: %s", channel_name);\n   557→ \n   558→             free(channel_name);\n   559→             return;\n   560→         }\n   561→ \n   562→         memset(channel_name, 0, CHANNELLEN+1);\n   563→         tvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n   564→         proto_item_append_text(tree, "Channel: %s", channel_name);\n   565→ \n   566→         proto_tree_add_item(tree, hf_irc_request_command_names_channel, tvb, start_offset, end_offset-start_offset, ENC_ASCII);\n   567→         start_offset = end_offset + 1;\n   568→     }\n   569→ \n   570→     free(channel_name);\n   571→     return;\n   572→ }\n   573→ \n   574→ static void\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n', is_error=None)], parent_tool_use_id=None)

================================================================================
Message 28: AssistantMessage
================================================================================
AssistantMessage(content=[TextBlock(text="The fix has been successfully applied. Now both `tvb_memcpy` calls in the `dissect_irc_names` function (lines 555 and 563) properly limit the copy size to `CHANNELLEN` to prevent buffer overflow.\n\n## Summary\n\n**Bug:** Heap-buffer-overflow in `dissect_irc_names` function in `/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c`\n\n**Root Cause:** In the `while` loop at line 563, `tvb_memcpy` was copying `length` bytes into `channel_name` buffer, but the buffer is only allocated with `CHANNELLEN+1` (51) bytes. When the input contained a channel name longer than 50 characters (as in the test case with 124 'a' characters), the copy would overflow the heap buffer.\n\n**Fix Applied:** Changed line 563 from:\n```c\ntvb_memcpy(tvb, channel_name, start_offset, length);\n```\nto:\n```c\ntvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n```\n\nThis ensures the copy is limited to at most `CHANNELLEN` (50) bytes, preventing the buffer overflow. This is consistent with how the same function handles the copy at line 555 (when there's no comma delimiter found).")], model='claude-opus-4-5-20251101', parent_tool_use_id=None, error=None)

================================================================================
Message 29: ResultMessage
================================================================================
ResultMessage(subtype='success', duration_ms=64759, duration_api_ms=86659, is_error=False, num_turns=11, session_id='e3ee9f66-d216-4ba4-a879-2ca3b41cbc40', total_cost_usd=0.5054390000000001, usage={'input_tokens': 13, 'cache_creation_input_tokens': 34488, 'cache_read_input_tokens': 384124, 'output_tokens': 2383, 'server_tool_use': {'web_search_requests': 0, 'web_fetch_requests': 0}, 'service_tier': 'standard', 'cache_creation': {'ephemeral_1h_input_tokens': 0, 'ephemeral_5m_input_tokens': 34488}}, result="The fix has been successfully applied. Now both `tvb_memcpy` calls in the `dissect_irc_names` function (lines 555 and 563) properly limit the copy size to `CHANNELLEN` to prevent buffer overflow.\n\n## Summary\n\n**Bug:** Heap-buffer-overflow in `dissect_irc_names` function in `/home/user/crete/.cache/official-afc-wireshark/epan/dissectors/packet-irc.c`\n\n**Root Cause:** In the `while` loop at line 563, `tvb_memcpy` was copying `length` bytes into `channel_name` buffer, but the buffer is only allocated with `CHANNELLEN+1` (51) bytes. When the input contained a channel name longer than 50 characters (as in the test case with 124 'a' characters), the copy would overflow the heap buffer.\n\n**Fix Applied:** Changed line 563 from:\n```c\ntvb_memcpy(tvb, channel_name, start_offset, length);\n```\nto:\n```c\ntvb_memcpy(tvb, channel_name, start_offset, (length < CHANNELLEN) ? length : CHANNELLEN);\n```\n\nThis ensures the copy is limited to at most `CHANNELLEN` (50) bytes, preventing the buffer overflow. This is consistent with how the same function handles the copy at line 555 (when there's no comma delimiter found).", structured_output=None)
