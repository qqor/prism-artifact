diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
index 83a9cb1..234b064 100644
--- a/libexif/apple/exif-mnote-data-apple.c
+++ b/libexif/apple/exif-mnote-data-apple.c
@@ -235,12 +235,32 @@ exif_mnote_data_apple_get_value(ExifMnoteData *md, unsigned int i, char *val, un
 
 int
 exif_mnote_data_apple_identify(const ExifData *ed, const ExifEntry *e) {
-    int variant;
+    int variant = 0;
+    const char *apple_ios = "Apple iOS";
+    size_t apple_ios_len = 9; /* Length of "Apple iOS" */
 
-    if (!strcmp((const char *) e->data, "Apple iOS")) {
-        variant = 1;
-    } else {
-        variant = 0;
+    /* Check if entry and data are valid */
+    if (!e || !e->data) {
+        return variant;
+    }
+
+    /* Check if buffer is large enough to contain "Apple iOS"
+     * We need at least 9 bytes for the string, and we check for null terminator
+     * within the buffer bounds */
+    if (e->size >= apple_ios_len) {
+        /* Use memcmp to avoid buffer overflow - compare up to available size */
+        if (e->size > apple_ios_len) {
+            /* If size is larger, we can safely check for null terminator */
+            if (memcmp(e->data, apple_ios, apple_ios_len) == 0 &&
+                e->data[apple_ios_len] == '\0') {
+                variant = 1;
+            }
+        } else if (e->size == apple_ios_len) {
+            /* Exact size match - just compare the bytes */
+            if (memcmp(e->data, apple_ios, apple_ios_len) == 0) {
+                variant = 1;
+            }
+        }
     }
 
     return variant;
