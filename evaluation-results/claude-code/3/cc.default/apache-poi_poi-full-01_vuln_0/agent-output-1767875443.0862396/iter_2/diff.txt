diff --git a/poi-scratchpad/src/main/java/org/apache/poi/hmef/CompressedRTF.java b/poi-scratchpad/src/main/java/org/apache/poi/hmef/CompressedRTF.java
index 46988b9ec..52635575c 100644
--- a/poi-scratchpad/src/main/java/org/apache/poi/hmef/CompressedRTF.java
+++ b/poi-scratchpad/src/main/java/org/apache/poi/hmef/CompressedRTF.java
@@ -25,6 +25,7 @@ import java.nio.charset.StandardCharsets;
 import org.apache.poi.util.IOUtils;
 import org.apache.poi.util.LZWDecompresser;
 import org.apache.poi.util.LittleEndian;
+import org.apache.poi.util.RecordFormatException;
 
 
 /**
@@ -52,6 +53,9 @@ public final class CompressedRTF extends LZWDecompresser {
       "\\fmodern \\fscript \\fdecor MS Sans SerifSymbolArialTimes New RomanCourier" +
       "{\\colortbl\\red0\\green0\\blue0\n\r\\par \\pard\\plain\\f0\\fs20\\b\\i\\u\\tab\\tx";
 
+   // Maximum allowed decompressed output size (50 MB) - prevents DoS attacks from malicious LZW data
+   private static final int MAX_OUTPUT_SIZE = 50_000_000;
+
    private int compressedSize;
    private int decompressedSize;
 
@@ -82,16 +86,18 @@ public final class CompressedRTF extends LZWDecompresser {
 
       // Do we need to do anything?
       if(compressionType == UNCOMPRESSED_SIGNATURE_INT) {
-         // Nope, nothing fancy to do
-         IOUtils.copy(src, res);
+         // Nope, nothing fancy to do - but limit output to prevent DoS
+         IOUtils.copy(src, res, MAX_OUTPUT_SIZE);
+         return;
       } else if(compressionType == COMPRESSED_SIGNATURE_INT) {
          // We need to decompress it below
       } else {
          throw new IllegalArgumentException("Invalid compression signature " + compressionType);
       }
 
-      // Have it processed
-      super.decompress(src, res);
+      // Have it processed with output size limiting to prevent DoS attacks
+      OutputLimitingStream limitedRes = new OutputLimitingStream(res, MAX_OUTPUT_SIZE);
+      super.decompress(src, limitedRes);
    }
 
    /**
@@ -127,4 +133,49 @@ public final class CompressedRTF extends LZWDecompresser {
      // Start adding new codes after the constants
      return preload.length;
    }
+
+   /**
+    * Output stream wrapper that limits total bytes written.
+    * Prevents denial-of-service attacks from malicious compressed data
+    * that could produce unbounded output.
+    */
+   private static class OutputLimitingStream extends OutputStream {
+      private final OutputStream delegate;
+      private final int maxBytes;
+      private int bytesWritten;
+
+      OutputLimitingStream(OutputStream delegate, int maxBytes) {
+         this.delegate = delegate;
+         this.maxBytes = maxBytes;
+         this.bytesWritten = 0;
+      }
+
+      @Override
+      public void write(int b) throws IOException {
+         if (bytesWritten >= maxBytes) {
+            throw new RecordFormatException("Decompressed data exceeds maximum allowed size of " + maxBytes + " bytes");
+         }
+         delegate.write(b);
+         bytesWritten++;
+      }
+
+      @Override
+      public void write(byte[] b, int off, int len) throws IOException {
+         if (bytesWritten + len > maxBytes) {
+            throw new RecordFormatException("Decompressed data exceeds maximum allowed size of " + maxBytes + " bytes");
+         }
+         delegate.write(b, off, len);
+         bytesWritten += len;
+      }
+
+      @Override
+      public void flush() throws IOException {
+         delegate.flush();
+      }
+
+      @Override
+      public void close() throws IOException {
+         delegate.close();
+      }
+   }
 }
