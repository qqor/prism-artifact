
================================================================================
Response 1
================================================================================
Now I understand the code better. Let me analyze why the previous patches failed and what the real issue is.

## Analysis of Why the Previous Patches Failed

The previous patches added iteration counters to `decode2D()`, `decodeRowType4()`, and `decodeRun()`. However, looking at the code more carefully, I can see the real problem:

1. **The `readBit()` method at line 409-425**: This is the core issue. When `in.read()` returns `-1` (EOF), it throws an `EOFException`. However, the problem is that the Huffman tree traversal loops can spin indefinitely if they encounter sequences that don't lead to valid codes **and** they keep looping without making progress.

2. **The `decodeRowType4()` method (lines 275-290)**: This is the `eof:` while loop that searches for EOL codes. The problem is in the `continue eof;` statement at line 283. When `n.walk(readBit())` returns `null`, it continues the outer loop, restarting from `eolOnlyTree.root`. This creates an infinite loop if the stream contains malformed data that never matches an EOL code.

3. **The `decode2D()` method (lines 185-241)**: Similarly, when `n.walk(readBit())` returns `null` at line 190, it uses `continue mode;` to restart the mode loop. This can also loop infinitely.

4. **The key insight**: The previous patches placed iteration counters inside the **inner** `while(true)` loops, but the real problem is that `continue mode;` and `continue eof;` jump to the **outer** loops, resetting `n` to `root` each time. The iteration counters in the inner loops don't help because the loops exit when `n` becomes null and the outer loops restart.

## New Approach

Instead of counting iterations, I'll take a different approach: **track the number of bits read** during decoding. This is a more robust metric because:
1. A valid CCITT stream has a finite number of bits
2. If we read way more bits than expected for the data, we're clearly in an infinite loop
3. We can use the `columns` parameter to estimate a reasonable maximum

Let me implement this by adding a bit counter that's checked in the `readBit()` method itself:

================================================================================
Response 2
================================================================================
Now let me update the `readBit()` method to check the bit counter:

================================================================================
Response 3
================================================================================
Now I need to reset the bit counter at the start of each row decoding. Let me update the `decodeRow()` method:

================================================================================
Response 4
================================================================================
Now let me verify the fix by reading the complete file to ensure everything is correct:

================================================================================
Response 5
================================================================================
The fix looks correct. Here's a summary of the changes I made:

## Why the Previous Patches Failed

The previous patches added iteration counters to the **inner** `while(true)` loops in `decode2D()`, `decodeRowType4()`, and `decodeRun()`. However, the problem is that:

1. When `n.walk(readBit())` returns `null`, the code executes `continue mode;` or `continue eof;`, which jumps to the **outer** labeled loops
2. This resets `n` back to `tree.root`, and the inner iteration counter never accumulates properly
3. The malformed data could cause the loops to repeatedly restart from the root without ever matching a valid code, creating an infinite loop that the inner iteration counters couldn't detect

## New Approach - Why It Works

Instead of counting iterations in individual loops, the new fix:

1. **Tracks bits read globally per row** in the `readBit()` method itself
2. **Every bit read increments the counter**, regardless of which loop or method called `readBit()`
3. **Resets the counter at the start of each row** in `decodeRow()`
4. **Uses a generous maximum** (`columns * 16` or at least 65536 bits) that allows valid data but prevents infinite loops

This approach is more robust because:
- It catches infinite loops regardless of which code path is spinning
- It doesn't matter whether the outer or inner loops are the problem
- Any malformed data that causes repeated `readBit()` calls will eventually hit the limit
- The limit is based on a realistic upper bound for valid CCITT-encoded data

## The Patch

```diff
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecoderStream.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecoderStream.java
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecoderStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecoderStream.java
@@ -72,6 +72,10 @@ final class CCITTFaxDecoderStream extends FilterInputStream {
 
     private int lastChangingElement = 0;
 
+    // PDFBOX-5765: track bits read per row to prevent infinite loops with malformed data
+    private int bitsReadInRow = 0;
+    private final int maxBitsPerRow;
+
     /**
      * Creates a CCITTFaxDecoderStream.
      * This constructor may be used for CCITT streams embedded in PDF files,
@@ -97,6 +101,11 @@ final class CCITTFaxDecoderStream extends FilterInputStream {
         changesReferenceRow = new int[columns + 2];
         changesCurrentRow = new int[columns + 2];
 
+        // PDFBOX-5765: Set a reasonable maximum for bits read per row
+        // In worst case, each pixel could require up to 13 bits (max code length) plus EOL overhead
+        // Using columns * 16 provides generous margin for valid data while preventing infinite loops
+        this.maxBitsPerRow = Math.max(columns * 16, 65536);
+
         switch (type) {
             case TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE:
                 optionByteAligned = byteAligned;
@@ -304,6 +313,9 @@ final class CCITTFaxDecoderStream extends FilterInputStream {
     }
 
     private void decodeRow() throws IOException {
+        // PDFBOX-5765: Reset bit counter for each row
+        bitsReadInRow = 0;
+
         switch (type) {
             case TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE:
                 decodeRowType2();
@@ -406,6 +418,11 @@ final class CCITTFaxDecoderStream extends FilterInputStream {
     int bufferPos = -1;
 
     private boolean readBit() throws IOException {
+        // PDFBOX-5765: Check if we've read too many bits for this row (indicates infinite loop)
+        if (++bitsReadInRow > maxBitsPerRow) {
+            throw new IOException("Maximum bits exceeded while decoding CCITT row - possible malformed data");
+        }
+
         if (bufferPos < 0 || bufferPos > 7) {
             buffer = in.read();
```
