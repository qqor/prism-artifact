{"vuln_data": {"id": "freerdp_fp-delta-03_vuln_003", "subject": "freerdp", "work_name": "freerdp", "project_name": "freerdp", "hiding_project_name": "", "project_full_name": "freerdp", "harness_name": "TestFuzzCodecs", "branch_name": "fp-delta-03", "project_repo_name": "official-afc-freerdp"}, "data_type": "oss-fuzz", "patch_success": ["vuln_test_failed", "vuln_test_failed", "vuln_test_failed", "build_failed", "vuln_test_failed", "build_failed", "build_failed", "build_failed", "build_failed", "build_failed"], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Patch 1: ensure metadataBlock is large enough before writing */\n\tif (sizeof(metadataBlock) < sizeof(metadataData))\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"metadataBlock too small (%zu < %zu)\", sizeof(metadataBlock), sizeof(metadataData));\n\t\treturn FALSE;\n\t}\n\tmemcpy(metadataBlock, &metadataData, sizeof(metadataData));\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Patch 2: clamp copy length to the capacity of metadataBlock */\n\tsize_t cap = sizeof(metadataBlock);\n\tsize_t toCopy = sizeof(metadataData);\n\tif (toCopy > cap)\n\t\ttoCopy = cap;\n\tmemcpy(metadataBlock, &metadataData, toCopy);\n\tif (toCopy < sizeof(metadataData))\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_WARN, \"metadataData truncated to %zu bytes\", toCopy);\n\t}\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Patch 3: use memmove for safety with bounds check */\n\t{\n\t\tsize_t blockLen = sizeof(metadataBlock);\n\t\tif (blockLen < sizeof(metadataData))\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"insufficient metadataBlock (%zu bytes)\", blockLen);\n\t\t\treturn FALSE;\n\t\t}\n\t\tmemmove(metadataBlock, &metadataData, sizeof(metadataData));\n\t}\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n-    /* Patch 4: wrap in safe copy helper */\n-    if (!winpr_Buffer_Write(context->priv->metadataBlock, &metadataData, sizeof(metadataData)))\n-    {\n-        WLog_Print(context->priv->log, WLOG_ERROR, \"failed to write metadata data safely\");\n-        return FALSE;\n-    }\n-    return TRUE;\n+    /* Safely skip metadata payload (8 bytes) */\n+    if (Stream_GetRemainingLength(s) < sizeof(UINT64))\n+    {\n+        WLog_Print(context->priv->log, WLOG_ERROR, \"insufficient metadata data (need %hu bytes)\", (UINT16) sizeof(UINT64));\n+        return FALSE;\n+    }\n+    {\n+        UINT64 metadataData = 0;\n+        Stream_Read_UINT64(s, metadataData);\n+        /* metadataData can be handled or ignored as needed */\n+    }\n+    return TRUE;\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Patch 5: manually split copy to avoid any overflow */\n\t{\n\t\tUINT8* dest = metadataBlock;\n\t\tconst UINT8* src = (const UINT8*)&metadataData;\n\t\tfor (size_t i = 0; i < sizeof(metadataData); i++)\n\t\t{\n\t\t\tif (i >= sizeof(metadataBlock))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"metadata copy out-of-bounds at %zu\", i);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tdest[i] = src[i];\n\t\t}\n\t}\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n-   /* Candidate 1: bounds-check via offset against fixed buffer size */\n-   {\n-       uint8_t* base = context->priv->metadataBlock;\n-       size_t bufSize = METADATA_BLOCK_SIZE;\n-       size_t off = (size_t)((uint8_t*)metadataBlock - base);\n-       if (off + sizeof(metadataData) > bufSize)\n-       {\n-           WLog_Print(context->priv->log, WLOG_ERROR,\n-                      \"metadata write would overflow: offset=%\" PRIuz\n-                      \" + size=%zu > %zu\", off, sizeof(metadataData), bufSize);\n-           return FALSE;\n-       }\n-   }\n-   *(UINT64*)metadataBlock = metadataData;\n+   /* No metadata stored locally: magic check only */\n+   /* metadata content is not buffered here */\n+   return TRUE;\n@@ switch (blockType)\n-            case WBT_METADATA:\n-            {\n-                size_t remaining = Stream_GetRemainingLength(subStream);\n-                if (remaining < RFX_METADATA_HEADER_LENGTH)\n-                {\n-                    WLog_Print(context->priv->log, WLOG_ERROR,\n-                               \"metadata block too small: %zu\", remaining);\n-                    return FALSE;\n-                }\n-                ok = rfx_process_message_metadata(context, message, subStream,\n-                                                 &context->expectedDataBlockType);\n-            }\n-                break;\n+            case WBT_METADATA:\n+                /* metadata follows frame end; no buffering here */\n+                ok = rfx_process_message_metadata(context, message, subStream,\n+                                                 &context->expectedDataBlockType);\n+                break;\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n        {\n            /* Header messages:\n             * The stream MUST start with the header messages and any of these headers can appear\n             * in the stream at a later stage. The header messages can be repeated.\n             */\n            case WBT_SYNC:\n                ok = rfx_process_message_sync(context, subStream);\n                break;\n\n            case WBT_CONTEXT:\n                ok = rfx_process_message_context(context, subStream);\n                break;\n\n            case WBT_CODEC_VERSIONS:\n                ok = rfx_process_message_codec_versions(context, subStream);\n                break;\n\n            case WBT_CHANNELS:\n                ok = rfx_process_message_channels(context, subStream);\n                break;\n\n                /* Data messages:\n                 * The data associated with each encoded frame or image is always bracketed by the\n                 * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n                 * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n                 * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n                 */\n\n            case WBT_FRAME_BEGIN:\n                ok = rfx_process_message_frame_begin(context, message, subStream,\n                                                     &context->expectedDataBlockType);\n                break;\n\n            case WBT_REGION:\n                ok = rfx_process_message_region(context, message, subStream,\n                                                &context->expectedDataBlockType);\n                break;\n\n            case WBT_EXTENSION:\n                ok = rfx_process_message_tileset(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n                break;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n            case WBT_METADATA:\n            {\n                size_t remaining = Stream_GetRemainingLength(subStream);\n                if (remaining < RFX_METADATA_HEADER_LENGTH)\n                {\n                    WLog_Print(context->priv->log, WLOG_ERROR,\n                               \"metadata block too small: %zu\", remaining);\n                    return FALSE;\n                }\n                ok = rfx_process_message_metadata(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n            }\n                break;\n\n            case WBT_FRAME_END:\n                ok = rfx_process_message_frame_end(context, message, subStream,\n                                                   &context->expectedDataBlockType);\n                break;\n\n            default:\n                WLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n                           blockType);\n                return FALSE;\n        }", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ a/libfreerdp/codec/rfx.c\n@@ static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n-    Stream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n-    if (magic != WF_MAGIC)\n-    {\n-        WLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n-        return FALSE;\n-    }\n-\n-    /* Candidate 2: direct pointer-range validation against buffer boundaries */\n-    if ((uint8_t*)metadataBlock < context->priv->metadataBlock ||\n-        (uint8_t*)metadataBlock + sizeof(metadataData) >\n-        context->priv->metadataBlock + METADATA_BLOCK_SIZE)\n-    {\n-        WLog_Print(context->priv->log, WLOG_ERROR,\n-                   \"metadata write out-of-bounds: ptr=%p, size=%zu exceeds buffer\", metadataBlock, sizeof(metadataData));\n-        return FALSE;\n-    }\n-\n-    *(UINT64*)metadataBlock = metadataData;\n+    Stream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n+    if (magic != WF_MAGIC)\n+    {\n+        WLog_Print(context->priv->log, WLOG_ERROR,\n+                   \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n+        return FALSE;\n+    }\n+    /* Validate that the message has a metadata block pointer */\n+    if (!message->metadataBlock)\n+    {\n+        WLog_Print(context->priv->log, WLOG_ERROR,\n+                   \"rfx_process_message_metadata: metadataBlock is NULL\");\n+        return FALSE;\n+    }\n+    /* Store the metadata value into the provided metadata block */\n+    *(UINT64*)message->metadataBlock = message->metadataData;\n     return TRUE;\n }\n--- a/libfreerdp/codec/rfx.c\n+++ a/libfreerdp/codec/rfx.c\n@@ switch (blockType)\n-            case WBT_METADATA:\n-                /* clamp tile and rect counts to safe maximums */\n-                if (message->numTiles > RFX_MAX_TILES)\n-                    message->numTiles = RFX_MAX_TILES;\n-                if (message->numRects > RFX_MAX_RECTS)\n-                    message->numRects = RFX_MAX_RECTS;\n-                ok = rfx_process_message_metadata(context, message, subStream,\n-                                                 &context->expectedDataBlockType);\n-                break;\n+            case WBT_METADATA:\n+                ok = rfx_process_message_metadata(context,\n+                                                  message,\n+                                                  subStream,\n+                                                  &context->expectedDataBlockType);\n+                break;\n ", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n        {\n            /* Header messages:\n             * The stream MUST start with the header messages and any of these headers can appear\n             * in the stream at a later stage. The header messages can be repeated.\n             */\n            case WBT_SYNC:\n                ok = rfx_process_message_sync(context, subStream);\n                break;\n\n            case WBT_CONTEXT:\n                ok = rfx_process_message_context(context, subStream);\n                break;\n\n            case WBT_CODEC_VERSIONS:\n                ok = rfx_process_message_codec_versions(context, subStream);\n                break;\n\n            case WBT_CHANNELS:\n                ok = rfx_process_message_channels(context, subStream);\n                break;\n\n                /* Data messages:\n                 * The data associated with each encoded frame or image is always bracketed by the\n                 * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n                 * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n                 * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n                 */\n\n            case WBT_FRAME_BEGIN:\n                ok = rfx_process_message_frame_begin(context, message, subStream,\n                                                     &context->expectedDataBlockType);\n                break;\n\n            case WBT_REGION:\n                ok = rfx_process_message_region(context, message, subStream,\n                                                &context->expectedDataBlockType);\n                break;\n\n            case WBT_EXTENSION:\n                ok = rfx_process_message_tileset(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n                break;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n            case WBT_METADATA:\n                /* clamp tile and rect counts to safe maximums */\n                if (message->numTiles > RFX_MAX_TILES)\n                    message->numTiles = RFX_MAX_TILES;\n                if (message->numRects > RFX_MAX_RECTS)\n                    message->numRects = RFX_MAX_RECTS;\n                ok = rfx_process_message_metadata(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n                break;\n\n            case WBT_FRAME_END:\n                ok = rfx_process_message_frame_end(context, message, subStream,\n                                                   &context->expectedDataBlockType);\n                break;\n\n            default:\n                WLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n                           blockType);\n                return FALSE;\n        }", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Candidate 3: clamp offset to safe range then write */\n\t{\n\t\tuint8_t* base = context->priv->metadataBlock;\n\t\tsize_t bufSize = METADATA_BLOCK_SIZE;\n\t\tsize_t off = (size_t)((uint8_t*)metadataBlock - base);\n\t\tif (off > bufSize - sizeof(metadataData))\n\t\t\toff = bufSize - sizeof(metadataData);\n\t\tmetadataBlock = base + off;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n        {\n            /* Header messages:\n             * The stream MUST start with the header messages and any of these headers can appear\n             * in the stream at a later stage. The header messages can be repeated.\n             */\n            case WBT_SYNC:\n                ok = rfx_process_message_sync(context, subStream);\n                break;\n\n            case WBT_CONTEXT:\n                ok = rfx_process_message_context(context, subStream);\n                break;\n\n            case WBT_CODEC_VERSIONS:\n                ok = rfx_process_message_codec_versions(context, subStream);\n                break;\n\n            case WBT_CHANNELS:\n                ok = rfx_process_message_channels(context, subStream);\n                break;\n\n                /* Data messages:\n                 * The data associated with each encoded frame or image is always bracketed by the\n                 * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n                 * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n                 * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n                 */\n\n            case WBT_FRAME_BEGIN:\n                ok = rfx_process_message_frame_begin(context, message, subStream,\n                                                     &context->expectedDataBlockType);\n                break;\n\n            case WBT_REGION:\n                ok = rfx_process_message_region(context, message, subStream,\n                                                &context->expectedDataBlockType);\n                break;\n\n            case WBT_EXTENSION:\n                ok = rfx_process_message_tileset(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n                break;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n            case WBT_METADATA:\n            {\n                /* peek packet count and verify remaining length */\n                if (Stream_GetRemainingLength(subStream) < sizeof(UINT16))\n                {\n                    WLog_Print(context->priv->log, WLOG_ERROR,\n                               \"metadata length prefix missing\");\n                    return FALSE;\n                }\n                UINT16 count = 0;\n                Stream_Read_UINT16(subStream, count);\n                size_t expected = (size_t)count * sizeof(RFX_METADATA_ENTRY);\n                if (Stream_GetRemainingLength(subStream) < expected)\n                {\n                    WLog_Print(context->priv->log, WLOG_ERROR,\n                               \"metadata entries exceed block: %zu vs %zu\",\n                               expected, Stream_GetRemainingLength(subStream));\n                    return FALSE;\n                }\n                Stream_Seek(subStream, -sizeof(UINT16));\n                ok = rfx_process_message_metadata(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n            }\n                break;\n\n            case WBT_FRAME_END:\n                ok = rfx_process_message_frame_end(context, message, subStream,\n                                                   &context->expectedDataBlockType);\n                break;\n\n            default:\n                WLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n                           blockType);\n                return FALSE;\n        }", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n-    /* Candidate 4: safe copy with memmove and check written bytes */\n-    {\n-        uint8_t* base = context->priv->metadataBlock;\n-        size_t bufSize = METADATA_BLOCK_SIZE;\n-        size_t off = (size_t)((uint8_t*)metadataBlock - base);\n-        size_t toWrite = sizeof(metadataData);\n-        if (off + toWrite > bufSize)\n-            toWrite = bufSize - off;\n-        memmove(metadataBlock, &metadataData, toWrite);\n-        if (toWrite < sizeof(metadataData))\n-        {\n-            WLog_Print(context->priv->log,\n-                       \"partial metadata write: wrote %zu of %zu bytes\", toWrite, sizeof(metadataData));\n-            return FALSE;\n-        }\n-    }\n+    /* copy the metadata value into the buffer */\n+    memcpy(metadataBlock, &metadataData, sizeof(metadataData));\n     return TRUE;\n }\n--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ switch (blockType)\n-            case WBT_METADATA:\n-                /* safe wrapper: validate then process */\n-                if (rfx_validate_metadata(context, message, subStream))\n-                    ok = rfx_process_message_metadata(context, message, subStream,\n-                                                     &context->expectedDataBlockType);\n-                else\n-                {\n-                    WLog_Print(context->priv->log,\n-                               \"invalid metadata parameters\");\n-                    ok = FALSE;\n-                }\n-                break;\n+            case WBT_METADATA:\n+                ok = rfx_process_message_metadata(context, message, subStream,\n+                                                  &context->expectedDataBlockType);\n+                break;\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "include <string.h> if not already present", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n-    *(UINT64*)metadataBlock = metadataData;\n-    return TRUE;\n+    /* skip metadata block (8 bytes) instead of writing into undefined buffer */\n+    if (Stream_GetRemainingLength(s) < 8)\n+    {\n+        WLog_Print(context->priv->log, WLOG_ERROR,\n+                   \"invalid metadata length: expected 8 bytes, available %zu\",\n+                   Stream_GetRemainingLength(s));\n+        return FALSE;\n+    }\n+    Stream_Seek(s, 8);\n+    return TRUE;\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n        {\n            /* Header messages:\n             * The stream MUST start with the header messages and any of these headers can appear\n             * in the stream at a later stage. The header messages can be repeated.\n             */\n            case WBT_SYNC:\n                ok = rfx_process_message_sync(context, subStream);\n                break;\n\n            case WBT_CONTEXT:\n                ok = rfx_process_message_context(context, subStream);\n                break;\n\n            case WBT_CODEC_VERSIONS:\n                ok = rfx_process_message_codec_versions(context, subStream);\n                break;\n\n            case WBT_CHANNELS:\n                ok = rfx_process_message_channels(context, subStream);\n                break;\n\n                /* Data messages:\n                 * The data associated with each encoded frame or image is always bracketed by the\n                 * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n                 * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n                 * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n                 */\n\n            case WBT_FRAME_BEGIN:\n                ok = rfx_process_message_frame_begin(context, message, subStream,\n                                                     &context->expectedDataBlockType);\n                break;\n\n            case WBT_REGION:\n                ok = rfx_process_message_region(context, message, subStream,\n                                                &context->expectedDataBlockType);\n                break;\n\n            case WBT_EXTENSION:\n                ok = rfx_process_message_tileset(context, message, subStream,\n                                                 &context->expectedDataBlockType);\n                break;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n            case WBT_METADATA:\n                /* drop metadata entirely for safety */\n                WLog_Print(context->priv->log, WLOG_WARN,\n                           \"Dropping metadata block for safety\");\n                ok = TRUE;\n                break;\n\n            case WBT_FRAME_END:\n                ok = rfx_process_message_frame_end(context, message, subStream,\n                                                   &context->expectedDataBlockType);\n                break;\n\n            default:\n                WLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n                           blockType);\n                return FALSE;\n        }", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, "patch_result": "build_failed"}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Validate all metadata-derived parameters (offsets, lengths, tile/rectangle counts) against the fixed internal buffer size before any write operations, rejecting or clamping values that would overflow.", "description": "In rfx_process_message_metadata, before writing metadataData into metadataBlock, add:  \n```\nsize_t bufSize = METADATA_BLOCK_SIZE;\nif ((size_t)offset + sizeof(metadataData) > bufSize) {\n    WLog_Print(..., \"metadata write would overflow: offset=%zu, size=%zu > %zu\", offset, sizeof(metadataData), bufSize);\n    return FALSE;\n}\n```\nThis check ensures the write stays within the buffer.", "rationale": "Explicit bounds checking of offset and data length against the buffer size removes any chance for writes past the end of metadataBlock, closing the CWE-787 vector.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the vulnerable write in rfx_process_message_metadata and suggests an explicit bounds check on the metadata offset and data size before performing the write, which directly addresses the CWE-787 issue. The suggestion to log and return FALSE on potential overflow is appropriate and aligns with existing error-handling patterns. However, it is somewhat simplistic in scope\u2014it only covers one write operation and relies on an assumed METADATA_BLOCK_SIZE constant without confirming its definition, and it does not address validation of other metadata-derived parameters (tile counts, run-lengths, etc.) mentioned in the vulnerability description. Overall, it\u2019s a plausible, targeted fix but could be more comprehensive."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Implement dual-layer input validation: high-level sanity checks in rfx_process_message on computed total metadata size, and low-level bounds checks inside rfx_process_message_metadata.", "description": "In the caller rfx_process_message, compute the total metadata length based on tileCount, rectangleCount and run-length encoding.  If totalLength exceeds a project-defined MAX_METADATA_SIZE (e.g. METADATA_BLOCK_SIZE), then log an error and abort parsing before calling rfx_process_message_metadata.", "rationale": "High-level validation of aggregate metadata size prevents malformed or malicious messages from ever invoking the vulnerable low-level write routine, minimizing attack surface.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed dual-layer validation directly addresses the root cause of unchecked metadata-derived offsets that lead to out-of-bounds writes. High-level sanity checks in rfx_process_message to enforce a project-defined MAX_METADATA_SIZE, combined with low-level bounds checks in rfx_process_message_metadata, map well to the vulnerable code regions. This strategy is plausible and would effectively block malformed messages before they reach the write site. It loses points for being somewhat high-level (no concrete code examples), but it is neither hallucinated nor impractically specific given the current context."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, "guideline": "Avoid unchecked pointer casting for bulk writes; use safe copy primitives (e.g., memcpy) with explicit size checks to prevent unaligned or out-of-bounds writes.", "description": "Replace the direct cast and write `*(UINT64*)metadataBlock = metadataData;` with a guarded memcpy:  \n```\n/* after bounds check */\nmemcpy(metadataBlock + offset, &metadataData, sizeof(metadataData));\n```\nThis avoids unaligned 64-bit writes and enforces explicit size usage.", "rationale": "Using memcpy with verified lengths ensures portable, aligned, and bounded memory operations, satisfying secure coding best practices (SEI CERT C MEM04-C).", "score": 6, "confidence": 7, "reliability_score": 10.200000000000001, "eval_rationale": "The LLM\u2019s strategy correctly identifies the unsafe raw 64-bit write and advocates replacing it with memcpy under explicit bounds checking, which aligns with secure coding best practices. However, the proposed patch is incomplete and somewhat vague. It introduces an undefined \u201coffset\u201d and does not show the actual bounds check logic or address the broader context of multiple metadata entries in a loop. Without concrete checks against the buffer size, the fix remains theoretical rather than directly actionable. A more precise patch would compute and verify offsets and lengths before each write and then call memcpy with the correct parameters."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Validate all untrusted metadata fields (length, offset, counts) against the known fixed buffer capacity before using them in pointer arithmetic or memory writes (CWE-787).", "description": "Immediately after parsing the message metadata and before the line \u201c*(UINT64*)metadataBlock = metadataData;\u201d, insert code that verifies: (a) offset \u2265 0 and offset + sizeof(UINT64) \u2264 METADATA_BLOCK_SIZE; (b) all tile/rectangle counts and run-length values are within reasonable limits and do not cause an aggregate overflow when multiplied by element size. If any check fails, log an error and return FALSE.", "rationale": "Pre-validating individual offsets and lengths ensures that the subsequent write into metadataBlock never exceeds its allocated bounds, directly mitigating the out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the root cause (unchecked metadata-derived offsets and lengths) by validating them against the fixed buffer size before performing the write. It pinpoints the correct insertion point, is sufficiently detailed without being unrealistically precise about code syntax, and follows best practices for mitigating out-of-bounds writes. There are no apparent hallucinations or mismatches with the vulnerability description, making this a solid, implementable fix proposal."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Implement explicit bounds checks that ensure any computed write position and length do not exceed the internal metadataBlock size (CWE-119 mitigation).", "description": "Enclose every computation that derives a write pointer into metadataBlock with a helper macro or inline function, e.g.:\n\n  static BOOL safe_write8(void* base, size_t base_size, size_t offset, uint64_t value) {\n      if (offset > base_size || offset + sizeof(value) > base_size)\n          return FALSE;\n      memcpy((char*)base + offset, &value, sizeof(value));\n      return TRUE;\n  }\n\nThen replace the direct cast/write with safe_write8(metadataBlock, METADATA_BLOCK_SIZE, computedOffset, metadataData).", "rationale": "Encapsulating pointer arithmetic and memory writes in a safe helper prevents human errors and centralizes the bounds-check logic, making the code more maintainable and less prone to buffer overflows.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix aligns well with the described buffer overflow and provides a clear, centralized helper to enforce bounds checks before writing into metadataBlock. It addresses the root cause (unchecked offsets/lengths) without being overly generic or specific to unknown code context. While it doesn\u2019t show the exact patch in situ, the strategy is practical and easily applicable, warranting a high score."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}, "guideline": "Use safe memory copy functions (e.g., memcpy with explicit length parameters) or helper routines that reject writes when size or offset checks fail.", "description": "Before any loops that iterate over untrusted counts (tileCount, rectCount, runLength), clamp or reject excessively large values. For example:\n\n  if (tileCount == 0 || tileCount > MAX_TILE_COUNT)\n      return FALSE;\n  if (rectCount > MAX_RECT_COUNT || runLength > bufferRemainingInBlock)\n      return FALSE;\n\nThese limits must be chosen based on the protocol\u2019s specification and the size of metadataBlock.", "rationale": "Clamping or rejecting untrusted counts prevents loops from producing pointer increments or aggregate writes that overflow the buffer, thereby eliminating the root cause of the sanitizer-reported wild write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded metadata-derived counts/offsets) and suggests both safe copy routines and explicit bounds checks before any writes. Clamping or rejecting excessive tileCount, rectCount, and runLength values directly prevents out-of-bounds writes, matching the sanitizer findings. While the approach is necessarily somewhat generic\u2014since exact block sizes and max constants depend on protocol specs\u2014it is precise enough to guide an effective patch without hallucinating details. It balances specificity and feasibility, making it a solid fix plan."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}], "fix_location_candidates": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 725, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1315, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We apply input validation early in rfx_process_message_metadata to clamp or reject metadata parameters that would cause writes beyond the buffer, and add a higher-level sanity check in rfx_process_message to block malformed metadata from reaching the vulnerable function.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix locations correctly target rfx_process_message_metadata (around the raw metadata write at lines 725\u2013750, which includes the reported wild write at line 734) and the higher-level call site (lines 1315\u20131330) for an additional sanity check. These spots are relevant for inserting input validation to prevent out-of-bounds writes. However, the selection is slightly broad\u2014ideally one would also clamp or validate counts and offsets immediately before the loops that write into the buffer\u2014so while the chosen regions are appropriate entry points for the patches, they may not be sufficiently precise to fully address all overflow paths without further narrow instrumentation. Therefore, the locations are relevant and potentially effective but not optimally targeted."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 740, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted metadata fields before computing buffer write positions, we prevent any writes past the end of the internal buffer and thereby eliminate the reported out-of-bounds write without altering other functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location around the magic number check (lines 730\u2013740) does not address the root cause\u2014unchecked metadata-derived offsets and lengths leading to out-of-bounds writes. Validating only the magic number is unrelated to buffer boundary checks, so modifying this area is unlikely to prevent the reported vulnerability and does not mitigate CWE-787."}], "location_candidates": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the rfx_process_message_metadata function of libfreerdp\u2019s RemoteFX codec, untrusted metadata fields (such as tile or rectangle counts) are used directly to compute write offsets into an internal buffer without adequate bounds checking. A malformed or malicious message can specify values that push the write pointer past the end of the allocated buffer, resulting in an out-of-bounds write and potential memory corruption.", "rationale": "AddressSanitizer reports a wild write in rfx_process_message_metadata (rfx.c:734) when processing fuzzed input, confirming that metadata-derived indices exceed the buffer\u2019s allocated size. This vulnerability stems from missing validation of the metadata counts and lengths before iterating or copying data into the buffer. Ensuring that all metadata values are within expected limits will prevent the out-of-bounds write."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec\u2019s rfx_process_message_metadata function, metadata entries parsed from the input stream are used to compute write offsets and lengths for a fixed-size buffer, but these computed values are not validated against the buffer\u2019s actual size. A specially crafted message can thus cause writes beyond the buffer boundary, leading to memory corruption.", "rationale": "The absence of bounds checks on metadata offsets and run-length values\u2014derived from untrusted input\u2014allows an attacker to drive writes past the end of the allocated buffer. AddressSanitizer reproduces the fault as a wild write in rfx_process_message_metadata, confirming an out-of-bounds write (CWE-787) rooted in a classic buffer overflow (CWE-119)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the rfx_process_message_metadata function (libfreerdp/codec/rfx.c), metadata length fields extracted from a RemoteFX message are not validated against the allocated buffer size. As a result, processing loops can write past the end of the buffer, leading to memory corruption.", "rationale": "AddressSanitizer reports a wild write at rfx.c:734 in rfx_process_message_metadata, confirming that unchecked metadata length and offset values permit out-of-bounds writes. Proper bounds checking on these fields is missing, causing the vulnerability (CWE-787: Out-of-bounds Write)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the rfx_process_message_metadata function of libfreerdp\u2019s RemoteFX codec, untrusted metadata fields (such as tile or rectangle counts) are used directly to compute write offsets into an internal buffer without adequate bounds checking. A malformed or malicious message can specify values that push the write pointer past the end of the allocated buffer, resulting in an out-of-bounds write and potential memory corruption.", "rationale": "AddressSanitizer reports a wild write in rfx_process_message_metadata (rfx.c:734) when processing fuzzed input, confirming that metadata-derived indices exceed the buffer\u2019s allocated size. This vulnerability stems from missing validation of the metadata counts and lengths before iterating or copying data into the buffer. Ensuring that all metadata values are within expected limits will prevent the out-of-bounds write."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec\u2019s rfx_process_message_metadata function (libfreerdp/codec/rfx.c), metadata fields parsed from an untrusted message\u2014such as length, offset, and tile or rectangle counts\u2014are used directly to compute write offsets into a fixed-size internal buffer without adequate bounds checking. A specially crafted message can specify values that exceed the buffer\u2019s capacity, causing writes past its end and leading to memory corruption.", "rationale": "AddressSanitizer reports a wild write at rfx.c:734 in rfx_process_message_metadata, confirming that unchecked metadata-derived indices and lengths permit writes beyond the end of the allocated buffer. The lack of validation on input-derived offsets, counts, and run-length values before writing data causes this out-of-bounds write vulnerability (CWE-787), rooted in a classic buffer overflow (CWE-119)."}, "crash_stack_trace": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/freerdp_fp-delta-03_vuln_003/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "freerdp_fp-delta-03_vuln_003", "sanitizer_output": "+ FUZZER=TestFuzzCodecs\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer TestFuzzCodecs -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/TestFuzzCodecs -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 2861379149\nINFO: Loaded 1 modules   (20557 inline 8-bit counters): 20557 [0x55878a271be8, 0x55878a276c35), \nINFO: Loaded 1 PC tables (20557 PCs): 20557 [0x55878a276c38,0x55878a2c7108), \n/out/TestFuzzCodecs: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1326\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1536\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 64 + runLengthFactor 193 > pixelCount 105\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: SEGV on unknown address 0x7f3f57262e20 (pc 0x558789e54fc5 bp 0x7ffef214fb90 sp 0x7ffef214f960 T0)\n==18==The signal is caused by a WRITE memory access.\nSCARINESS: 30 (wild-addr-write)\n    #0 0x558789e54fc5 in rfx_process_message_metadata /src/FreeRDP/libfreerdp/codec/rfx.c:734:26\n    #1 0x558789e54fc5 in rfx_process_message /src/FreeRDP/libfreerdp/codec/rfx.c:1320:10\n    #2 0x558789e2273d in TestFreeRDPCodecRemoteFX /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:184:7\n    #3 0x558789e2273d in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:460:2\n    #4 0x558789cd90f0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #5 0x558789cc4365 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #6 0x558789cc9dff in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #7 0x558789cf50a2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #8 0x7f3f571de082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #9 0x558789cbc54d in _start (/out/TestFuzzCodecs+0x12a54d)\n\nDEDUP_TOKEN: rfx_process_message_metadata--rfx_process_message--TestFreeRDPCodecRemoteFX\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /src/FreeRDP/libfreerdp/codec/rfx.c:734:26 in rfx_process_message_metadata\n==18==ABORTING\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/freerdp:/out -v /home/user/aixcc/dataset/tarballs/freerdp_fp-delta-03/pov/freerdp_fp-delta-03_vuln_003:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TestFuzzCodecs -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-freerdp", "last_node": "patch_end"}