{"vuln_data": {"id": "wireshark_ws-delta-02_vuln_004", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_icmp", "branch_name": "ws-delta-02", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["build_failed", "build_failed", "success", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "switch(c_type) {\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t\t}\n\t}", "patched_code": "case ICMP_EXT_ECHO_IDENT_NAME:\n    /* Identification Name must be printable */\n    {\n        /* Determine how many bytes we can safely copy (leave room for NUL) */\n        gint max_len = sizeof(ident_name) - 1;\n        gint copy_len = obj_length - 4;\n        if (copy_len > max_len)\n            copy_len = max_len;\n        /* Copy and NUL-terminate */\n        tvb_memcpy(tvb, ident_name, offset, copy_len);\n        ident_name[copy_len] = '\\0';\n\n        /* Trim at first non-printable character */\n        gint name_len = copy_len;\n        for (gint i = 0; i < copy_len; i++) {\n            if (!g_ascii_isprint(ident_name[i])) {\n                name_len = i;\n                break;\n            }\n        }\n\n        /* Display only the valid portion */\n        proto_tree_add_item(ext_object_tree,\n                            hf_icmp_int_ident_name_string,\n                            tvb,\n                            offset,\n                            name_len,\n                            ENC_ASCII);\n    }\n    break;", "func_def": "static bool\ndissect_interface_identification_object(tvbuff_t * tvb, int offset,\n\t\t\t\t     proto_tree * ext_object_tree,\n\t\t\t\t     proto_item * tf_object)", "func_ret": ["return true;", "return unknown_object;"]}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "switch(c_type) {\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t\t}\n\t}", "patched_code": "switch(c_type) {\n    case ICMP_EXT_ECHO_IDENT_NAME: {\n        /* compute number of bytes to copy (obj_length minus 4) */\n        gint copy_len = (obj_length > 4) ? obj_length - 4 : 0;\n        /* clamp to buffer size minus NUL */\n        copy_len = (copy_len < (sizeof(ident_name) - 1)) ? copy_len : (sizeof(ident_name) - 1);\n        /* safe copy and terminate */\n        tvb_memcpy(tvb, ident_name, offset, copy_len);\n        ident_name[copy_len] = '\\0';\n\n        /* printable check only up to copy_len */\n        for (gint i = 0; i < copy_len; i++) {\n            if (!g_ascii_isprint(ident_name[i]))\n                break;\n        }\n\n        /* add item with safe length */\n        proto_tree_add_item(ext_object_tree,\n                            hf_icmp_int_ident_name_string,\n                            tvb,\n                            offset,\n                            copy_len,\n                            ENC_ASCII);\n        break;\n    }\n    /* ... other cases ... */\n}", "func_def": "static bool\ndissect_interface_identification_object(tvbuff_t * tvb, int offset,\n\t\t\t\t     proto_tree * ext_object_tree,\n\t\t\t\t     proto_item * tf_object)", "func_ret": ["return true;", "return unknown_object;"]}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "switch(c_type) {\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t\t}\n\t}", "patched_code": "switch(c_type) {\n\t// FIXME: Crash CWE-787: Out-of-bounds Write\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* ensure we don\u2019t overflow */\n\t\t\tif (obj_length - 4 > (sizeof(ident_name) - 1))\n\t\t\t\treturn unknown_object;\n\n\t\t\t/* safe memcpy and terminate */\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\t\t\tident_name[obj_length - 4] = '\\0';\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t}\n}", "func_def": "static bool\ndissect_interface_identification_object(tvbuff_t * tvb, int offset,\n\t\t\t\t     proto_tree * ext_object_tree,\n\t\t\t\t     proto_item * tf_object)", "func_ret": ["return true;", "return unknown_object;"]}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "switch(c_type) {\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t\t}\n\t}", "patched_code": "switch(c_type) {\n\t// FIXME: Crash CWE-787: Out-of-bounds Write\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME: {\n\t\t\tconst guint8 *ptr = tvb_get_ptr(tvb, offset, obj_length - 4);\n\t\t\t/* use g_ascii_strncpy to avoid overflow */\n\t\t\tg_ascii_strncpy(ident_name, (const char *)ptr, sizeof(ident_name) - 1);\n\t\t\tident_name[sizeof(ident_name) - 1] = '\\0';\n\n\t\t\tfor (unsigned i = 0; i < strlen(ident_name); i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, strlen(ident_name), ENC_ASCII);\n\t\t\tbreak;\n\t\t}\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t}\n}", "func_def": "static bool\ndissect_interface_identification_object(tvbuff_t * tvb, int offset,\n\t\t\t\t     proto_tree * ext_object_tree,\n\t\t\t\t     proto_item * tf_object)", "func_ret": ["return true;", "return unknown_object;"]}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "switch(c_type) {\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t\t}\n\t}", "patched_code": "switch(c_type) {\n\t// FIXME: Crash CWE-787: Out-of-bounds Write\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* format safely into ident_name */\n\t\t\tsnprintf(ident_name, sizeof(ident_name), \"%.*s\", (int)(obj_length - 4), (const char *)tvb_get_ptr(tvb, offset, obj_length - 4));\n\n\t\t\tfor (unsigned i = 0; i < strlen(ident_name); i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, strlen(ident_name), ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_ADDRESS:\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_afi, tvb, offset, 2, ENC_BIG_ENDIAN, &afi);\n\t\t\toffset += 2;\n\t\t\tproto_tree_add_item_ret_uint(ext_object_tree, hf_icmp_int_ident_addr_length, tvb, offset, 1, ENC_BIG_ENDIAN, &addr_length);\n\t\t\toffset += 1;\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_reserved, tvb, offset, 1, ENC_NA);\n\t\t\toffset += 1;\n\t\t\tswitch(afi){\n\t\t\t\tcase AFNUM_INET: /* IPv4 */\n\t\t\t\t\twhile(addr_length >= 4 && tvb_reported_length_remaining(tvb, offset) >= 4) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\taddr_length -= 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase AFNUM_INET6: /* IPv6 */\n\t\t\t\t\twhile(addr_length >= 16 && tvb_reported_length_remaining(tvb, offset) >= 16) {\n\t\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_ipv6, tvb, offset, 16, ENC_NA);\n\t\t\t\t\t\toffset += 16;\n\t\t\t\t\t\taddr_length -= 16;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: /* Unknown ?! */\n\t\t\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_address, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n\t\t}\n}", "func_def": "static bool\ndissect_interface_identification_object(tvbuff_t * tvb, int offset,\n\t\t\t\t     proto_tree * ext_object_tree,\n\t\t\t\t     proto_item * tf_object)", "func_ret": ["return true;", "return unknown_object;"]}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}, "guideline": "Implement a policy to reject or sanitize extensions whose declared length exceeds the maximum supported size, logging or skipping invalid objects rather than blindly copying them. ", "description": "Before any copy, check if the extension\u2019s declared length exceeds 32 bytes. If so, log a protocol violation and skip dissecting this object (or clamp the length). For example:\n    if (name_len > sizeof(ident_name.i)-1) {\n        expert_add_info(..., \"ICMP extension name too long, skipping\");\n        return offset + total_object_length;\n    }\n    /* safe to copy */", "rationale": "Rejecting or skipping invalid objects enforces protocol correctness and prevents malformed packets from corrupting memory, adding an additional layer of defense.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by validating the name length against the 32-byte buffer before copying and logs/skips overly long objects\u2014this matches the vulnerability root cause and the guideline. The strategy is plausible and aligns with the sanitizer report. While somewhat generic (no exact line numbers or full code context), it is appropriately scoped given the available information and avoids over-specificity or hallucination."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}, "guideline": "Validate all packet-supplied lengths against the fixed buffer capacity before performing the copy (defense-in-depth for CWE-787/CWE-119).", "description": "Insert a check before the call to tvb_memcpy so that the actual number of bytes copied is at most sizeof(ident_name.i). For example:\n    guint8 name_len = tvb_get_guint8(tvb, offset+1);\n    guint copy_len = (name_len > sizeof(ident_name.i)-1) ? sizeof(ident_name.i)-1 : name_len;\n    tvb_memcpy(tvb, offset+2, ident_name.i, copy_len);\n    ident_name.i[copy_len] = '\\0';", "rationale": "By bounding the copy length to the size of the stack buffer, we eliminate any possibility of writing beyond the end of ident_name.i, directly preventing the stack-based overflow.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by bounding the copy length to the 32-byte buffer and null-terminating the result, preventing any stack overflow. The strategy aligns with the vulnerability details (CWE-119/CWE-787) and inserts the check at the correct location before tvb_memcpy. It\u2019s specific yet realistic for this code context and avoids side effects on other functionality. The minor deduction reflects that full context (e.g., exact offset handling) isn\u2019t visible, but the overall approach is sound."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}, "guideline": "Use length-constrained or safe copy routines (e.g., strncpy, g_strlcpy, or tvb_strncpy) that accept a maximum buffer size and always null-terminate. ", "description": "Replace the direct tvb_memcpy with tvb_strncpy (or a similar API) that takes a maximum length argument, e.g.:\n    tvb_strncpy(tvb, offset+2, name_len, ident_name.i, sizeof(ident_name.i));\nThis ensures no more than sizeof(ident_name.i)-1 bytes are copied and the buffer is null-terminated.", "rationale": "Using a dedicated safe copy routine centralizes length checks and guarantees null-termination, reducing the risk of future errors if code is refactored or reused.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by replacing the unsafe tvb_memcpy with a length-checked tvb_strncpy, ensuring no more than 32 bytes are copied and the buffer is null-terminated. This aligns precisely with the CWE-787 buffer overflow root cause, applies at the correct location, and follows the project\u2019s existing API conventions. The guidance is concrete without relying on unavailable context, making it a practical and robust solution."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}, "guideline": "Implement a policy to reject or sanitize extensions whose declared length exceeds the maximum supported size, logging or skipping invalid objects rather than blindly copying them. ", "description": "Before any copy, check if the extension\u2019s declared length exceeds 32 bytes. If so, log a protocol violation and skip dissecting this object (or clamp the length). For example:\n    if (name_len > sizeof(ident_name.i)-1) {\n        expert_add_info(..., \"ICMP extension name too long, skipping\");\n        return offset + total_object_length;\n    }\n    /* safe to copy */", "rationale": "Rejecting or skipping invalid objects enforces protocol correctness and prevents malformed packets from corrupting memory, adding an additional layer of defense.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by validating the name length against the 32-byte buffer before copying and logs/skips overly long objects\u2014this matches the vulnerability root cause and the guideline. The strategy is plausible and aligns with the sanitizer report. While somewhat generic (no exact line numbers or full code context), it is appropriately scoped given the available information and avoids over-specificity or hallucination."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Validate all length fields before copying into fixed-size buffers (CWE-787). Always check that the declared length does not exceed the destination buffer size.", "description": "Immediately before the call to tvb_memcpy, insert a check: if ((obj_length - 4) > sizeof(ident_name) - 1) { g_snprintf(ident_name, sizeof(ident_name), \"<TOO LONG>\"); } else { tvb_memcpy(tvb, ident_name, offset, obj_length - 4); } Then NUL-terminate ident_name[MIN(obj_length-4, sizeof(ident_name)-1)] = '\\0';", "rationale": "By bounding obj_length-4 to the size of ident_name, we eliminate any chance of a stack-buffer overflow when memcpy is invoked.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the root cause (unbounded memcpy into a 32-byte stack buffer) by validating and capping obj_length before copying. It cleanly prevents overflow, offers a clear fallback for over-long names, and includes proper NUL-termination. The fix location and approach are plausible and align with the guideline without introducing side effects. It\u2019s specific enough to implement without hallucination but not overly detailed given the context."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "Use safe copy primitives or functions that take an explicit maximum length parameter (e.g., strlcpy, memcpy with MIN()).", "description": "Replace the tvb_memcpy and manual printable-character loop with tvb_strncpy: tvb_strncpy(tvb, ident_name, offset, obj_length - 4, sizeof(ident_name) - 1); ident_name[sizeof(ident_name) - 1] = '\\0'; This ensures no more than sizeof(ident_name)-1 bytes are written and always NUL terminates.", "rationale": "Safe copy routines like tvb_strncpy or strlcpy automatically cap the copied length and add a NUL terminator, preventing overflow even if the source length is maliciously large.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the overflow by replacing the unchecked tvb_memcpy with a bounded-copy routine (tvb_strncpy) that enforces a maximum length and guarantees NUL-termination. It aligns with the given guideline, applies to the correct location, and prevents writing beyond the 32-byte buffer. It is neither overly general nor unrealistically specific, making it a practical and sound strategy to eliminate the vulnerability without altering other behavior."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, "guideline": "For variable-length packet fields that may exceed stack buffer limits, either reject oversized values or use dynamically allocated memory sized to the incoming length plus a terminator.", "description": "Instead of using a stack buffer, allocate a temporary heap buffer of length (obj_length - 4) + 1, copy the data via tvb_memcpy into that buffer, NUL-terminate, use it for proto_tree_add_item with ENC_ASCII, then free() the buffer.", "rationale": "Heap allocation sized to the actual incoming data prevents all stack-based overflow risks; if the packet is extremely large, allocation will fail or we can explicitly reject the packet.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded memcpy into a fixed 32-byte stack buffer) and offers an appropriate mitigation by switching to a heap allocation sized to the actual incoming data plus a terminator, which addresses the overflow. It also aligns with the guideline to either reject or properly size buffers. The fix is plausible at the specified code location and avoids affecting other features. However, it is still somewhat high-level (doesn't show exact code) and could be improved by explicitly handling allocation failures or adding a length check branch for extreme sizes, so it isn\u2019t a perfect 10 but is solid and on point."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}, {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 923, "end_line": 927, "function_name": "", "code": "{\n\t\tcase ICMP_EXT_ECHO_IDENT_NAME:\n\t\t\t/* Identification Name must be printable*/\n\t\t\ttvb_memcpy(tvb, ident_name, offset, obj_length - 4);\n\n\t\t\tfor (unsigned i = 0; i < obj_length - 4; i++)\n\t\t\t\tif (!g_ascii_isprint(ident_name[i]))\n\t\t\t\t\tbreak;\n\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_name_string, tvb, offset, obj_length - 4, ENC_ASCII);\n\t\t\tbreak;\n\t\tcase ICMP_EXT_ECHO_IDENT_INDEX:\n\t\t\tproto_tree_add_item(ext_object_tree, hf_icmp_int_ident_index, tvb, offset, 4, ENC_NA);\n\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check immediately before the memcpy in dissect_interface_identification_object to ensure the copy length is capped at the buffer\u2019s size, eliminating the stack-based buffer overflow.", "score": 9, "confidence": 9, "reliability_score": 17.099999999999998, "eval_rationale": "The LLM correctly pinpointed the exact memcpy call in dissect_interface_identification_object where the unchecked copy occurs (ICMP_EXT_ECHO_IDENT_NAME case). Inserting a bounds check immediately before tvb_memcpy directly addresses the root cause of the stack buffer overflow. The location is highly relevant and modifying it will effectively eliminate the vulnerability without impacting unrelated functionality. I deduct one point only because additional checks on the object length field upstream might further harden the fix, but overall the selected location is spot-on."}, {"locations": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1090, "end_line": 1092, "function_name": "", "code": "=\n\t\t\t    dissect_interface_identification_object(tvb,\n\t\t\t\t\t\t\t\t offset,\n\t\t\t\t\t\t\t\t ext_object_tree,\n\t\t\t\t\t\t\t\t tf_object)", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy at line 1092 uses a packet-supplied length that may exceed the 32-byte local buffer, causing an out-of-bounds write. Introducing a bounds check on the copy length at this location directly addresses the overflow without impacting other functionality.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The LLM correctly identifies that the unchecked memcpy occurs around the handling of the Interface Identification Object and pinpoints the call to dissect_interface_identification_object (lines 1090\u20131092) as the spot where a length check can prevent the overflow. This aligns well with the vulnerability root cause and would directly address the out-of-bounds write without overhauling other functionality. However, the actual memcpy occurs inside the implementation of dissect_interface_identification_object (via dissect_icmp_extension), so ideally the bounds check should be added within that function rather than only at its call site. The selected location is on target but slightly imprecise, warranting a moderate deduction."}], "location_candidates": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 927, "end_line": 927, "function_name": "dissect_interface_identification_object", "code": "tvb_memcpy(tvb, ident_name, offset, obj_length - 4);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1092, "end_line": 1092, "function_name": "dissect_icmp_extension", "code": "dissect_interface_identification_object(tvb,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the ICMP extension parsing code (dissect_icmp_extension), data from the packet is copied into a fixed-size stack buffer without checking the length of the data. An attacker can craft an extension object larger than the buffer, causing memcpy to overwrite adjacent stack memory and leading to memory corruption.", "rationale": "AddressSanitizer detected a stack-buffer-overflow when 256 bytes were copied into the 32-byte \u2018ident_name.i\u2019 buffer via tvb_memcpy. The lack of a bounds check on the copy operation permits out-of-bounds writes, confirming the vulnerability\u2019s root cause and CWE classification."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In dissect_icmp_extension, the code calls tvb_memcpy (memcpy) to copy up to 256 bytes of ICMP extension data into a fixed\u2010size local array (ident_name.i) of only 32 bytes without validating the data length. This leads to a stack\u2010based buffer overflow and an out\u2010of\u2010bounds write when processing crafted ICMP packets.", "rationale": "AddressSanitizer output shows a stack-buffer-overflow at memcpy in dissect_icmp_extension, writing 256 bytes into a 32-byte buffer. The lack of a length check before memcpy is the direct cause of the overflow, matching CWE-787: Out-of-bounds Write under the broader category of CWE-119: Buffer Overflow."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the ICMP dissector (packet-icmp.c), the function dissect_icmp_extension handles the Interface Identification Object by copying its name field into a small fixed\u2010size stack buffer without verifying the declared length. A malicious packet can specify a name length larger than the 32\u2010byte buffer, causing memcpy to write beyond the buffer and overflow the stack.", "rationale": "The code uses tvb_memcpy (via memcpy) to copy up to 256 bytes into the 32-byte local array ident_name.i without any bounds check on the length parameter. This unchecked copy leads directly to an out-of-bounds write on the stack, resulting in a buffer overflow."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the ICMP extension parsing code (dissect_icmp_extension), data from the packet is copied into a fixed-size stack buffer without checking the length of the data. An attacker can craft an extension object larger than the buffer, causing memcpy to overwrite adjacent stack memory and leading to memory corruption.", "rationale": "AddressSanitizer detected a stack-buffer-overflow when 256 bytes were copied into the 32-byte \u2018ident_name.i\u2019 buffer via tvb_memcpy. The lack of a bounds check on the copy operation permits out-of-bounds writes, confirming the vulnerability\u2019s root cause and CWE classification."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-icmp.c\u2019s ICMP dissector, dissect_icmp_extension handles the Interface Identification Object by copying its name field into a 32-byte stack buffer via tvb_memcpy. The function does not verify that the name length provided by the packet is within the 32-byte limit and can accept up to 256 bytes. A malicious packet specifying a length greater than 32 bytes causes memcpy to overflow the local buffer and overwrite adjacent stack memory, leading to memory corruption.", "rationale": "The function dissect_icmp_extension uses tvb_memcpy (which calls memcpy) to copy up to 256 bytes of ICMP extension data into a fixed 32-byte local buffer (ident_name.i) on the stack without validating that the declared length does not exceed the buffer size. This unchecked copy results in a stack-based out-of-bounds write, as confirmed by AddressSanitizer detecting a stack-buffer-overflow at the memcpy call."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 927, "start_line": 927, "end_line": 927, "function_name": "dissect_interface_identification_object", "code": "tvb_memcpy(tvb, ident_name, offset, obj_length - 4);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-icmp.c", "fix_line": 1092, "start_line": 1092, "end_line": 1092, "function_name": "dissect_icmp_extension", "code": "dissect_interface_identification_object(tvb,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/qqor/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-delta-02_vuln_004/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-delta-02_vuln_004", "sanitizer_output": "+ FUZZER=handler_icmp\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_icmp -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_icmp -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: icmp\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 855662647\nINFO: Loaded 1 modules   (420438 inline 8-bit counters): 420438 [0xa9f3f00, 0xaa5a956), \nINFO: Loaded 1 PC tables (420438 PCs): 420438 [0xaa5a958,0xb0c4eb8), \n/out/handler_icmp: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n=================================================================\n==18==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f7be1181aa0 at pc 0x000005070b64 bp 0x7fffc573a330 sp 0x7fffc5739af0\nWRITE of size 256 at 0x7f7be1181aa0 thread T0\nSCARINESS: 60 (multi-byte-write-stack-buffer-overflow)\n    #0 0x5070b63 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:63:3\n    #1 0x7980fda in memcpy /usr/include/x86_64-linux-gnu/bits/string_fortified.h:34:10\n    #2 0x7980fda in tvb_memcpy /src/wireshark/epan/tvbuff.c:945:10\n    #3 0x6c1eba9 in dissect_interface_identification_object /src/wireshark/epan/dissectors/packet-icmp.c:927:4\n    #4 0x6c1eba9 in dissect_icmp_extension /src/wireshark/epan/dissectors/packet-icmp.c:1092:8\n    #5 0x6c1b989 in dissect_icmp /src/wireshark/epan/dissectors/packet-icmp.c\n    #6 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #7 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #8 0x5b8fb14 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #9 0x5b8fb14 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #10 0x544aac7 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #11 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #12 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #13 0x5b809b7 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #14 0x5b809b7 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #15 0x5b809b7 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #16 0x52bd530 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #17 0x50b3f48 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #18 0x4f66c20 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #19 0x4f51245 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #20 0x4f56cdf in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #21 0x4f82bd2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #22 0x7f7be1948082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #23 0x4f4942d in _start (/out/handler_icmp+0x4f4942d)\n\nDEDUP_TOKEN: __asan_memcpy--memcpy--tvb_memcpy\nAddress 0x7f7be1181aa0 is located in stack of thread T0 at offset 160 in frame\n    #0 0x6c1dbaf in dissect_icmp_extension /src/wireshark/epan/dissectors/packet-icmp.c:971\n\nDEDUP_TOKEN: dissect_icmp_extension\n  This frame has 5 object(s):\n    [32, 160) 'ident_name.i' (line 902)\n    [192, 196) 'afi.i' (line 904) <== Memory access at offset 160 partially underflows this variable\n    [208, 212) 'addr_length.i' (line 905) <== Memory access at offset 160 partially underflows this variable\n    [224, 232) 'tf_entry.i' (line 671) <== Memory access at offset 160 partially underflows this variable\n    [256, 264) 'tf_object' (line 977) <== Memory access at offset 160 partially underflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /usr/include/x86_64-linux-gnu/bits/string_fortified.h:34:10 in memcpy\nShadow bytes around the buggy address:\n  0x7f7be1181800: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181880: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181900: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181980: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181a00: f1 f1 f1 f1 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x7f7be1181a80: 00 00 00 00[f2]f2 f2 f2 04 f2 04 f2 f8 f2 f2 f2\n  0x7f7be1181b00: 00 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f7be1181b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7f7be1181c00: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181c80: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\n  0x7f7be1181d00: f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5 f5\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/qqor/aixcc/dataset/tarballs/wireshark_ws-delta-02/pov/wireshark_ws-delta-02_vuln_004:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_icmp -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/qqor/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}