{"vuln_data": {"id": "wireshark_ws-full-01_vuln_005", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_bat.vis", "branch_name": "ws-full-01", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["build_failed", "success", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\ttvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n\n}", "patched_code": "static void __attribute__((unused)) dissect_bat_vis_v23(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_def": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_ret": ["return;"]}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "patched_code": "static void __attribute__((unused)) dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_def": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)", "func_ret": ["return tvb_captured_length(tvb);"]}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\ttvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n\n}", "patched_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\t tvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n// Safe print: use fputs to avoid format string vulnerability\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4)) {\n\t\tfputs(d_output_buffer, stderr);\n\t\tfputc('\\n', stderr);\n\t}\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t }\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n}\n", "func_def": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_ret": ["return;"]}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "patched_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\tcase 24:\n\t\t{\n\t\t\t/* Rationale: Pre-format raw packet into bounded buffer to prevent format-string misuse */\n\t\t\tconst guint len_raw = tvb_captured_length(tvb);\n\t\t\tconst guint8 *raw = tvb_get_ptr(tvb, 0, len_raw);\n\t\t\tchar safe_buf[1024];\n\t\t\tsize_t copy_len = len_raw < (sizeof(safe_buf)-1) ? len_raw : (sizeof(safe_buf)-1);\n\t\t\tmemcpy(safe_buf, raw, copy_len);\n\t\t\tsafe_buf[copy_len] = '\\0';\n\t\t\tcol_add_str(pinfo->cinfo, COL_INFO, safe_buf);\n\t\t\t/* Call the appropriate specialized dissector after safe logging */\n\t\t\tif (version == 23)\n\t\t\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\t\telse\n\t\t\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "func_def": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)", "func_ret": ["return tvb_captured_length(tvb);"]}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\ttvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n\n}", "patched_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\t tvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n// Safe print: use precision-limited format to avoid overruns and format vuln\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4)) {\n\t\t{\n\t\t\tint len = (int)strnlen(d_output_buffer, sizeof(d_output_buffer));\n\t\t\tfprintf(stderr, \"%.*s\\n\", len, d_output_buffer);\n\t\t}\n\t}\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n}\n", "func_def": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_ret": ["return;"]}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "patched_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\t{\n\t\t\t/* Rationale: Safely print raw payload with precision specifier to avoid format-string exploits */\n\t\t\tconst guint len_raw = tvb_captured_length(tvb);\n\t\t\tconst guint8 *raw = tvb_get_ptr(tvb, 0, len_raw);\n\t\t\tchar safe_buf[1024];\n\t\t\tsnprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len_raw, raw);\n\t\t\tcol_add_str(pinfo->cinfo, COL_INFO, safe_buf);\n\t\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\t{\n\t\t\t/* Rationale: Safely print raw payload with precision specifier to avoid format-string exploits */\n\t\t\tconst guint len_raw = tvb_captured_length(tvb);\n\t\t\tconst guint8 *raw = tvb_get_ptr(tvb, 0, len_raw);\n\t\t\tchar safe_buf[1024];\n\t\t\tsnprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len_raw, raw);\n\t\t\tcol_add_str(pinfo->cinfo, COL_INFO, safe_buf);\n\t\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "func_def": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)", "func_ret": ["return tvb_captured_length(tvb);"]}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\ttvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n\n}", "patched_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\t tvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n// Safe print: pre-format into bounded buffer to avoid format and overflow\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4)) {\n\t\tchar safe_buf[1024];\n\t\tsize_t len = strnlen(d_output_buffer, sizeof(d_output_buffer));\n\t\tsnprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n\t\tfprintf(stderr, \"%s\\n\", safe_buf);\n\t}\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t }\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n}\n", "func_def": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_ret": ["return;"]}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "patched_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\t{\n\t\t\t/* Rationale: Pre-format into safe buffer before using fprintf to avoid format vulnerability */\n\t\t\tconst guint len_raw = tvb_captured_length(tvb);\n\t\t\tconst char *data_str = (const char*)tvb_get_ptr(tvb, 0, len_raw);\n\t\t\tchar safe_buf[1024];\n\t\t\tsize_t valid_len = strnlen(data_str, len_raw);\n\t\t\tsnprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)valid_len, data_str);\n\t\t\tfprintf(stderr, \"%s\\n\", safe_buf);\n\t\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "func_def": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)", "func_ret": ["return tvb_captured_length(tvb);"]}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\ttvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t}\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n\n}", "patched_code": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct vis_packet_v23 *vis_packeth;\n\tuint32_t sender_ip;\n\tproto_tree *bat_vis_tree = NULL;\n\tint vis_packeth_raw_data_size=0;\n\tchar vis_packeth_raw_data[1024];\n\tchar d_output_buffer[1024];\n\n\t tvbuff_t *next_tvb;\n\tint length_remaining, i, offset;\n\n\td_output_buffer[0] = 0;\n\n\tvis_packeth = wmem_new(pinfo->pool, struct vis_packet_v23);\n\n\tsender_ip = tvb_get_ipv4(tvb, 0);\n\tset_address_tvb(&vis_packeth->sender_ip, AT_IPv4, 4, tvb, 0);\n\toffset = 8;\n\tvis_packeth->version = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->gw_class = tvb_get_uint8(tvb, offset++);\n\tvis_packeth->tq_max = tvb_get_uint8(tvb, offset++);\n\tvis_packeth_raw_data_size = tvb_get_uint32(tvb, offset++, 0);\n\toffset += 4;\n\tif ((unsigned long)vis_packeth_raw_data_size > sizeof(vis_packeth_raw_data))\n\t\treturn;\n\n\tfor (i=0; i < vis_packeth_raw_data_size; i++) {\n\t\tvis_packeth_raw_data[i] = tvb_get_uint8(tvb, offset);\n\t\toffset++;\n\t}\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\t/* Set info column */\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Src: %s\",\n\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\n\t/* Set tree info */\n\tif (tree) {\n\t\tproto_item *ti;\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_bat_vis, tvb, 0, VIS_PACKET_V23_SIZE,\n\t\t\t\t\t\"B.A.T.M.A.N. Vis, Src: %s\",\n\t\t\t\t\taddress_with_resolution_to_str(pinfo->pool, &vis_packeth->sender_ip));\n\t\tsnprintf(d_output_buffer, sizeof(d_output_buffer), \"B.A.T.M.A.N. Vis, raw_data %s\", vis_packeth_raw_data);\n\t\tbat_vis_tree = proto_item_add_subtree(ti, ett_bat_vis);\n\n\t\t/* items */\n\t\tproto_tree_add_ipv4(bat_vis_tree, hf_bat_vis_vis_orig, tvb, offset, 4, sender_ip);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_vis_gwflags, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\tproto_tree_add_item(bat_vis_tree, hf_bat_max_tq_v23, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t/*offset += 1;*/\n\t}\n// Safe print: use fwrite to stderr to avoid format string\n\tif ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4)) {\n\t\tsize_t len = strnlen(d_output_buffer, sizeof(d_output_buffer));\n\t\tfwrite(d_output_buffer, 1, len, stderr);\n\t\tfputc('\\n', stderr);\n\t}\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\n\tfor (i = 0; i < length_remaining; i += VIS_PACKET_V23_DATA_SIZE) {\n\t\tnext_tvb = tvb_new_subset_length(tvb, offset, VIS_PACKET_V23_DATA_SIZE);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tif (bat_vis_tree != NULL) {\n\t\t\tdissect_vis_entry_v23(next_tvb, pinfo, tree);\n\t\t}\n\n\t\toffset += VIS_PACKET_V23_DATA_SIZE;\n\t }\n\n\tlength_remaining = tvb_reported_length_remaining(tvb, offset);\n\tif (length_remaining > 0) {\n\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\n\t\tif (have_tap_listener(bat_follow_tap)) {\n\t\t\ttap_queue_packet(bat_follow_tap, pinfo, next_tvb);\n\t\t}\n\n\t\tcall_data_dissector(next_tvb, pinfo, tree);\n\t}\n}\n", "func_def": "static void dissect_bat_vis_v24(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)", "func_ret": ["return;"]}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "patched_code": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tuint8_t version;\n\n\t/* set protocol name */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"BAT_VIS\");\n\n\tversion = tvb_get_uint8(tvb, 4);\n\tswitch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\t/* Rationale: Use bounded format in col_add_fstr to avoid external format specifier */\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"%.*s\", tvb_captured_length(tvb),\n\t\t\t\t(unsigned char*)tvb_get_ptr(tvb, 0, tvb_captured_length(tvb)));\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\t/* Rationale: Use bounded format in col_add_fstr to avoid external format specifier */\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"%.*s\", tvb_captured_length(tvb),\n\t\t\t\t(unsigned char*)tvb_get_ptr(tvb, 0, tvb_captured_length(tvb)));\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}\n\treturn tvb_captured_length(tvb);\n}", "func_def": "static int dissect_bat_vis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)", "func_ret": ["return tvb_captured_length(tvb);"]}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Use constant format strings with printf\u2010family functions to avoid uncontrolled format string vulnerabilities (CWE-134).", "description": "In packet-bat.c at lines 700\u2013710, replace the unsafe call\n    if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n        fprintf(stderr, d_output_buffer);\nwith a constant format and length guard, for example:\n    if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4)) {\n        /* print raw payload safely */\n        fprintf(stderr, \"%.*s\\n\", (int)vis_packeth_raw_data_size, d_output_buffer);\n    }\n", "rationale": "Using a constant format string prevents an attacker from injecting format specifiers via d_output_buffer, eliminating the format string vuln.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the CWE-134 format-string vulnerability by replacing the uncontrolled format argument with a constant format string and incorporating a length guard. It targets the correct location (lines 700\u2013710), uses \"%.*s\" to safely limit output to the buffer size, and prevents attacker-controlled format specifiers. This strategy is both plausible and aligns well with the remediation guidelines; only minor clarity or stylistic improvements could be considered, so a high score is warranted."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Limit the number of characters printed from external buffers by using precision specifiers or bounded functions like snprintf (mitigates CWE-119 buffer overflows).", "description": "Alternatively, pre-format into a local bounded buffer and then log, e.g.:\n    char safe_buf[1024];\n    size_t len = strnlen(d_output_buffer, vis_packeth_raw_data_size);\n    /* snprintf guarantees null-termination */\n    snprintf(safe_buf, sizeof(safe_buf), \"%.*s\", (int)len, d_output_buffer);\n    fprintf(stderr, \"%s\\n\", safe_buf);\n", "rationale": "By bounding the copy into safe_buf with snprintf and strnlen, we prevent both over-reads and buffer overruns, satisfying CWE-119.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies and addresses both the uncontrolled format string (CWE-134) and potential buffer overflows (CWE-119) by using snprintf with precise length and a fixed format specifier. It\u2019s directly applicable to the reported code locations, bounding reads and writes safely. The suggestion is neither overly generic nor unrealistically detailed, making it a practical, high-quality fix."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, "guideline": "Sanitize or escape user\u2010controlled data before output if printing raw payloads is required, or use higher\u2010level APIs that handle binary/hex dumps safely.", "description": "If the intent is to display binary data rather than a text string, replace fprintf with a hex\u2010dump helper to avoid interpreting any format specifiers:\n    if (vis_packeth_raw_data_size > 4) {\n        proto_tree_add_text(tree, pinfo, COL_INFO, \"Raw Payload\", NULL);\n        expert_add_info_format(pinfo, NULL, \"Payload (hex): %s\", hexdump_hex_str(d_output_buffer, vis_packeth_raw_data_size));\n    }\n", "rationale": "Presenting data via a hex\u2010dump API avoids any interpretation of user\u2010controlled format directives and is more appropriate for binary payloads.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly addresses the format\u2010string vulnerability (CWE-134) by replacing the unsafe fprintf call with a fixed format specifier and a hex-dump helper, thereby preventing interpretation of attacker-controlled format tokens. The use of proto_tree_add_text, expert_add_info_format, and hexdump_hex_str aligns with Wireshark\u2019s APIs for safely displaying binary data. The rationale and guideline are clear and appropriate. The answer is neither too generic nor overly detailed\u2014it pinpoints the vulnerable code and suggests a practical, API-based replacement. Therefore it merits a high score."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}, {"locations": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 700, "end_line": 710, "function_name": "", "code": "if ((vis_packeth_raw_data_size > 4) && (strlen(vis_packeth_raw_data) > 4))\n\t\tfprintf(stderr, d_output_buffer);\n\n\ttap_queue_packet(bat_tap, pinfo, vis_packeth);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 424, "end_line": 435, "function_name": "", "code": "switch (version) {\n\tcase 22:\n\t\tdissect_bat_vis_v22(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 23:\n\t\tdissect_bat_vis_v23(tvb, pinfo, tree);\n\t\tbreak;\n\tcase 24:\n\t\tdissect_bat_vis_v24(tvb, pinfo, tree);\n\t\tbreak;\n\tdefault:\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Unsupported Version %d\", version);\n\t\tcall_data_dissector(tvb, pinfo, tree);\n\t\tbreak;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Both vulnerable calls construct format strings from untrusted packet data. By using a constant format specifier (\"%s\") and passing the payload as an argument, we eliminate the CWE-134 format string vulnerability without altering existing functionality.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The first location (fprintf in dissect_bat_vis_v24) correctly targets the format\u2010string vulnerability by pointing to untrusted data used as a format specifier. However, the second location (the version\u2010switch in packet-bat.c) is not directly related to fixing the format\u2010string issue\u2014it merely dispatches based on version and does not involve printf\u2010style calls with untrusted input. Including it as a fix location is irrelevant and unlikely to resolve or even address the vulnerability. Thus, although one of the two chosen sites is appropriate, the other is misplaced, warranting a low score."}], "location_candidates": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 705, "end_line": 705, "function_name": "dissect_bat_vis_v24", "code": "fprintf(stderr, d_output_buffer);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 429, "end_line": 429, "function_name": "dissect_bat_vis", "code": "dissect_bat_vis_v24(tvb, pinfo, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-134: Use of Externally-Controlled Format String", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the BAT VIS dissector (function dissect_bat_vis_v24), parser code passes untrusted packet payload directly as the format string to a printf-like function (vfprintf) without using a fixed format specifier. An attacker can embed arbitrary format tokens (such as %x, %n, %s) in the packet data, causing the library to read or write memory out of bounds, leading to crashes or potential memory corruption.", "rationale": "AddressSanitizer output pinpoints a SEGV in printf_common/vfprintf triggered by dereferencing an over-large address when interpreting attacker-controlled format specifiers. This demonstrates a classic format string weakness (CWE-134) that results in an out-of-bounds memory access (buffer overflow, CWE-119) due to lack of validation or use of a safe, constant format string."}, "vuln_info_candidates": [{"type": "CWE-134: Uncontrolled Format String", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the dissect_bat_vis_v24 function within packet-bat.c, untrusted packet data is passed directly as the format string to printf-style functions (vfprintf/__fprintf_chk) without validation. This uncontrolled format string usage allows an attacker to embed format specifiers (e.g., %x, %n) in the packet payload, leading to arbitrary out-of-bounds memory reads or writes and resulting in a crash.", "rationale": "AddressSanitizer identifies a SEGV caused by wild-address reads in vfprintf when processing a malformed .vis packet. The root cause is an uncontrolled format string (CWE-134) that permits attacker-controlled directives to drive memory access beyond intended buffers (a form of buffer overflow, CWE-119). Sanitizing or fixing the format string usage will prevent these out-of-bounds operations."}, {"type": "CWE-134: Use of Externally-Controlled Format String", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The BAT.vis dissector\u2019s dissect_bat_vis_v24 function constructs a format string directly from untrusted packet data and passes it to printf/vfprintf without using a fixed format specifier or validating the input. A malicious packet containing format directives (e.g. \u201c%x\u201d, \u201c%n\u201d) can force vfprintf to perform arbitrary reads or writes beyond intended memory bounds, leading to a crash or potential memory corruption.", "rationale": "Using externally-controlled data as a printf format string without sanitization is a classic format string vulnerability (CWE-134) that results in out-of-bounds memory accesses (CWE-119). The lack of a fixed format specifier allows attackers to inject format codes and trigger uncontrolled memory operations."}, {"type": "CWE-134: Use of Externally-Controlled Format String", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the BAT VIS dissector (function dissect_bat_vis_v24), parser code passes untrusted packet payload directly as the format string to a printf-like function (vfprintf) without using a fixed format specifier. An attacker can embed arbitrary format tokens (such as %x, %n, %s) in the packet data, causing the library to read or write memory out of bounds, leading to crashes or potential memory corruption.", "rationale": "AddressSanitizer output pinpoints a SEGV in printf_common/vfprintf triggered by dereferencing an over-large address when interpreting attacker-controlled format specifiers. This demonstrates a classic format string weakness (CWE-134) that results in an out-of-bounds memory access (buffer overflow, CWE-119) due to lack of validation or use of a safe, constant format string."}], "vuln_info_final": {"type": "CWE-134: Use of Externally-Controlled Format String", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In dissect_bat_vis_v24 (packet-bat.c), the code hands untrusted packet payload to vfprintf/printf-style calls as the format string without validation or a constant format specifier. An attacker can embed format tokens (e.g., %x, %n, %s) in the packet, forcing arbitrary memory reads or writes beyond intended buffers, leading to crashes or potential memory corruption.", "rationale": "Passing untrusted packet data directly as the format string to printf-like functions without using a fixed format specifier creates a format string vulnerability (CWE-134) that enables out-of-bounds memory accesses (CWE-119). AddressSanitizer traces a SEGV in vfprintf when interpreting attacker-controlled format directives, confirming uncontrolled reads/writes."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-bat.c", "fix_line": 705, "start_line": 705, "end_line": 705, "function_name": "dissect_bat_vis_v24", "code": "fprintf(stderr, d_output_buffer);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-bat.c", "fix_line": 429, "start_line": 429, "end_line": 429, "function_name": "dissect_bat_vis", "code": "dissect_bat_vis_v24(tvb, pinfo, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/qqor/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-full-01_vuln_005/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-full-01_vuln_005", "sanitizer_output": "+ FUZZER=handler_bat.vis\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_bat.vis -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_bat.vis -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: bat.vis\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 4291921145\nINFO: Loaded 1 modules   (420518 inline 8-bit counters): 420518 [0xa9f6a00, 0xaa5d4a6), \nINFO: Loaded 1 PC tables (420518 PCs): 420518 [0xaa5d4a8,0xb0c7f08), \n/out/handler_bat.vis: Running 1 inputs 100 time(s) each.\nRunning: /testcase\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000004ffee72 bp 0x7ffef6fcfe80 sp 0x7ffef6fcf610 T0)\n==18==The signal is caused by a READ memory access.\n==18==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.\nSCARINESS: 20 (wild-addr-read)\n    #0 0x4ffee72 in QuickCheckForUnpoisonedRegion /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.h:37:7\n    #1 0x4ffee72 in printf_common(void*, char const*, __va_list_tag*) /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors_format.inc:546:7\n    #2 0x5000d94 in vfprintf /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1648:1\n    #3 0x5000d94 in __fprintf_chk /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1710:1\n    #4 0x5ffd29f in dissect_bat_vis_v24 /src/wireshark/epan/dissectors/packet-bat.c:705:3\n    #5 0x5ffd29f in dissect_bat_vis /src/wireshark/epan/dissectors/packet-bat.c:429:3\n    #6 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #7 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #8 0x5b90394 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #9 0x5b90394 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #10 0x544b347 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #11 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #12 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #13 0x5b81237 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #14 0x5b81237 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #15 0x5b81237 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #16 0x52bddb0 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #17 0x50b47c8 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #18 0x4f674a0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #19 0x4f51ac5 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #20 0x4f5755f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #21 0x4f83452 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #22 0x7f3b85bd1082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #23 0x4f49cad in _start (/out/handler_bat.vis+0x4f49cad)\n\nDEDUP_TOKEN: QuickCheckForUnpoisonedRegion--printf_common(void*, char const*, __va_list_tag*)--___interceptor_vfprintf\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /src/wireshark/epan/dissectors/packet-bat.c:705:3 in dissect_bat_vis_v24\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x1,0x1,0x1,0x1,0x18,0x0,0x0,0x0,0x1,0x2,0x3,0x0,0x0,0x0,0x49,0x58,0x58,0x58,0x58,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x6e,0x2e,0x25,0x73,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x58,0x58,0x58,0x58,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x78,0x2e,0x25,0x6e,0x2e,0x25,0x73,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,\n\\001\\001\\001\\001\\030\\000\\000\\000\\001\\002\\003\\000\\000\\000IXXXX.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n.%sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXXXX.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%n.%sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/qqor/aixcc/dataset/tarballs/wireshark_ws-full-01/pov/wireshark_ws-full-01_vuln_005:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_bat.vis -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/qqor/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}