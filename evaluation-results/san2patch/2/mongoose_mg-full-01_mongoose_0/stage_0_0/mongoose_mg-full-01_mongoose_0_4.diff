diff --git a/src/json.c b/src/json.c
index cf6bc57b..555e9cdb 100644
--- a/src/json.c
+++ b/src/json.c
@@ -319,10 +319,18 @@ bool mg_json_unescape(struct mg_str s, char *to, size_t n) {
 char *mg_json_get_str(struct mg_str json, const char *path) {
   char *result = NULL;
   int len = 0, off = mg_json_get(json, path, &len);
-  if (off >= 0 && len > 1 && json.buf[off] == '"') {
-    if ((result = (char *) calloc(1, (size_t) len)) != NULL &&
-        !mg_json_unescape(mg_str_n(json.buf + off + 1, (size_t) (len - 2)),
-                          result, (size_t) len)) {
+// Validate offset/length and ensure result buffer cannot overflow
+  if (off < 0 || len <= 1 || off + len > (int) json.len || json.buf[off] != '"') {
+    return NULL;
+  }
+  /* Allocate and zero-initialize; add extra space for a trailing NUL */
+  size_t alloc_size = (size_t)len + 1;
+  result = (char *) calloc(1, alloc_size);
+  if (result != NULL) {
+    /* Unescape into the buffer, passing total size for safety */
+    if (mg_json_unescape(
+          mg_str_n(json.buf + off + 1, (size_t)(len - 2)),
+          result, alloc_size)) {
       free(result);
       result = NULL;
     }
@@ -345,15 +353,20 @@ char *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {
 char *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {
   char *result = NULL;
   int len = 0, off = mg_json_get(json, path, &len);
-  if (off >= 0 && json.buf[off] == '"' && len > 1 &&
-      (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {
+  if (off < 0 || json.buf[off] != '"' || len <= 2) return NULL;
+  /* Rationale: explicitly compute hex length, require even number of hex chars */
+  int hex_len = len - 2;
+  if (hex_len % 2 != 0) return NULL;
+  int byte_count = hex_len / 2;
+  result = (char *) calloc(1, (size_t)byte_count + 1);
+  if (result != NULL) {
+    const char *p = json.buf + off + 1;
     int i;
-    for (i = 0; i < len - 2; i += 2) {
-      mg_str_to_num(mg_str_n(json.buf + off + 1 + i, 2), 16, &result[i >> 1],
-                    sizeof(uint8_t));
+    for (i = 0; i < byte_count; i++, p += 2) {
+      mg_str_to_num(mg_str_n(p, 2), 16, &result[i], sizeof(uint8_t));
     }
-    result[len / 2 - 1] = '\0';
-    if (slen != NULL) *slen = len / 2 - 1;
+    result[byte_count] = '\0';
+    if (slen != NULL) *slen = byte_count;
   }
   return result;
 }
