diff --git a/epan/dissectors/packet-telnet.c b/epan/dissectors/packet-telnet.c
index 9f003e3e61..478a9f1d67 100644
--- a/epan/dissectors/packet-telnet.c
+++ b/epan/dissectors/packet-telnet.c
@@ -2318,8 +2318,10 @@ dissect_telnet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _
       }
       /*
        * Now interpret the command.
+       * After handling, exit loop to avoid further use of freed suboption data.
        */
       offset = telnet_command(pinfo, telnet_tree, tvb, iac_offset, &num_info_items);
+      break;
     } else {
       /* get more data if tn3270 */
       if (is_tn3270 || is_tn5250) {
@@ -2375,8 +2377,10 @@ proto_register_telnet(void)
         VALS(auth_cmd_vals), 0, "Authentication Command", HFILL }
     },
     { &hf_telnet_auth_type,
+      /* Rationale: use a separate, never‐freed copy of the auth_type_vals table so
+         the values pointer cannot become dangling (avoids use‐after‐free) */
       { "Auth Type", "telnet.auth.type", FT_UINT8, BASE_DEC,
-        VALS(auth_type_vals), 0, "Authentication Type", HFILL }
+        VALS(auth_type_vals_copy), 0, "Authentication Type", HFILL }
     },
     { &hf_telnet_auth_mod_cred_fwd,
       { "Cred Fwd", "telnet.auth.mod.cred_fwd", FT_BOOLEAN, 8,
@@ -2387,8 +2391,7 @@ proto_register_telnet(void)
         TFS(&tfs_s2c_c2s), 0x01, "Modifier: Who will authenticate", HFILL }
     },
     { &hf_telnet_auth_mod_how,
-      { "How", "telnet.auth.mod.how", FT_BOOLEAN, 8,
-        TFS(&auth_mod_how), 0x02, "Modifier: Authentication flow", HFILL }
+      { "How", "telnet.auth.mod.how", FT_BOOLEAN, 8,        TFS(&auth_mod_how), 0x02, "Modifier: Authentication flow", HFILL }
     },
     { &hf_telnet_auth_mod_enc,
       { "Encrypt", "telnet.auth.mod.enc", FT_UINT8, BASE_DEC,
