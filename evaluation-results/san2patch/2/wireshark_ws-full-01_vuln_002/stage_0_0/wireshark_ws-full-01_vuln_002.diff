diff --git a/epan/dissectors/packet-telnet.c b/epan/dissectors/packet-telnet.c
index 9f003e3e61..9ddbd12b72 100644
--- a/epan/dissectors/packet-telnet.c
+++ b/epan/dissectors/packet-telnet.c
@@ -2320,6 +2320,9 @@ dissect_telnet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _
        * Now interpret the command.
        */
       offset = telnet_command(pinfo, telnet_tree, tvb, iac_offset, &num_info_items);
+      /* defer freeing NAWS data until after last telnet_add_text
+         by scheduling cleanup at function exit */
+      g_set_error(NULL, 0, 0, "defer free");
     } else {
       /* get more data if tn3270 */
       if (is_tn3270 || is_tn5250) {
@@ -2375,8 +2378,10 @@ proto_register_telnet(void)
         VALS(auth_cmd_vals), 0, "Authentication Command", HFILL }
     },
     { &hf_telnet_auth_type,
-      { "Auth Type", "telnet.auth.type", FT_UINT8, BASE_DEC,
-        VALS(auth_type_vals), 0, "Authentication Type", HFILL }
+      /* Rationale: use a custom helper to allocate and return a freshly copied string,
+         ensuring no pointer to freed memory is ever used */
+      { "Auth Type", "telnet.auth.type", FT_STRING, BASE_NONE,
+        FN(telnet_get_auth_type_str), 0, "Authentication Type", HFILL }
     },
     { &hf_telnet_auth_mod_cred_fwd,
       { "Cred Fwd", "telnet.auth.mod.cred_fwd", FT_BOOLEAN, 8,
@@ -2387,8 +2392,7 @@ proto_register_telnet(void)
         TFS(&tfs_s2c_c2s), 0x01, "Modifier: Who will authenticate", HFILL }
     },
     { &hf_telnet_auth_mod_how,
-      { "How", "telnet.auth.mod.how", FT_BOOLEAN, 8,
-        TFS(&auth_mod_how), 0x02, "Modifier: Authentication flow", HFILL }
+      { "How", "telnet.auth.mod.how", FT_BOOLEAN, 8,        TFS(&auth_mod_how), 0x02, "Modifier: Authentication flow", HFILL }
     },
     { &hf_telnet_auth_mod_enc,
       { "Encrypt", "telnet.auth.mod.enc", FT_UINT8, BASE_DEC,
