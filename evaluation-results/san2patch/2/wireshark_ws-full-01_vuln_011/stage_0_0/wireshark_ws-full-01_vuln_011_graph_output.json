{"vuln_data": {"id": "wireshark_ws-full-01_vuln_011", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_aim", "branch_name": "ws-full-01", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["success", "", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\t/* Rationale: clamp buddyname_length to buffer capacity to prevent overflow */\n\tif (buddyname_length >= 256) {\n\t\tbuddyname_length = 255;\n\t}\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, 1), buddyname_length);\n\t\t/* ensure null termination */\n\t\t(*name)[buddyname_length] = '\\0';\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\t/* Rationale: use bounded copy length to avoid overflow */\n\tconst uint16_t max_len = 255;\n\tuint16_t copy_len = buddyname_length > max_len ? max_len : buddyname_length;\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, 1), copy_len);\n\t\t/* terminate string safely */\n\t\t(*name)[copy_len] = '\\0';\n\t}\n\n\treturn copy_len;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t/* Rationale: allocate a zeroed buffer to ensure safe null-termination */\n\t*name = wmem_alloc0(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\t/* clamp to maximum of 255 bytes */\n\tuint16_t copy_len = buddyname_length > 255 ? 255 : buddyname_length;\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, 1), copy_len);\n\t}\n\n\treturn copy_len;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\t/* Rationale: reject names that exceed buffer and return empty */\n\tif (buddyname_length > 255) {\n\t\t/* too long, drop the name */\n\t\treturn 0;\n\t}\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, 1), buddyname_length);\n\t\t(*name)[buddyname_length] = '\\0';\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\tuint32_t copy_len, tvb_len;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\t/* Rationale: check both tvb bounds and buffer size before copy */\n\ttvb_len = tvb_captured_length(tvb);\n\t/* ensure we don't read past tvb */\n\tif ((uint32_t)offset + 2 + buddyname_length > tvb_len) {\n\t\tcopy_len = tvb_len > (uint32_t)offset + 2 ? tvb_len - ((uint32_t)offset + 2) : 0;\n\t} else {\n\t\tcopy_len = buddyname_length;\n\t}\n\t/* clamp to buffer */\n\tif (copy_len > 255) {\n\t\tcopy_len = 255;\n\t}\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, 1), copy_len);\n\t\t(*name)[copy_len] = '\\0';\n\t}\n\n\treturn copy_len;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, "guideline": "Validate the buddyname_length against the allocated buffer size before calling memcpy to prevent out-of-bounds copying.", "description": "Before copying, check if buddyname_length >= 256. If so, truncate buddyname_length to 255 (reserving one byte for the terminating null) and then proceed with memcpy. After the copy, explicitly write a '\\0' at offset buddyname_length.", "rationale": "By validating and truncating buddyname_length to 255, any oversized input is safely reduced to the maximum buffer capacity minus one, preventing buffer overflow while preserving data integrity.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the buffer size limitation (256 bytes), introduces a conditional check to clamp the input length to 255 bytes, and adds a terminating null byte\u2014effectively preventing the out-of-bounds write without altering other functionality. It directly addresses the root cause noted by AddressSanitizer and applies at the right code location. The approach is practical and aligns with best practices for fixed-size buffers. It loses one point only because it sticks with static sizing rather than suggesting a more flexible allocation, but it remains a solid, plausible fix under the given constraints."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}, "guideline": "Perform explicit bounds checking on the buddyname_length field and clamp it to the static buffer\u2019s capacity before copying.", "description": "Insert a check immediately after reading buddyname_length: if it exceeds 255, set it to 255. Then call memcpy using this clamped length, and explicitly NUL-terminate the destination buffer: (*name)[clamped_length] = '\\0'.", "rationale": "Clamping the input length to the known buffer size guarantees that memcpy cannot write past the end of the 256-byte buffer, preventing CWE-787.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked memcpy into a fixed-size buffer) and applies the standard fix pattern: clamp the length to the buffer capacity and add a null terminator to prevent overflow. It aligns with the provided vulnerability info and fix location, is plausible to implement, and avoids over-specificity. The only minor omission is explicitly adjusting the pointer offset when copying, but overall the recommendation is well-reasoned and appropriate."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Validate all user-supplied length fields against the capacity of the destination buffer before performing any memory copy operations (CWE-787).", "description": "Add an explicit check that buddyname_length does not exceed the 256-byte buffer. If it does, clamp it to 255, then copy that many bytes and explicitly write a terminating null byte. For example:\n\n    if (buddyname_length >= 256) {\n        buddyname_length = 255;\n    }\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Clamping the copy length to the buffer\u2019s capacity prevents any out-of-bounds writes, and explicit null termination ensures the result is a well-formed string.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by clamping the user-supplied length to the 256-byte buffer and adding a null terminator, which exactly follows the CWE-787 guidance. It correctly targets the `memcpy` in `aim_get_buddyname` and even adjusts the offset for copying the name bytes. The strategy is realistic and would prevent overflow without over-complicating the change. A perfect 10 would require mention of zero-initializing the buffer or handling error reporting, but overall this is a precise, applicable, and minimally invasive patch."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "Use bounded copy functions or safe library calls (e.g., strlcpy, wmem_strndup, or tvb_strncpy) that enforce maximum length constraints and always null-terminate strings (SEI CERT STR30-C, STR31-C).", "description": "Replace the raw memcpy call with a bounded copy routine, such as wmem_strndup or tvb_strncpy, which takes a maximum length parameter and always null-terminates. For example:\n\n    *name = wmem_strndup(pool, tvb_get_ptr(tvb, offset + 2, buddyname_length), buddyname_length);\n    /* wmem_strndup will allocate buddyname_length+1 and null-terminate */", "rationale": "Safe, bounded copy functions reduce the risk of programmer error by centralizing length checks and always providing null termination, eliminating the need for manual buffer-size logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly addresses the out-of-bounds issue by replacing the unsafe memcpy with a safe, bounded copy function (wmem_strndup or tvb_strncpy). It uses the buddyname_length field and allocates buddyname_length+1 bytes to ensure null-termination, eliminating the fixed-size buffer overflow. The strategy aligns well with the vulnerability root cause, follows CERT guidelines (STR30-C, STR31-C), and is applicable at the specified code location. It is neither overly general nor unrealistically specific, making it a high-quality, practical solution."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, "guideline": "When fixed-size buffers are insufficient or the input length is large or untrusted, dynamically allocate a buffer of the exact needed size plus space for a terminator (CWE-119 mitigation).", "description": "Instead of always allocating 256 bytes, allocate buddyname_length+1 bytes so you can accommodate the entire input. After reading the length, do:\n\n    *name = wmem_alloc(pool, buddyname_length + 1);\n    memcpy(*name, tvb_get_ptr(tvb, offset + 2, 1), buddyname_length);\n    (*name)[buddyname_length] = '\\0';", "rationale": "Dynamically sizing the buffer to exactly match the input length (plus a terminator) avoids imposing arbitrary limits while still preventing overflows, since the allocation always matches the data size.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the root cause (unchecked memcpy into a fixed\u2010size buffer) by dynamically allocating buddyname_length+1 bytes and adding a null terminator. It correctly adjusts the memcpy source pointer (offset+2) to skip the length field and avoids any arbitrary upper limit, thus preventing out\u2010of\u2010bounds writes. The approach is neither overly generic (it specifies the exact code changes) nor unrealistically detailed (it doesn\u2019t reference lines beyond what was provided). The only minor omission is a bounds check on buddyname_length to prevent absurdly large allocations, but overall the fix is solid and applicable."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, "guideline": "Validate the buddyname_length against the allocated buffer size before calling memcpy to prevent out-of-bounds copying.", "description": "Before copying, check if buddyname_length >= 256. If so, truncate buddyname_length to 255 (reserving one byte for the terminating null) and then proceed with memcpy. After the copy, explicitly write a '\\0' at offset buddyname_length.", "rationale": "By validating and truncating buddyname_length to 255, any oversized input is safely reduced to the maximum buffer capacity minus one, preventing buffer overflow while preserving data integrity.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the buffer size limitation (256 bytes), introduces a conditional check to clamp the input length to 255 bytes, and adds a terminating null byte\u2014effectively preventing the out-of-bounds write without altering other functionality. It directly addresses the root cause noted by AddressSanitizer and applies at the right code location. The approach is practical and aligns with best practices for fixed-size buffers. It loses one point only because it sticks with static sizing rather than suggesting a more flexible allocation, but it remains a solid, plausible fix under the given constraints."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, "guideline": "Allocate a buffer based on the actual buddyname_length + 1 (for null termination) rather than using a fixed size, to avoid overflow or wasted space.", "description": "Replace the fixed wmem_alloc(pool, 256) call with wmem_alloc(pool, buddyname_length + 1). This allocates exactly the amount of memory required. Then memcpy the buddyname_length bytes and append a terminating null byte.", "rationale": "Allocating exactly buddyname_length + 1 ensures that the buffer is never smaller than the data to be copied plus the null terminator, eliminating any risk of overflow and reducing unnecessary memory usage.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the root cause by removing the fixed-size allocation and instead allocating exactly buddyname_length+1 bytes, which prevents out-of-bounds writes and adds a null terminator. The fix location (packet-aim.c around aim_get_buddyname) is correct and the approach is straightforward and applicable. The answer is neither overly vague nor unrealistically specific, making it a solid, high-quality solution."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, "guideline": "Use a bounded copy function (e.g., memcpy_s, g_strlcpy or similar) that takes the destination size as an argument and always null-terminates the result.", "description": "Use a safer, bounded copy API such as memcpy_s(*name, allocated_size, tvb_get_ptr(...), buddyname_length) or g_strlcpy((char *)*name, (char *)tvb_get_ptr(...), MIN(buddyname_length, allocated_size - 1) + 1). This ensures the copy cannot exceed the buffer size and results in a properly terminated string.", "rationale": "Using a bounded copy routine enforces at-compile-time and at-run-time checks on the copy length, guaranteeing that no more than the buffer capacity is copied and that the string is always null-terminated.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds write by introducing a bounded copy routine and ensuring null-termination. It aligns with the vulnerability root cause and fix location, uses industry-standard safe APIs, and is plausible to implement with minimal impact on existing functionality. The response could be improved with a bit more concrete code context (e.g., defining the allocated_size constant), but overall it is sound and appropriate."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}, "guideline": "Perform explicit bounds checking on the buddyname_length field and clamp it to the static buffer\u2019s capacity before copying.", "description": "Insert a check immediately after reading buddyname_length: if it exceeds 255, set it to 255. Then call memcpy using this clamped length, and explicitly NUL-terminate the destination buffer: (*name)[clamped_length] = '\\0'.", "rationale": "Clamping the input length to the known buffer size guarantees that memcpy cannot write past the end of the 256-byte buffer, preventing CWE-787.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked memcpy into a fixed-size buffer) and applies the standard fix pattern: clamp the length to the buffer capacity and add a null terminator to prevent overflow. It aligns with the provided vulnerability info and fix location, is plausible to implement, and avoids over-specificity. The only minor omission is explicitly adjusting the pointer offset when copying, but overall the recommendation is well-reasoned and appropriate."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}, "guideline": "Allocate the destination buffer dynamically based on the actual buddyname_length (plus one for the NUL terminator), instead of using a fixed-size allocation.", "description": "Change the fixed allocation `wmem_alloc(pool, 256)` to `wmem_alloc(pool, buddyname_length + 1)`, after reading buddyname_length. Then perform memcpy for buddyname_length bytes and set the final byte to '\\0'.", "rationale": "By allocating exactly the space required (length+1), you eliminate reliance on a static upper bound and ensure no overflow while still preserving the full name.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly addresses the root cause by replacing the fixed 256-byte buffer with a dynamic allocation based on the actual `buddyname_length+1` and adds a terminating NUL byte. This aligns well with the sanitizer report and eliminates the out-of-bounds write. The strategy is both plausible and implementable at the indicated location. The only minor gap is that it doesn\u2019t discuss an upper bound or defend against a maliciously large length leading to excessive allocation, but given the use of `wmem_alloc`, this is a reasonable omission. Overall, it\u2019s a solid, focused fix that scores high on relevance and correctness."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}, "guideline": "Leverage existing libwireshark/tvb APIs (e.g., tvb_strndup or tvb_get_string_enc) that handle length checking and NUL\u2010termination automatically.", "description": "Replace the manual wmem_alloc + memcpy sequence with a single call to `tvb_strndup(tvb, offset+2, buddyname_length)`. Assign the return value to *name; this API both checks bounds and NUL-terminates.", "rationale": "Using the existing tvb_strndup API offloads boundary checks and terminator insertion to well-tested library code, reducing the chance of human error and eliminating the overflow.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the root cause\u2014unchecked memcpy into a fixed buffer\u2014and leverages an existing Wireshark API (tvb_strndup) that enforces bounds checking and NUL-termination. It aligns well with the input vulnerability details, applies neatly to the specified code region (replacing wmem_alloc + memcpy), and avoids over-specific code changes. The approach is both precise and realistic without hallucinating nonexistent APIs or being overly generic."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a length check before the memcpy call in aim_get_buddyname, we ensure that no more bytes are copied than the buffer can hold, preventing buffer overflow.", "score": 9, "confidence": 8, "reliability_score": 32.4, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (packet-aim.c) as the precise location to address the OOB write. Adding a length check here directly mitigates the CWE-787 buffer overflow without touching unrelated code, making it both accurate and relevant. The only minor consideration is ensuring the static buffer size (256 bytes) is used in the check, but this detail was covered in the rationale. Thus, the chosen fix location is highly appropriate and effective."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 591, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check in aim_get_buddyname to limit the user-supplied buddy name length to the size of the static buffer, avoiding buffer overflow without altering existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly identified the memcpy call in aim_get_buddyname (lines 589\u2013591) as the root cause of the buffer overflow. Adding a bounds check on buddyname_length before the memcpy directly addresses the vulnerability without impacting other functionality. This fix location is accurate, relevant, and effective for eliminating the out-of-bounds write."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The overflow occurs in aim_get_buddyname when memcpy copies unchecked input into a static buffer. Inserting a length check around line 591 prevents writing past the buffer boundary without affecting other functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly pinpointed the vulnerable memcpy in aim_get_buddyname (lines 580\u2013600, specifically around line 591) where an unchecked length leads to an out-of-bounds write. The indicated location directly corresponds to the AddressSanitizer report and aligns with the root cause. Suggesting an input-length check at that spot is both relevant and likely effective without disrupting existing functionality. A small point is that more context (e.g., buffer size constant) could be noted, but the chosen location is spot-on."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 589, "end_line": 593, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding a length check immediately before the memcpy in aim_get_buddyname ensures that user-supplied names longer than the fixed buffer are truncated, preventing out-of-bounds writes without impacting normal functionality beyond trimming overly long inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location directly targets the memcpy call in aim_get_buddyname, which is the root cause of the out-of-bounds write. Inserting a length check immediately before this call is precise and effective in preventing buffer overflows without affecting other functionality. Thus, the location is accurate, relevant, and likely to resolve the vulnerability."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 585, "end_line": 600, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The memcpy in aim_get_buddyname (around line 591) copies an attacker-controlled length field into a fixed-size buffer without bounds checking, causing a buffer overflow. By adding a check and clamping the length to the buffer capacity before memcpy, we eliminate the overflow while preserving the original functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected fix location pinpoints the exact memcpy call in aim_get_buddyname where unchecked buddyname_length is copied into a fixed-size buffer. This aligns perfectly with the ASan report and root cause analysis (CWE-787/CWE-119). Clamping length here would effectively prevent the overflow without altering other functionality. The only minor deduction is for not explicitly considering the tvb_get_ptr length parameters, but overall the location is spot-on."}], "location_candidates": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 591, "end_line": 591, "function_name": "aim_get_buddyname", "code": "memcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1976, "start_line": 1976, "end_line": 1976, "function_name": "dissect_aim_chat_outgoing_msg", "code": "buddyname_length = aim_get_buddyname( pinfo->pool, &buddyname, tvb, 30 );", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 809, "start_line": 809, "end_line": 809, "function_name": "dissect_aim_snac", "code": "subtype->dissector(subtvb, pinfo, family_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1618, "start_line": 1618, "end_line": 1618, "function_name": "dissect_aim_pdu", "code": "dissect_aim_snac(tvb, pinfo, offset, aim_tree, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-tcp.c", "fix_line": 5569, "start_line": 5569, "end_line": 5569, "function_name": "tcp_dissect_pdus", "code": "(*dissect_pdu)(next_tvb, pinfo, tree, dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1655, "end_line": 1655, "function_name": "dissect_aim", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "fuzz/fuzzshark.c", "fix_line": 359, "start_line": 359, "end_line": 359, "function_name": "LLVMFuzzerTestOneInput", "code": "epan_dissect_run(edt, WTAP_FILE_TYPE_SUBTYPE_UNKNOWN, &rec, &fdlocal, NULL /* &fuzz_cinfo */);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the AIM dissector (packet-aim.c), the function aim_get_buddyname uses memcpy to copy incoming data into a fixed-size buffer without verifying that the input length does not exceed the buffer\u2019s capacity. This unchecked copy can overwrite adjacent memory, leading to an out-of-bounds write and potential program crash or code execution.", "rationale": "AddressSanitizer reports a __chk_fail in memcpy at packet-aim.c:591, indicating that more data is being copied than the destination buffer can hold. The lack of bounds checking before memcpy is the direct cause of the buffer overflow (CWE-787). This description highlights the faulty memcpy usage in aim_get_buddyname and its impact, providing a clear basis for adding proper length validation in a patch."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the AIM dissector\u2019s aim_get_buddyname function, data from the packet is copied into a fixed-size buffer using memcpy without verifying that the source length fits, allowing an out-of-bounds write when handling overly long inputs.", "rationale": "AddressSanitizer reports a crash in memcpy at packet-aim.c:591, indicating that user-controlled data exceeds the destination buffer. The lack of bounds checking before memcpy leads to a buffer overflow (CWE-119) manifesting as an out-of-bounds write (CWE-787)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The AIM protocol dissector in packet-aim.c calls memcpy in aim_get_buddyname to copy a buddy name field into a fixed-size buffer without validating the incoming length. If the field is larger than the buffer, memcpy writes past the end, leading to an out-of-bounds write and program abort.", "rationale": "AddressSanitizer reports a fortified memcpy failure at packet-aim.c:591, demonstrating that unvalidated input length is copied into a statically sized buffer. By not checking the field length before memcpy, the code permits writing beyond the buffer boundary (CWE-787), resulting in a buffer overflow (CWE-119). The description highlights the vulnerable function, the missing length check, and the copy operation that triggers the overflow."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the AIM dissector (packet-aim.c), the function aim_get_buddyname uses memcpy to copy incoming data into a fixed-size buffer without verifying that the input length does not exceed the buffer\u2019s capacity. This unchecked copy can overwrite adjacent memory, leading to an out-of-bounds write and potential program crash or code execution.", "rationale": "AddressSanitizer reports a __chk_fail in memcpy at packet-aim.c:591, indicating that more data is being copied than the destination buffer can hold. The lack of bounds checking before memcpy is the direct cause of the buffer overflow (CWE-787). This description highlights the faulty memcpy usage in aim_get_buddyname and its impact, providing a clear basis for adding proper length validation in a patch."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the AIM protocol dissector\u2019s aim_get_buddyname function (packet-aim.c), the implementation uses memcpy to transfer the buddy name field from the packet into a statically allocated buffer without verifying that the input length does not exceed the buffer\u2019s capacity. If an attacker provides a buddy name longer than the buffer, memcpy will write past the end, causing an out-of-bounds write that can crash the program or enable arbitrary code execution.", "rationale": "AddressSanitizer reports a memcpy overflow at packet-aim.c:591 in the aim_get_buddyname function, demonstrating that unchecked user-supplied data is being copied into a fixed-size buffer. By omitting a length validation before calling memcpy, the code permits writing beyond the buffer boundary (CWE-787), resulting in a buffer overflow (CWE-119)."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 591, "end_line": 591, "function_name": "aim_get_buddyname", "code": "memcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1976, "start_line": 1976, "end_line": 1976, "function_name": "dissect_aim_chat_outgoing_msg", "code": "buddyname_length = aim_get_buddyname( pinfo->pool, &buddyname, tvb, 30 );", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 809, "start_line": 809, "end_line": 809, "function_name": "dissect_aim_snac", "code": "subtype->dissector(subtvb, pinfo, family_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1618, "start_line": 1618, "end_line": 1618, "function_name": "dissect_aim_pdu", "code": "dissect_aim_snac(tvb, pinfo, offset, aim_tree, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-tcp.c", "fix_line": 5569, "start_line": 5569, "end_line": 5569, "function_name": "tcp_dissect_pdus", "code": "(*dissect_pdu)(next_tvb, pinfo, tree, dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1655, "end_line": 1655, "function_name": "dissect_aim", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "fuzz/fuzzshark.c", "fix_line": 359, "start_line": 359, "end_line": 359, "function_name": "LLVMFuzzerTestOneInput", "code": "epan_dissect_run(edt, WTAP_FILE_TYPE_SUBTYPE_UNKNOWN, &rec, &fdlocal, NULL /* &fuzz_cinfo */);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/qqor/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-full-01_vuln_011/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-full-01_vuln_011", "sanitizer_output": "+ FUZZER=handler_aim\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_aim -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_aim -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: aim\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 982848296\nINFO: Loaded 1 modules   (420518 inline 8-bit counters): 420518 [0xa9f6a00, 0xaa5d4a6), \nINFO: Loaded 1 PC tables (420518 PCs): 420518 [0xaa5d4a8,0xb0c7f08), \n/out/handler_aim: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n*** buffer overflow detected ***: terminated\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: ABRT on unknown address 0x000000000012 (pc 0x7fe9d7af700b bp 0x7ffc4c453b00 sp 0x7ffc4c453780 T0)\nSCARINESS: 10 (signal)\n    #0 0x7fe9d7af700b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #1 0x7fe9d7ad6858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #2 0x7fe9d7b41265  (/lib/x86_64-linux-gnu/libc.so.6+0x8d265) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #3 0x7fe9d7be3cd9 in __fortify_fail (/lib/x86_64-linux-gnu/libc.so.6+0x12fcd9) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #4 0x7fe9d7be2575 in __chk_fail (/lib/x86_64-linux-gnu/libc.so.6+0x12e575) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #5 0x5dbcb23 in memcpy /usr/include/x86_64-linux-gnu/bits/string_fortified.h:34:10\n    #6 0x5dbcb23 in aim_get_buddyname /src/wireshark/epan/dissectors/packet-aim.c:591:3\n    #7 0x5dbcb23 in dissect_aim_chat_outgoing_msg /src/wireshark/epan/dissectors/packet-aim.c:1976:21\n    #8 0x5dbaa2f in dissect_aim_snac /src/wireshark/epan/dissectors/packet-aim.c:809:3\n    #9 0x5dbaa2f in dissect_aim_pdu /src/wireshark/epan/dissectors/packet-aim.c:1618:3\n    #10 0x52ff8af in tcp_dissect_pdus /src/wireshark/epan/dissectors/packet-tcp.c:5569:13\n    #11 0x5db7f4d in dissect_aim /src/wireshark/epan/dissectors/packet-aim.c:1655:2\n    #12 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #13 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #14 0x5b90394 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #15 0x5b90394 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #16 0x544b347 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #17 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #18 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #19 0x5b81237 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #20 0x5b81237 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #21 0x5b81237 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #22 0x52bddb0 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #23 0x50b47c8 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #24 0x4f674a0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #25 0x4f51ac5 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #26 0x4f5755f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #27 0x4f83452 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #28 0x7fe9d7ad8082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #29 0x4f49cad in _start (/out/handler_aim+0x4f49cad)\n\nDEDUP_TOKEN: raise--abort--\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: ABRT (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d) in raise\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x2a,0x1,0x2a,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a,0x2,0x2,0x0,0x0,0xf7,0x0,0xe,0x0,0x5,0x0,0x0,0x0,0x0,0xff,0xfc,0x2a,0x2,0x2,0x24,0x8,0x0,0x0,0x0,0x0,0x0,0xf7,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a,0x2,0x2,0x24,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2a,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x89,0x1f,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,\n*\\001*\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000(\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\000o\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000*\\002\\002\\000\\000\\367\\000\\016\\000\\005\\000\\000\\000\\000\\377\\374*\\002\\002$\\010\\000\\000\\000\\000\\000\\367\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000*\\002\\002$\\000\\200\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\001*\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\211\\037\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\012\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/qqor/aixcc/dataset/tarballs/wireshark_ws-full-01/pov/wireshark_ws-full-01_vuln_011:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_aim -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/qqor/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}