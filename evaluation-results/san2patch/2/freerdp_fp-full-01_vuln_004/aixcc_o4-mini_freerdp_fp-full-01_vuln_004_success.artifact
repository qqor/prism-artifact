{"vuln_data": {"id": "freerdp_fp-full-01_vuln_004", "subject": "freerdp", "work_name": "freerdp", "project_name": "freerdp", "hiding_project_name": "", "project_full_name": "freerdp", "harness_name": "TestFuzzCoreServer", "branch_name": "fp-full-01", "project_repo_name": "official-afc-freerdp"}, "data_type": "oss-fuzz", "patch_success": ["success", "", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "patched_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\t// Added check to ensure 'size' does not exceed buffer allocation (prevent OOB write)\n\t#define MCS_MAX_CREATE_REQUEST 992\n\tif (size > MCS_MAX_CREATE_REQUEST)\n\t\treturn FALSE;\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "func_def": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)", "func_ret": ["return result;"]}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "patched_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\t/* Prevent overflow: validate length against heap buffer size */\n#ifndef MCS_MAX_CREATE_REQUEST\n#define MCS_MAX_CREATE_REQUEST 992\n#endif\n\tif (length > MCS_MAX_CREATE_REQUEST)\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "func_def": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return tpkt_ensure_stream_consumed(s, tlength);"]}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "patched_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\t// Validate externally-supplied size against fixed max (prevent OOB)\n\tconst size_t max_create_request = 992;\n\tif (size > max_create_request)\n\t{\n\t\treturn FALSE;\n\t}\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "func_def": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)", "func_ret": ["return result;"]}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "patched_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (length > MCS_MAX_CREATE_REQUEST) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\t/* Combined check to enforce max size */\n#ifndef MCS_MAX_CREATE_REQUEST\n#define MCS_MAX_CREATE_REQUEST 992\n#endif\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "func_def": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return tpkt_ensure_stream_consumed(s, tlength);"]}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "patched_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\t// Clamp input size to prevent reading beyond allocated buffer\n\tconst size_t MCS_MAX_CREATE_REQUEST = 992;\n\tsize_t init_size = (size > MCS_MAX_CREATE_REQUEST) ? MCS_MAX_CREATE_REQUEST : size;\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, init_size);\n\n\tWINPR_ASSERT(data || (init_size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "func_def": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)", "func_ret": ["return result;"]}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "patched_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\t/* Clamp length to prevent overflow */\n#ifndef MCS_MAX_CREATE_REQUEST\n#define MCS_MAX_CREATE_REQUEST 992\n#endif\n\tif (length > MCS_MAX_CREATE_REQUEST)\n\t{\n\t\tlength = MCS_MAX_CREATE_REQUEST;\n\t}\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "func_def": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return tpkt_ensure_stream_consumed(s, tlength);"]}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "patched_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\t// Enforce maximum stream capacity to avoid overflow\n\tif (Stream_Capacity(s) > 992)\n\t{\n\t\tStream_SetLength(s, 992);\n\t}\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "func_def": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)", "func_ret": ["return result;"]}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "patched_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\t/* Validate and log oversized request to prevent overflow */\n#ifndef MCS_MAX_CREATE_REQUEST\n#define MCS_MAX_CREATE_REQUEST 992\n#endif\n\tif (length > MCS_MAX_CREATE_REQUEST)\n\t{\n\t\tWLog_ERR(TAG, \"Conference create request length %zu exceeds max %d\", length, MCS_MAX_CREATE_REQUEST);\n\t\treturn FALSE;\n\t}\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "func_def": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return tpkt_ensure_stream_consumed(s, tlength);"]}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "patched_code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\t// Only proceed if the size is within allowed bounds\n\tconst size_t MCS_MAX_CREATE_REQUEST = 992;\n\tBOOL result = FALSE;\n\trdpMcs* mcs = NULL;\n\tif (size <= MCS_MAX_CREATE_REQUEST)\n\t{\n\t\tmcs = test_mcs_new();\n\t\tif (mcs)\n\t\t{\n\t\t\tresult = mcs_recv_connect_initial(mcs, s);\n\t\t\ttest_mcs_free(mcs);\n\t\t}\n\t}\n\treturn result;\n}", "func_def": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)", "func_ret": ["return result;"]}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "patched_code": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)\n{\n\tUINT16 li = 0;\n\tsize_t length = 0;\n\tBOOL upwardFlag = FALSE;\n\tUINT16 tlength = 0;\n\n\tWINPR_ASSERT(mcs);\n\tWINPR_ASSERT(s);\n\n\tif (!tpkt_read_header(s, &tlength))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_data(s, &li, tlength))\n\t\treturn FALSE;\n\n\tif (!ber_read_application_tag(s, MCS_TYPE_CONNECT_INITIAL, &length))\n\t\treturn FALSE;\n\n\t/* callingDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* calledDomainSelector (OCTET_STRING) */\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tStream_Seek(s, length);\n\n\t/* upwardFlag (BOOLEAN) */\n\tif (!ber_read_BOOL(s, &upwardFlag))\n\t\treturn FALSE;\n\n\t/* targetParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->targetParameters))\n\t\treturn FALSE;\n\n\t/* minimumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->minimumParameters))\n\t\treturn FALSE;\n\n\t/* maximumParameters (DomainParameters) */\n\tif (!mcs_read_domain_parameters(s, &mcs->maximumParameters))\n\t\treturn FALSE;\n\n\tif (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n#ifndef MCS_MAX_CREATE_REQUEST\n#define MCS_MAX_CREATE_REQUEST 992\n#endif\n\t/* Only proceed with valid length to avoid overflow */\n\tif (length <= MCS_MAX_CREATE_REQUEST)\n\t{\n\t\tif (!gcc_read_conference_create_request(s, mcs))\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;\n\n\treturn tpkt_ensure_stream_consumed(s, tlength);\n}", "func_def": "BOOL mcs_recv_connect_initial(rdpMcs* mcs, wStream* s)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return tpkt_ensure_stream_consumed(s, tlength);"]}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}, "guideline": "Validate untrusted length values before using them to allocate or copy memory, ensuring they do not exceed buffer sizes (CWE-119).", "description": "In gcc_read_client_network_data (libfreerdp/core/gcc.c), after extracting the client\u2010supplied name length, add a check `if (nameLength > CHANNEL_NAME_LEN) return ERROR_INVALID_DATA;` before calling `Stream_Read`. This ensures that the requested copy size never exceeds the 8-byte buffer.", "rationale": "By validating the length in the caller before any allocation or copy, we prevent invalid (excessive) sizes from ever reaching the buffer, eliminating the overflow vector.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked client\u2010supplied length) and applies the standard CWE-119 fix pattern of validating the length before copying. The suggested location (in gcc_read_client_network_data before Stream_Read) is accurate and plausible, and the approach is neither too vague nor overly detailed given the context. It directly addresses the overflow without impacting other logic. A higher score was withheld only because additional context (e.g., precise error handling or logging) could further harden the patch, but overall this is a solid and applicable fix."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, "guideline": "Sanitize and validate all untrusted length inputs before using them in memory copy operations (CWE-787).", "description": "In libfreerdp/core/gcc.c, within gcc_read_client_data_blocks (around lines 615\u2013620), insert a check that the client-supplied length does not exceed the remaining capacity of the 992-byte buffer before calling Stream_Read. If the length is too large, log an error and return FALSE.", "rationale": "By validating the length against the actual buffer capacity, we eliminate the possibility of an out-of-bounds write beyond the 992-byte allocation.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix correctly targets the root cause (unsanitized length leading to heap-buffer overflow) and places the check in the appropriate function (around lines 615\u2013620 in gcc_read_client_data_blocks). The strategy to validate the client-supplied length against the 992-byte buffer before calling Stream_Read is sound and aligns with CWE-787 guidance. The answer is neither overly generic nor unrealistically specific given the information provided. A more detailed code snippet would earn a higher score, but the current level of detail is adequate to guide implementation and testing."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Validate all externally-supplied length fields against the bounds of the destination buffer before copying or reading data (CWE-787).", "description": "In gcc_read_conference_create_request (libfreerdp/core/mcs.c), immediately after ber_read_octet_string_tag and before Stream_Read, insert a sanity check: if (length > MCS_MAX_CREATE_REQUEST) return FALSE;. Define MCS_MAX_CREATE_REQUEST to 992 (the original buffer size) so that downstream Stream_Read cannot write past the heap allocation.", "rationale": "By checking the untrusted length field against a defined maximum before any copy, we eliminate the condition that allowed an 8-byte overflow past the 992-byte buffer.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the allocated buffer size before any copy occurs. It pinpoints the correct function and insertion point (gcc_read_conference_create_request), defines an appropriate constant (MCS_MAX_CREATE_REQUEST = 992), and follows the CWE-787 guideline without introducing side effects. The strategy is neither overly general nor excessively detailed given the context, making it a plausible, actionable patch."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "If the valid data length can exceed the size of a fixed buffer, perform dynamic allocation based on a validated size parameter rather than use a hard-coded buffer (CWE-119).", "description": "Change mcs_new() (called by test_mcs_new) to take a size argument and allocate its heap buffer with malloc(length + STREAM_HEADER_SIZE) rather than always 992 bytes. In gcc_read_conference_create_request, after validating length, call mcs_new(length) so the buffer is sized to exactly accommodate the incoming data.", "rationale": "Allocating the buffer dynamically based on the validated length guarantees that the buffer is always large enough for the requested data, removing reliance on brittle fixed sizes.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy directly addresses the root cause by replacing the fixed-size buffer with a dynamically allocated buffer based on the validated length, which removes the out-of-bounds risk. It aligns well with the identified vulnerability location and the provided guideline. The approach is plausible and would integrate with mcs_new/test_mcs_new, though it remains at a high level without implementation details (e.g., handling integer overflow or freeing the new buffer correctly), so it loses a couple of points for being somewhat generic."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, "guideline": "Use or wrap stream-read functions with explicit capacity checks (e.g. Stream_EnsureRemainingCapacity) to prevent any attempt to read beyond the end of the allocated buffer.", "description": "Introduce a wrapper for Stream_Read that first calls Stream_EnsureRemainingCapacity(s, length). Replace direct calls to Stream_Read(s, dest, length) in the MCS/GCC path with wrapper_Stream_Read(s, dest, length), which will log an error and return FALSE if the remaining capacity is insufficient.", "rationale": "Centralizing the capacity check in a read-wrapper function enforces a uniform safety boundary for all stream reads and prevents any bypass of the check in the future.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the root cause (lack of bounds checking) by centralizing capacity checks in a Stream_Read wrapper. This aligns well with the vulnerability description and suggested fix locations. It is plausible to apply in the MCS/GCC code paths and avoids bypass. The approach is neither overly general nor unrealistically detailed, making it a practical and maintainable solution. Continuous wrapping enforces uniform safety without impacting unrelated features."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, "guideline": "Sanitize and validate all untrusted length inputs before using them in memory copy operations (CWE-787).", "description": "In libfreerdp/core/gcc.c, within gcc_read_client_data_blocks (around lines 615\u2013620), insert a check that the client-supplied length does not exceed the remaining capacity of the 992-byte buffer before calling Stream_Read. If the length is too large, log an error and return FALSE.", "rationale": "By validating the length against the actual buffer capacity, we eliminate the possibility of an out-of-bounds write beyond the 992-byte allocation.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix correctly targets the root cause (unsanitized length leading to heap-buffer overflow) and places the check in the appropriate function (around lines 615\u2013620 in gcc_read_client_data_blocks). The strategy to validate the client-supplied length against the 992-byte buffer before calling Stream_Read is sound and aligns with CWE-787 guidance. The answer is neither overly generic nor unrealistically specific given the information provided. A more detailed code snippet would earn a higher score, but the current level of detail is adequate to guide implementation and testing."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, "guideline": "Enforce strict upper bounds based on the allocated buffer size when copying or reading data (CWE-119 mitigation).", "description": "Replace the unguarded Stream_Read call with a bounded read: calculate the maximum allowable length (min(requested_length, buffer_capacity - bytes_already_read)) and pass that to Stream_Read. If the requested length exceeds capacity, reject the request.", "rationale": "Using a bounded read pattern ensures that even if a malicious client requests excessive data, only the safe, precomputed maximum will ever be read into the buffer.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed fix correctly identifies the root cause (unchecked client\u2010supplied length) and prescribes a standard CWE-119 mitigation: calculate and enforce an upper bound on the read length before calling Stream_Read, rejecting overly large requests. This approach aligns with the sanitizer report and the identified overflow at the heap buffer boundary. However, the recommendation remains at a high\u2010level and does not show concrete code changes at libfreerdp/core/gcc.c:615\u2013620; adding a code snippet or more precise integration guidance would strengthen the solution and reduce ambiguity. Thus, the strategy is sound but somewhat general, earning a score of 7."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, "guideline": "Introduce defensive early exits on detection of invalid or out-of-range parameters to prevent unsafe operations.", "description": "Add an explicit size validation in mcs_new or upstream parsing so that any block length field greater than the known maximum (e.g., 992) is considered malformed and triggers a protocol error, aborting the MCS connection setup.", "rationale": "Failing early on malformed or oversized blocks prevents further processing of invalid data, preserving heap integrity and stopping the overflow at the protocol boundary.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause by adding a bounds check on the client-supplied length before the heap copy, preventing the 8-byte overflow. The guideline to perform early exits on malformed or oversized blocks is sound and aligns with defensive programming best practices. The suggestion to validate in mcs_new or upstream parsing covers the correct fix location and avoids altering unrelated functionality. However, the answer is somewhat high-level and lacks exact code-level detail (e.g., the specific check and error path), so it cannot be scored higher without further specificity."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}, "guideline": "Validate untrusted length values before using them to allocate or copy memory, ensuring they do not exceed buffer sizes (CWE-119).", "description": "In gcc_read_client_network_data (libfreerdp/core/gcc.c), after extracting the client\u2010supplied name length, add a check `if (nameLength > CHANNEL_NAME_LEN) return ERROR_INVALID_DATA;` before calling `Stream_Read`. This ensures that the requested copy size never exceeds the 8-byte buffer.", "rationale": "By validating the length in the caller before any allocation or copy, we prevent invalid (excessive) sizes from ever reaching the buffer, eliminating the overflow vector.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked client\u2010supplied length) and applies the standard CWE-119 fix pattern of validating the length before copying. The suggested location (in gcc_read_client_network_data before Stream_Read) is accurate and plausible, and the approach is neither too vague nor overly detailed given the context. It directly addresses the overflow without impacting other logic. A higher score was withheld only because additional context (e.g., precise error handling or logging) could further harden the patch, but overall this is a solid and applicable fix."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}, "guideline": "Implement runtime bounds checking in Stream_Read to prevent overflows even when assertions are disabled, following SEI CERT C STR31.", "description": "In Stream_Read (winpr/include/winpr/stream.h), replace the assertion `WINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);` with a runtime check:\n```\nif (Stream_GetRemainingCapacity(_s) < _n) {\n  WLog_ERR(TAG, \"Stream_Read: requested %zu bytes but only %zu available\", _n, Stream_GetRemainingCapacity(_s));\n  return FALSE;\n}\n```\nThen proceed with `memcpy` and `Stream_Seek` only when safe.", "rationale": "Runtime checks in Stream_Read protect against buffer overreads or overwrites even in production builds where assertions are disabled, making the code more robust.", "score": 6, "confidence": 8, "reliability_score": 10.8, "eval_rationale": "The proposed fix correctly identifies the need for a runtime bounds check in Stream_Read and aligns with SEI CERT C STR31, preventing buffer overflows when assertions are disabled. However, it is flawed in implementation: Stream_Read is declared as returning void, so returning FALSE is invalid and would break compilation. The use of TAG and WLog_ERR also assumes existing infrastructure without confirmation. Overall, the strategy is sound but the details are not fully applicable, requiring adjustments to match the function signature and logging conventions."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}, "guideline": "Adopt secure coding practices by centralizing boundary validation at API boundaries and returning errors for invalid inputs.", "description": "Introduce a new helper `Stream_ReadSafe(wStream* s, void* b, size_t n, size_t maxAllowed)` that checks `n <= maxAllowed && Stream_GetRemainingCapacity(s) >= n` before copying. Replace direct calls to `Stream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1)` with `Stream_ReadSafe(s, channel->Name, nameLength, CHANNEL_NAME_LEN + 1)`.", "rationale": "A centralized safe-read wrapper reduces duplication, ensures consistent validation across all callers, and makes it easier to audit and maintain the boundary checks.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly identifies the lack of validation as the root cause and introduces a centralized \u2018Stream_ReadSafe\u2019 wrapper that enforces both a maximum allowed size and remaining buffer capacity. This approach cleanly addresses the CWE-787 overflow without scattering checks throughout the code and is implementable at the given locations. It isn\u2019t overly generic or hallucinated, nor is it unrealistically detailed for unknown code context. A minor detail\u2014the source of the `nameLength` argument\u2014could be clarified, but overall the fix strategy is sound and applicable."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}], "fix_location_candidates": [{"locations": [{"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1438, "end_line": 1446, "function_name": "", "code": "BOOL freerdp_is_valid_mcs_create_request(const BYTE* data, size_t size)\n{\n\n\twStream sbuffer = { 0 };\n\twStream* s = Stream_StaticConstInit(&sbuffer, data, size);\n\n\tWINPR_ASSERT(data || (size == 0));\n\tWINPR_ASSERT(s);\n\n\trdpMcs* mcs = test_mcs_new();\n\tWINPR_ASSERT(mcs);\n\n\tBOOL result = mcs_recv_connect_initial(mcs, s);\n\ttest_mcs_free(mcs);\n\treturn result;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By validating the untrusted length field in the MCS create request at both the preliminary validation function and immediately before allocation, we ensure that no oversized length can lead to an out-of-bounds write in Stream_Read.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed locations for length validation are only tangentially related to where the overflow actually occurs. The first location in freerdp.c is a generic preliminary check that doesn\u2019t guarantee protection at the heap\u2010allocated buffer boundary; the second in mcs.c precedes conference parsing but doesn\u2019t enforce the 992\u2010byte limit used by Stream_Read. Neither directly addresses the unchecked client\u2010supplied length before the heap write in winpr/stream.h, so the fix is unlikely to fully prevent the overflow."}, {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 695, "end_line": 705, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The overflow occurs in Stream_Read when a client-supplied length is used without bounds checking. Adding a size check here stops writes beyond the allocated buffer, fully addressing the vulnerability without altering higher-level logic.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The chosen fix location in Stream_Read (winpr/include/winpr/stream.h:695\u2013705) is not appropriate for this vulnerability. The existing WINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n) only validates the source stream\u2019s remaining data, not the size of the destination buffer (_b), which is the heap buffer allocated in mcs_new. Thus, adding bounds checks here would not prevent an overflow of the destination buffer. A correct fix must validate the client-supplied length against the heap buffer\u2019s allocated size at the call site in the MCS code path (e.g., before invoking Stream_Read), not in the generic stream.h inline function. Modifying Stream_Read is unlikely to resolve the vulnerability and risks breaking other use cases of this utility function."}, {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1885, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The patch ensures that Stream_Read enforces bounds checking to prevent writing beyond the allocated buffer and that the caller in gcc_read_client_network_data properly handles error conditions, thus preventing the heap-based buffer overflow triggered by malicious length fields.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed locations include the generic Stream_Read in stream.h and a static use-site in gcc.c (the CHANNEL_NAME_LEN call), but they do not target the actual dynamic copy where the client-supplied length is used without validation. While tightening Stream_Read\u2019s bounds checks is generally useful, modifying the static name copy isn\u2019t where the overflow occurs. The real fix should validate the untrusted length before the dynamic Stream_Read call in the MCS PDU parser. Because the chosen sites miss the vulnerable copy, the likelihood of resolving the overflow is low, so substantial points are deducted."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the untrusted length field immediately before the buffer copy in gcc_read_client_data_blocks. This prevents a malicious client from specifying an overly large size and causing a heap-based buffer overflow.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The suggested patch point in libfreerdp/core/gcc.c around the call to gcc_read_client_network_data is too high-level and does not address the actual out-of-bounds write in Stream_Read (winpr/include/winpr/stream.h). The overflow occurs when Stream_Read copies the client-supplied length into a fixed 992-byte buffer without validation. A proper patch must insert bounds checking at or immediately before the memcpy in Stream_Read or within the gcc_read_client_data_blocks function where the buffer is populated, not in the caller in gcc.c. Thus the chosen location is unlikely to prevent the overflow and does not directly target the root cause."}, {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 695, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 400, "end_line": 430, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By adding a generic bounds check in Stream_Read and validating the length in the protocol parsing function (gcc_read_conference_create_request), we prevent untrusted length values from triggering a heap-based buffer overflow without altering other functionality.", "score": 6, "confidence": 6, "reliability_score": 9.600000000000001, "eval_rationale": "The LLM correctly identifies stream.h's Stream_Read as a key place for enforcing a runtime bounds check instead of an assert, and adding validation in the protocol parsing path is sound. However, it points to libfreerdp/core/gcc.c rather than the MCS create-request handler where the offending length is read, mixing up GCC and MCS code paths. This mislocation reduces confidence that the fix will actually target the reported overflow. Overall, the chosen locations are partially relevant but include a significant misplacement."}], "location_candidates": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 703, "end_line": 703, "function_name": "Stream_Read", "code": "memcpy(_b, (_s->pointer), (_n));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1875, "end_line": 1875, "function_name": "gcc_read_client_network_data", "code": "Stream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 617, "end_line": 617, "function_name": "gcc_read_client_data_blocks", "code": "if (!gcc_read_client_network_data(sub, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 414, "end_line": 414, "function_name": "gcc_read_conference_create_request", "code": "if (!gcc_read_client_data_blocks(s, mcs, length))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 700, "end_line": 700, "function_name": "mcs_recv_connect_initial", "code": "if (!gcc_read_conference_create_request(s, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1441, "end_line": 1441, "function_name": "freerdp_is_valid_mcs_create_request", "code": "BOOL result = mcs_recv_connect_initial(mcs, s);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 1446, "start_line": 1446, "end_line": 1446, "function_name": "mcs_new", "code": "mcs->channels = (rdpMcsChannel*)calloc(CHANNEL_MAX_COUNT, sizeof(rdpMcsChannel));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "freerdp_is_valid_mcs_create_request", "code": "rdpMcs* mcs = test_mcs_new();", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In FreeRDP\u2019s GCC/MCS code path, Stream_Read uses a length field extracted from an untrusted client \u201ccreate request\u201d PDU to read data into a heap buffer without verifying that the requested size fits within the buffer\u2019s allocated length, leading to an out-of-bounds write past the end of the buffer.", "rationale": "The AddressSanitizer report shows an 8\u2010byte write immediately after a 992\u2010byte allocation in mcs_new. The length value driving Stream_Read is derived from unvalidated network data, so the code does not enforce upper bounds before performing the copy, resulting in a heap\u2010based buffer overflow (CWE-787)."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The Stream_Read implementation in winpr/libfreerdp\u2019s GCC handling reads a client-provided length for conference creation data and then copies that many bytes into a heap buffer allocated by mcs_new, without verifying that the requested length does not exceed the buffer\u2019s capacity. This missing bounds check allows an attacker to trigger an out-of-bounds write (heap buffer overflow) when the length field is larger than the allocated buffer size.", "rationale": "AddressSanitizer pinpoints an 8-byte heap-buffer-overflow in Stream_Read (winpr/include/winpr/stream.h:703) invoked by gcc_read_client_network_data \u2192 gcc_read_client_data_blocks. The buffer allocated by mcs_new is 992 bytes, but an unchecked client length causes writes beyond this boundary. This confirms an out-of-bounds write vulnerability resulting from improper validation of untrusted length fields."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In gcc_read_client_network_data (via Stream_Read), the code reads a client-supplied data block into a heap-allocated buffer without verifying that the requested length fits within the buffer\u2019s capacity. A malicious client can specify a block larger than the allocated 992 bytes, causing an 8-byte write past the end of the buffer.", "rationale": "AddressSanitizer reports a heap-buffer-overflow at winpr/stream.h:703:3 when Stream_Read writes 8 bytes just beyond the 992-byte region. The lack of a bounds check before copying client data into the buffer directly leads to an out-of-bounds write (CWE-787)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In FreeRDP\u2019s GCC/MCS code path, Stream_Read uses a length field extracted from an untrusted client \u201ccreate request\u201d PDU to read data into a heap buffer without verifying that the requested size fits within the buffer\u2019s allocated length, leading to an out-of-bounds write past the end of the buffer.", "rationale": "The AddressSanitizer report shows an 8\u2010byte write immediately after a 992\u2010byte allocation in mcs_new. The length value driving Stream_Read is derived from unvalidated network data, so the code does not enforce upper bounds before performing the copy, resulting in a heap\u2010based buffer overflow (CWE-787)."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In FreeRDP\u2019s GCC/MCS implementation (winpr/libfreerdp), Stream_Read extracts a length value from an untrusted client \"create request\" PDU and copies that many bytes into a heap buffer allocated by mcs_new (992 bytes) without checking that the requested size fits. A malicious client can specify a larger length, causing an 8-byte write beyond the allocated buffer boundary and triggering a heap-based buffer overflow.", "rationale": "AddressSanitizer reports an 8-byte heap-buffer-overflow at winpr/include/winpr/stream.h:703 when Stream_Read, in the GCC/MCS code path, writes past the end of a 992-byte heap allocation. The vulnerability arises because the client-supplied length field is used without validation before copying data into the buffer, leading directly to an out-of-bounds write."}, "crash_stack_trace": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 703, "end_line": 703, "function_name": "Stream_Read", "code": "memcpy(_b, (_s->pointer), (_n));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1875, "end_line": 1875, "function_name": "gcc_read_client_network_data", "code": "Stream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 617, "end_line": 617, "function_name": "gcc_read_client_data_blocks", "code": "if (!gcc_read_client_network_data(sub, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 414, "end_line": 414, "function_name": "gcc_read_conference_create_request", "code": "if (!gcc_read_client_data_blocks(s, mcs, length))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 700, "end_line": 700, "function_name": "mcs_recv_connect_initial", "code": "if (!gcc_read_conference_create_request(s, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1441, "end_line": 1441, "function_name": "freerdp_is_valid_mcs_create_request", "code": "BOOL result = mcs_recv_connect_initial(mcs, s);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [{"file_name": "libfreerdp/core/mcs.c", "fix_line": 1446, "start_line": 1446, "end_line": 1446, "function_name": "mcs_new", "code": "mcs->channels = (rdpMcsChannel*)calloc(CHANNEL_MAX_COUNT, sizeof(rdpMcsChannel));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "freerdp_is_valid_mcs_create_request", "code": "rdpMcs* mcs = test_mcs_new();", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/freerdp_fp-full-01_vuln_004/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "freerdp_fp-full-01_vuln_004", "sanitizer_output": "+ FUZZER=TestFuzzCoreServer\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer TestFuzzCoreServer -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/TestFuzzCoreServer -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 2884325085\nINFO: Loaded 1 modules   (70193 inline 8-bit counters): 70193 [0x55ecce390594, 0x55ecce3a17c5), \nINFO: Loaded 1 PC tables (70193 PCs): 70193 [0x55ecce3a17c8,0x55ecce4b3ad8), \n/out/TestFuzzCoreServer: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: *************************************************\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: This build is using [runtime-check] build options:\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: * 'WITH_VERBOSE_WINPR_ASSERT=ON'\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: \n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: [runtime-check] build options might slow down the application\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: *************************************************\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_SOCKET, SO_KEEPALIVE\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() IPPROTO_TCP, TCP_KEEPIDLE\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_KEEPCNT\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_KEEPINTVL\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_USER_TIMEOUT\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_send_update_pdu]: fast path update size (2) exceeds the client's maximum request size (0)\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_update]: Fastpath update Synchronize [3] failed, status 0\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_update_data]: fastpath_recv_update() - -1\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_updates]: fastpath_recv_update_data() fail\n[02:02:27:719] [18:00000012] [WARN][com.freerdp.core.rdp] - [rdp_read_security_header][0x519000000080]: invalid security header length, have 0, must be >= 4\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 88 > tpkt header length 0\n[02:02:27:719] [18:00000012] [WARN][com.freerdp.core.rdp] - [Stream_CheckAndLogRequiredLengthWLogExVa][0x519000000080]: [rdp_read_share_control_header(/src/FreeRDP/libfreerdp/core/rdp.c:314)] invalid length, got 169, require at least 16699 [element size=1]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 10: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 11: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 12: unresolvable, address=(nil)\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core.update] - [update_recv_altsec_window_order]: Stream short orderSize\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core.surface] - [update_recv_surfcmds]: unknown cmdType 0x4141\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 65 > tpkt header length 0\n[02:02:27:720] [18:00000012] [WARN][com.winpr.wStream] - [Stream_CheckAndLogRequiredLengthWLogExVa]: [rdp_recv_demand_active(/src/FreeRDP/libfreerdp/core/capabilities.c:4528)] invalid length, got 126, require at least 22616 [element size=1]\n[02:02:27:720] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 10: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 11: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 12: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 13: unresolvable, address=(nil)\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [Stream_CheckAndLogRequiredLengthWLogExVa]: [rdp_recv_confirm_active(/src/FreeRDP/libfreerdp/core/capabilities.c:4660)] invalid length, got 116, require at least 22532 [element size=1]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 10: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 11: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 12: unresolvable, address=(nil)\n[02:02:27:721] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 65 > tpkt header length 0\n=================================================================\n==18==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x519000001d60 at pc 0x55eccdd52d91 bp 0x7ffe05bf4ad0 sp 0x7ffe05bf4ac8\nWRITE of size 8 at 0x519000001d60 thread T0\nSCARINESS: 42 (8-byte-write-heap-buffer-overflow)\n    #0 0x55eccdd52d90 in Stream_Read /src/FreeRDP/winpr/include/winpr/stream.h:703:3\n    #1 0x55eccdd52d90 in gcc_read_client_network_data /src/FreeRDP/libfreerdp/core/gcc.c:1875:3\n    #2 0x55eccdd52d90 in gcc_read_client_data_blocks /src/FreeRDP/libfreerdp/core/gcc.c:617:10\n    #3 0x55eccdd4d00b in gcc_read_conference_create_request /src/FreeRDP/libfreerdp/core/gcc.c:414:7\n    #4 0x55eccdc952ff in mcs_recv_connect_initial /src/FreeRDP/libfreerdp/core/mcs.c:700:7\n    #5 0x55eccda6cefb in freerdp_is_valid_mcs_create_request /src/FreeRDP/libfreerdp/core/freerdp.c:1441:16\n    #6 0x55eccd9f4785 in test_server /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:82:3\n    #7 0x55eccd9f4785 in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:106:2\n    #8 0x55eccd8ab100 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #9 0x55eccd896375 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #10 0x55eccd89be0f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #11 0x55eccd8c70b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #12 0x7fb409d07082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #13 0x55eccd88e55d in _start (/out/TestFuzzCoreServer+0x3d655d)\n\nDEDUP_TOKEN: Stream_Read--gcc_read_client_network_data--gcc_read_client_data_blocks\n0x519000001d60 is located 0 bytes after 992-byte region [0x519000001980,0x519000001d60)\nallocated by thread T0 here:\n    #0 0x55eccd9b7099 in calloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:75:3\n    #1 0x55eccdc9a9b6 in mcs_new /src/FreeRDP/libfreerdp/core/mcs.c:1446:34\n    #2 0x55eccda6cee4 in freerdp_is_valid_mcs_create_request /src/FreeRDP/libfreerdp/core/freerdp.c:1438:16\n    #3 0x55eccd9f4785 in test_server /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:82:3\n    #4 0x55eccd9f4785 in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:106:2\n    #5 0x55eccd8ab100 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #6 0x55eccd896375 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #7 0x55eccd89be0f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #8 0x55eccd8c70b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #9 0x7fb409d07082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n\nDEDUP_TOKEN: __interceptor_calloc--mcs_new--freerdp_is_valid_mcs_create_request\nSUMMARY: AddressSanitizer: heap-buffer-overflow /src/FreeRDP/winpr/include/winpr/stream.h:703:3 in Stream_Read\nShadow bytes around the buggy address:\n  0x519000001a80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001c80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x519000001d00: 00 00 00 00 00 00 00 00 00 00 00 00[fa]fa fa fa\n  0x519000001d80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001e00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001e80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001f00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001f80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/freerdp:/out -v /home/user/aixcc/dataset/tarballs/freerdp_fp-full-01/pov/freerdp_fp-full-01_vuln_004:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TestFuzzCoreServer -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-freerdp", "last_node": "patch_end"}