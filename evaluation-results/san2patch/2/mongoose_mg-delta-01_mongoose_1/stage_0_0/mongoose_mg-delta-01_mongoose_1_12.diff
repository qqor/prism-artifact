diff --git a/src/fmt.c b/src/fmt.c
index 8164e1ca..79876d4a 100644
--- a/src/fmt.c
+++ b/src/fmt.c
@@ -176,21 +176,27 @@ static size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {
     return mg_snprintf(dst, dstlen, "%.*s", n, buf);
   } else {
     int targ_width = width;
-    for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {
+    const int maxlen = (int) sizeof(buf) - 1;
+    for (i = 0, t = mul; t >= 1.0 && s < maxlen; i++) {
       int ch = (int) (d / t);
-      if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');
+      if (n > 0 || ch > 0) {
+        if (s + n < maxlen) buf[s + n++] = (char) (ch + '0');  // bound check
+      }
       d -= ch * t;
       t /= 10.0;
     }
-    // printf(" --> [%g] -> %g %g (%d) [%.*s]\n", saved, d, t, n, s + n, buf);
-    if (n == 0) buf[s++] = '0';
-    while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;
-    if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';
-    // printf(" 1--> [%g] -> [%.*s]\n", saved, s + n, buf);
+    if (n == 0) {
+      if (s < maxlen) buf[s++] = '0';  // bound check
+    }
+    while (t >= 1.0 && s + n < maxlen) {
+      buf[s + n++] = '0';  // bound check
+      t /= 10.0;
+    }
+    if (s + n < maxlen) buf[s + n++] = '.';  // bound check
     if (!tz && n > 0) targ_width = width + n;
-    for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < targ_width; i++) {
+    for (i = 0, t = 0.1; s + n < maxlen && n < targ_width; i++) {
       int ch = (int) (d / t);
-      buf[s + n++] = (char) (ch + '0');
+      buf[s + n++] = (char) (ch + '0');  // bound check
       d -= ch * t;
       t /= 10.0;
     }
@@ -220,7 +226,7 @@ static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {
   // Reverse a string
   for (i = 0; i < n / 2; i++) {
     char t = buf[s + i];
-    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
+buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
   }
   if (val == 0) buf[n++] = '0';  // Handle special case
   return n + s;
@@ -228,8 +234,13 @@ static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {
 
 static size_t scpy(void (*out)(char, void *), void *ptr, char *buf,
                           size_t len) {
-  size_t i = 0;
-  while (i < len && buf[i] != '\0') out(buf[i++], ptr);
+// Rationale: Handle zero-length buffer and copy safely up to len-1 characters
+  if (len == 0) return 0;
+   size_t i = 0;
+  while (i < len - 1 && buf[i] != '\0') {
+    out(buf[i], ptr);
+    i++;
+  }
   return i;
 }
 
@@ -241,7 +252,6 @@ size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {
   va_end(ap);
   return len;
 }
-
 size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
                    va_list *ap) {
   size_t i = 0, n = 0;
