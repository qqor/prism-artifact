diff --git a/src/net_builtin.c b/src/net_builtin.c
index 793874f4..05e396a3 100644
--- a/src/net_builtin.c
+++ b/src/net_builtin.c
@@ -357,6 +357,9 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
               &ifp->mac));
     ether_output(ifp, PDIFF(eth, arp + 1));
   } else if (pkt->arp->op == mg_htons(2)) {
+    /* Pointer-based bounds check before accessing SHA/THA */
+    const uint8_t *arp_end = (const uint8_t *)pkt->arp + sizeof(*pkt->arp);
+    if (arp_end > (const uint8_t *)pkt + pkt->pay.len) return;
     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;
     if (pkt->arp->spa == ifp->gw) {
       // Got response for the GW ARP request. Set ifp->gwmac and IP -> READY
@@ -380,8 +383,10 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
 }
 
 static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
-  // MG_DEBUG(("ICMP %d", (int) len));
-  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {
+  // FIXME: Crash CWE-125: Out-of-bounds Read
+  // Inline guard: type, destination, and sufficient length
+  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip &&
+      ntohs(pkt->ip->len) >= sizeof(struct ip) + sizeof(struct icmp) + pkt->pay.len) {
     size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
     size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;
     if (plen > space) plen = space;
