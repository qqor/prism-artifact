diff --git a/src/net_builtin.c b/src/net_builtin.c
index 793874f4..07a089fe 100644
--- a/src/net_builtin.c
+++ b/src/net_builtin.c
@@ -357,6 +357,10 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
               &ifp->mac));
     ether_output(ifp, PDIFF(eth, arp + 1));
   } else if (pkt->arp->op == mg_htons(2)) {
+    /* Ensure both THA and SHA fields are in bounds */
+    size_t off_tha = offsetof(struct arp, tha) + sizeof(pkt->arp->tha);
+    size_t off_sha = offsetof(struct arp, sha) + sizeof(pkt->arp->sha);
+    if (pkt->pay.len < off_tha || pkt->pay.len < off_sha) return;
     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;
     if (pkt->arp->spa == ifp->gw) {
       // Got response for the GW ARP request. Set ifp->gwmac and IP -> READY
@@ -380,11 +384,24 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
 }
 
 static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
-  // MG_DEBUG(("ICMP %d", (int) len));
+  // FIXME: Crash CWE-125: Out-of-bounds Read
   if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {
-    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
-    size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;
-    if (plen > space) plen = space;
+    u16 total_len = ntohs(pkt->ip->len);
+    const size_t hdrs = sizeof(struct ip) + sizeof(struct icmp);
+    // Skip if packet is too small
+    if (total_len < hdrs) {
+      goto out;
+    }
+    size_t plen = pkt->pay.len;
+    // Clamp to actual IP payload size
+    if (total_len - hdrs < plen) {
+      plen = total_len - hdrs;
+    }
+    size_t hlen = sizeof(struct eth) + hdrs;
+    // Ensure not to exceed transmit buffer
+    if (ifp->tx.len < hlen + plen) {
+      goto out;
+    }
     struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,
                           sizeof(struct icmp) + plen);
     struct icmp *icmp = (struct icmp *) (ip + 1);
@@ -393,6 +410,8 @@ static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
     icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);
     ether_output(ifp, hlen + plen);
   }
+out:
+  ;
 }
 
 static void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {
