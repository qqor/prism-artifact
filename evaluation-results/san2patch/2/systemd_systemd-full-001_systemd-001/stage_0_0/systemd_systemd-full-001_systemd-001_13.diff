diff --git a/src/udev/udev-rules.c b/src/udev/udev-rules.c
index 9f9a970a6c..fe850fefcf 100644
--- a/src/udev/udev-rules.c
+++ b/src/udev/udev-rules.c
@@ -503,7 +503,8 @@ static int rule_line_add_token(UdevRuleLine *rule_line, UdevRuleTokenType type,
         assert(type >= 0 && type < _TK_TYPE_MAX);
         assert(op >= 0 && op < _OP_TYPE_MAX);
 
-        if (type < _TK_M_MAX) {
+        /* Rationale: Remove the redundant second write beyond the buffer end; a single '\0' at *b is sufficient to terminate the string safely. */
+if (type < _TK_M_MAX) {
                 assert(value);
                 assert(IN_SET(op, OP_MATCH, OP_NOMATCH));
 
@@ -514,7 +515,7 @@ static int rule_line_add_token(UdevRuleLine *rule_line, UdevRuleTokenType type,
                 else if (streq(value, "?*")) {
                         /* Convert KEY=="?*" -> KEY!="" */
                         match_type = MATCH_TYPE_EMPTY;
-                        op = op == OP_MATCH ? OP_NOMATCH : OP_MATCH;
+                         op = op == OP_MATCH ? OP_NOMATCH : OP_MATCH;
                 } else if (string_is_glob(value))
                         match_type = MATCH_TYPE_GLOB;
                 else
@@ -537,12 +538,9 @@ static int rule_line_add_token(UdevRuleLine *rule_line, UdevRuleTokenType type,
                                         bar = true;
                                 }
                         }
+                        /* Single null-terminator only */
                         *b = '\0';
 
-                        /* Make sure the value is end, so NULSTR_FOREACH can read correct match */
-                        if (b < a)
-                                b[1] = '\0';
-
                         if (bar)
                                 empty = true;
 
