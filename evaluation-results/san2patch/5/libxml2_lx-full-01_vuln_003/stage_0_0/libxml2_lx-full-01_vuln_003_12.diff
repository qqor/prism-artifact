diff --git a/SAX2.c b/SAX2.c
index 21a6b4e0..3dd54b6a 100644
--- a/SAX2.c
+++ b/SAX2.c
@@ -533,6 +533,14 @@ xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
     if ((ctxt == NULL) || (ctxt->myDoc == NULL))
         return;
 
+    /* Rationale: Early drop of overly large content to prevent
+     * buffer overflow in xmlSBufAddEntitySecure
+     */
+    if (xmlStrlen(content) > 4096) {
+        /* Silently ignore too-large entities for security */
+        return;
+    }
+
     extSubset = ctxt->inSubset == 2;
     res = xmlAddEntity(ctxt->myDoc, extSubset, name, type, publicId, systemId,
                        content, &ent);
@@ -553,10 +561,6 @@ xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
             }
             return;
         case XML_ERR_REDECL_PREDEF_ENTITY:
-            /*
-             * Technically an error but it's a common mistake to get double
-             * escaping according to "4.6 Predefined Entities" wrong.
-             */
             xmlWarnMsg(ctxt, res, "Invalid redeclaration of predefined"
                        " entity '%s'", name);
             return;
@@ -579,10 +583,6 @@ xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
             }
         }
 
-        /*
-         * We don't really need the 'directory' struct member, but some
-         * users set it manually to a base URI for memory streams.
-         */
         if (base == NULL)
             base = ctxt->directory;
 
diff --git a/entities.c b/entities.c
index a5c814c3..addc252d 100644
--- a/entities.c
+++ b/entities.c
@@ -150,16 +150,20 @@ xmlCreateEntity(xmlDocPtr doc, const xmlChar *name, int type,
             goto error;
     }
     if (content != NULL) {
-        ret->length = xmlStrlen(content);
-	ret->content = xmlStrndup(content, ret->length);
-        if (ret->content == NULL)
-            goto error;
+        /* Rationale: manual allocation and copy with limit */
+        size_t content_len = xmlStrlen(content);
+        if (content_len > ENTITY_MAX_LEN) goto error;
+        ret->length = content_len;
+        ret->content = (xmlChar *) xmlMalloc(ret->length + 1);
+        if (ret->content == NULL) goto error;
+        memcpy(ret->content, content, ret->length);
+        ret->content[ret->length] = '\0';
      } else {
         ret->length = 0;
         ret->content = NULL;
     }
     ret->URI = NULL; /* to be computed by the layer knowing
-			the defining entity */
+					the defining entity */
     ret->orig = NULL;
 
     return(ret);
