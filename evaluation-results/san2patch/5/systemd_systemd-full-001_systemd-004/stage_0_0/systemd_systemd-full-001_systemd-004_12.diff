diff --git a/src/shared/condition.c b/src/shared/condition.c
index 67894f9319..bd50900c41 100644
--- a/src/shared/condition.c
+++ b/src/shared/condition.c
@@ -373,36 +373,48 @@ static int condition_test_user(Condition *c, char **env) {
 }
 
 static int condition_test_control_group_controller(Condition *c, char **env) {
-        int r;
-        CGroupMask system_mask, wanted_mask = 0;
-
-        assert(c);
-        assert(c->parameter);
-        assert(c->type == CONDITION_CONTROL_GROUP_CONTROLLER);
-
-        if (streq(c->parameter, "v2"))
-                return cg_all_unified();
-        if (streq(c->parameter, "v1")) {
-                r = cg_all_unified();
-                if (r < 0)
-                        return r;
-                return !r;
-        }
-
-        r = cg_mask_supported(&system_mask);
-        if (r < 0)
-                return log_debug_errno(r, "Failed to determine supported controllers: %m");
-
-        r = cg_mask_from_string(c->parameter, &wanted_mask);
-        if (r < 0 || wanted_mask <= 0) {
-                /* This won't catch the case that we have an unknown controller
-                 * mixed in with valid ones -- these are only assessed on the
-                 * validity of the valid controllers found. */
-                log_debug("Failed to parse cgroup string: %s", c->parameter);
-                return 1;
-        }
-
-        return FLAGS_SET(system_mask, wanted_mask);
+	int r, ret = 0;
+	CGroupMask system_mask, wanted_mask = 0;
+	assert(c);
+	assert(c->parameter);
+	assert(c->type == CONDITION_CONTROL_GROUP_CONTROLLER);
+
+	/* Centralized cleanup via goto */
+	char *param_copy = strdup(c->parameter);
+	if (!param_copy)
+		return -ENOMEM;
+
+	if (streq(param_copy, "v2")) {
+		ret = cg_all_unified();
+		goto out;
+	} else if (streq(param_copy, "v1")) {
+		r = cg_all_unified();
+		if (r < 0) {
+			ret = r;
+			goto out;
+		}
+		ret = !r;
+		goto out;
+	}
+
+	r = cg_mask_supported(&system_mask);
+	if (r < 0) {
+		ret = log_debug_errno(r, "Failed to determine supported controllers: %m");
+		goto out;
+	}
+
+	r = cg_mask_from_string(param_copy, &wanted_mask);
+	if (r < 0 || wanted_mask <= 0) {
+		log_debug("Failed to parse cgroup string: %s", param_copy);
+		ret = 1;
+		goto out;
+	}
+
+	ret = FLAGS_SET(system_mask, wanted_mask);
+
+out:
+	free(param_copy);
+	return ret;
 }
 
 static int condition_test_group(Condition *c, char **env) {
