diff --git a/src/shared/condition.c b/src/shared/condition.c
index 67894f9319..6e114fd283 100644
--- a/src/shared/condition.c
+++ b/src/shared/condition.c
@@ -180,61 +180,24 @@ static int condition_test_credential(Condition *c, char **env) {
         return false;
 }
 
-static int condition_test_kernel_version(Condition *c, char **env) {
-        CompareOperator operator;
-        struct utsname u;
-        bool first = true;
-
-        assert(c);
-        assert(c->parameter);
-        assert(c->type == CONDITION_KERNEL_VERSION);
-
-        assert_se(uname(&u) >= 0);
-
-        for (const char *p = c->parameter;;) {
-                _cleanup_free_ char *word = NULL;
-                const char *s;
-                int r;
-
-                r = extract_first_word(&p, &word, NULL, EXTRACT_UNQUOTE);
-                if (r < 0)
-                        return log_debug_errno(r, "Failed to parse condition string \"%s\": %m", p);
-                if (r == 0)
-                        break;
-
-                s = strstrip(word);
-                operator = parse_compare_operator(&s, COMPARE_ALLOW_FNMATCH|COMPARE_EQUAL_BY_STRING);
-                if (operator < 0) /* No prefix? Then treat as glob string */
-                        operator = COMPARE_FNMATCH_EQUAL;
-
-                s += strspn(s, WHITESPACE);
-                if (isempty(s)) {
-                        if (first) {
-                                /* For backwards compatibility, allow whitespace between the operator and
-                                 * value, without quoting, but only in the first expression. */
-                                word = mfree(word);
-                                r = extract_first_word(&p, &word, NULL, 0);
-                                if (r < 0)
-                                        return log_debug_errno(r, "Failed to parse condition string \"%s\": %m", p);
-                                if (r == 0)
-                                        return log_debug_errno(SYNTHETIC_ERRNO(EINVAL), "Unexpected end of expression: %s", p);
-                                s = word;
-                        } else
-                                return log_debug_errno(SYNTHETIC_ERRNO(EINVAL), "Unexpected end of expression: %s", p);
-                }
-
-                r = version_or_fnmatch_compare(operator, u.release, s);
-                if (r < 0)
-                        return r;
-                if (!r)
-                        return false;
-
-                first = false;
-        }
-
-        return true;
+static void condition_free_list_type(ConditionList *list) {
+	struct condition *n;
+	/* Use do/while for one-pass list free */
+	if (!list->head) {
+		return;
+	}
+	n = list->head;
+
+do {
+	struct condition *next = n->next;
+	condition_free(n);
+	n = next;
+} while (n);
+	list->head = list->tail = NULL;
 }
 
+/* Rationale: The do/while form still captures next before freeing, and handles empty lists early. */
+
 static int condition_test_osrelease(Condition *c, char **env) {
         int r;
 
