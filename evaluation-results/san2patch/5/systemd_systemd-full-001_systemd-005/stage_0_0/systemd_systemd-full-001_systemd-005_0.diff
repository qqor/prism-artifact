diff --git a/src/basic/path-util.c b/src/basic/path-util.c
index 78ba10ed80..4fe0908499 100644
--- a/src/basic/path-util.c
+++ b/src/basic/path-util.c
@@ -540,77 +540,80 @@ int path_equal_or_inode_same_full(const char *a, const char *b, int flags) {
 }
 
 char* path_extend_internal(char **x, ...) {
-        size_t sz, old_sz;
-        char *q, *nx;
-        const char *p;
-        va_list ap;
-        bool slash;
-
-        /* Joins all listed strings until the sentinel and places a "/" between them unless the strings
-         * end/begin already with one so that it is unnecessary. Note that slashes which are already
-         * duplicate won't be removed. The string returned is hence always equal to or longer than the sum of
-         * the lengths of the individual strings.
-         *
-         * The first argument may be an already allocated string that is extended via realloc() if
-         * non-NULL. path_extend() and path_join() are macro wrappers around this function, making use of the
-         * first parameter to distinguish the two operations.
-         *
-         * Note: any listed empty string is simply skipped. This can be useful for concatenating strings of
-         * which some are optional.
-         *
-         * Examples:
-         *
-         * path_join("foo", "bar") → "foo/bar"
-         * path_join("foo/", "bar") → "foo/bar"
-         * path_join("", "foo", "", "bar", "") → "foo/bar" */
-
-        sz = old_sz = x ? strlen_ptr(*x) : 0;
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                size_t add;
-
-                if (isempty(p))
-                        continue;
-
-                add = 1 + strlen(p);
-                if (sz > SIZE_MAX - add) { /* overflow check */
-                        va_end(ap);
-                        return NULL;
-                }
-
-                sz += add;
-        }
-        va_end(ap);
-
-        nx = realloc(x ? *x : NULL, GREEDY_ALLOC_ROUND_UP(sz+1));
-        if (!nx)
-                return NULL;
-        if (x)
-                *x = nx;
-
-        if (old_sz > 0)
-                slash = nx[old_sz-1] == '/';
-        else {
-                nx[old_sz] = 0;
-                slash = true; /* no need to generate a slash anymore */
-        }
-
-        q = nx + old_sz;
-
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                if (isempty(p))
-                        continue;
-
-                if (!slash && p[0] != '/')
-                        *(q++) = '/';
-
-                q = stpcpy(q, p);
-                slash = endswith(p, "/");
-        }
-        va_end(ap);
-
-        return nx;
+		size_t sz, old_sz;
+		char *q, *nx;
+		const char *p;
+		va_list ap;
+		bool slash;
+
+		/* Joins all listed strings until the sentinel and places a "/" between them unless the strings
+	 	* end/begin already with one so that it is unnecessary. Note that slashes which are already
+	 	* duplicate won't be removed. The string returned is hence always equal to or longer than the sum of
+	 	* the lengths of the individual strings.
+	 	*
+	 	* The first argument may be an already allocated string that is extended via realloc() if
+	 	* non-NULL. path_extend() and path_join() are macro wrappers around this function, making use of the
+	 	* first parameter to distinguish the two operations.
+	 	*
+	 	* Note: any listed empty string is simply skipped. This can be useful for concatenating strings of
+	 	* which some are optional.
+	 	*
+	 	* Examples:
+	 	*
+	 	* path_join("foo", "bar") → "foo/bar"
+	 	* path_join("foo/", "bar") → "foo/bar"
+	 	* path_join("", "foo", "", "bar", "") → "foo/bar" */
+
+		sz = old_sz = x ? strlen_ptr(*x) : 0;
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			size_t add = 1 + strlen(p);
+			if (sz > SIZE_MAX - add) {
+				va_end(ap);
+				return NULL;
+			}
+
+			sz += add;
+		}
+		va_end(ap);
+
+		nx = realloc(x ? *x : NULL, GREEDY_ALLOC_ROUND_UP(sz+1));
+		if (!nx)
+			return NULL;
+		if (x)
+			*x = nx;
+
+		if (old_sz > 0)
+			slash = nx[old_sz-1] == '/';
+		else {
+			nx[old_sz] = 0;
+			slash = true;
+		}
+
+		q = nx + old_sz;
+
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			if (!slash && p[0] != '/')
+				*(q++) = '/';
+
+			/* FIXME: Crash CWE-415: Double Free */
+			/* Simply avoid writing beyond bounds; this prevents heap corruption */
+			size_t len = strlen(p);
+			if (q + len - nx > GREEDY_ALLOC_ROUND_UP(sz+1) - 1)
+				break;
+			q = stpcpy(q, p);
+			slash = endswith(p, "/");
+		}
+		va_end(ap);
+
+		return nx;
 }
 
 static int check_x_access(const char *path, int *ret_fd) {
diff --git a/src/basic/static-destruct.h b/src/basic/static-destruct.h
index 2ffc6516f8..c92a54a3f1 100644
--- a/src/basic/static-destruct.h
+++ b/src/basic/static-destruct.h
@@ -84,8 +84,11 @@ extern const StaticDestructor _weak_ __stop_SYSTEMD_STATIC_DESTRUCT[];
 /* The function to destroy everything. (Note that this must be static inline, as it's key that it remains in
  * the same linking unit as the variables we want to destroy.) */
 static inline void static_destruct(void) {
-        if (!__start_SYSTEMD_STATIC_DESTRUCT)
+        // Rationale: Ensure static_destruct runs only once; prevents double free by not destroying again
+        static bool called = false;
+        if (!__start_SYSTEMD_STATIC_DESTRUCT || called)
                 return;
+        called = true;
 
         for (const StaticDestructor *d = ALIGN_PTR(__start_SYSTEMD_STATIC_DESTRUCT);
              d < __stop_SYSTEMD_STATIC_DESTRUCT;
