diff --git a/src/basic/path-util.c b/src/basic/path-util.c
index 78ba10ed80..76d55e5ded 100644
--- a/src/basic/path-util.c
+++ b/src/basic/path-util.c
@@ -540,77 +540,68 @@ int path_equal_or_inode_same_full(const char *a, const char *b, int flags) {
 }
 
 char* path_extend_internal(char **x, ...) {
-        size_t sz, old_sz;
-        char *q, *nx;
-        const char *p;
-        va_list ap;
-        bool slash;
-
-        /* Joins all listed strings until the sentinel and places a "/" between them unless the strings
-         * end/begin already with one so that it is unnecessary. Note that slashes which are already
-         * duplicate won't be removed. The string returned is hence always equal to or longer than the sum of
-         * the lengths of the individual strings.
-         *
-         * The first argument may be an already allocated string that is extended via realloc() if
-         * non-NULL. path_extend() and path_join() are macro wrappers around this function, making use of the
-         * first parameter to distinguish the two operations.
-         *
-         * Note: any listed empty string is simply skipped. This can be useful for concatenating strings of
-         * which some are optional.
-         *
-         * Examples:
-         *
-         * path_join("foo", "bar") → "foo/bar"
-         * path_join("foo/", "bar") → "foo/bar"
-         * path_join("", "foo", "", "bar", "") → "foo/bar" */
-
-        sz = old_sz = x ? strlen_ptr(*x) : 0;
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                size_t add;
-
-                if (isempty(p))
-                        continue;
-
-                add = 1 + strlen(p);
-                if (sz > SIZE_MAX - add) { /* overflow check */
-                        va_end(ap);
-                        return NULL;
-                }
-
-                sz += add;
-        }
-        va_end(ap);
-
-        nx = realloc(x ? *x : NULL, GREEDY_ALLOC_ROUND_UP(sz+1));
-        if (!nx)
-                return NULL;
-        if (x)
-                *x = nx;
-
-        if (old_sz > 0)
-                slash = nx[old_sz-1] == '/';
-        else {
-                nx[old_sz] = 0;
-                slash = true; /* no need to generate a slash anymore */
-        }
-
-        q = nx + old_sz;
-
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                if (isempty(p))
-                        continue;
-
-                if (!slash && p[0] != '/')
-                        *(q++) = '/';
-
-                q = stpcpy(q, p);
-                slash = endswith(p, "/");
-        }
-        va_end(ap);
-
-        return nx;
+		/* Use a one-shot free macro to avoid accidentally freeing twice */
+		#define FREE_ONCE(ptr) do { static bool _f_##ptr = false; if ((ptr) && !_f_##ptr) { free(ptr); _f_##ptr = true; } } while (0)
+
+		size_t sz, old_sz;
+		char *q, *nx;
+		const char *p;
+		va_list ap;
+		bool slash;
+
+		sz = old_sz = x ? strlen_ptr(*x) : 0;
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			size_t add = 1 + strlen(p);
+			if (sz > SIZE_MAX - add) {
+				va_end(ap);
+				#undef FREE_ONCE
+				return NULL;
+			}
+
+			sz += add;
+		}
+		va_end(ap);
+
+		/* Always allocate anew and free old buffer only once */
+		nx = malloc(GREEDY_ALLOC_ROUND_UP(sz+1));
+		if (!nx) {
+			#undef FREE_ONCE
+			return NULL;
+		}
+		if (x) {
+			FREE_ONCE(*x);
+			*x = nx;
+		}
+
+		if (old_sz > 0)
+			slash = nx[old_sz-1] == '/';
+		else {
+			nx[old_sz] = 0;
+			slash = true;
+		}
+
+		q = nx + old_sz;
+
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			if (!slash && p[0] != '/')
+				*(q++) = '/';
+
+			/* FIXME: Crash CWE-415: Double Free */
+			q = stpcpy(q, p);
+			slash = endswith(p, "/");
+		}
+		va_end(ap);
+
+		#undef FREE_ONCE
+		return nx;
 }
 
 static int check_x_access(const char *path, int *ret_fd) {
diff --git a/src/basic/static-destruct.h b/src/basic/static-destruct.h
index 2ffc6516f8..d9a135f0ac 100644
--- a/src/basic/static-destruct.h
+++ b/src/basic/static-destruct.h
@@ -84,6 +84,12 @@ extern const StaticDestructor _weak_ __stop_SYSTEMD_STATIC_DESTRUCT[];
 /* The function to destroy everything. (Note that this must be static inline, as it's key that it remains in
  * the same linking unit as the variables we want to destroy.) */
 static inline void static_destruct(void) {
+#define SAFE_DESTROY(fn, data) do { \
+        if ((data)) { \
+                fn(data); \
+        } \
+} while (0)
+        // Rationale: Use safe destroy macro to check data before calling
         if (!__start_SYSTEMD_STATIC_DESTRUCT)
                 return;
 
@@ -92,7 +98,7 @@ static inline void static_destruct(void) {
              d = ALIGN_PTR(d + 1))
                 switch (d->type) {
                 case STATIC_DESTRUCTOR_SIMPLE:
-                        d->simple.destroy(d->simple.data);
+                        SAFE_DESTROY(d->simple.destroy, d->simple.data);
                         break;
 
                 case STATIC_DESTRUCTOR_ARRAY:
@@ -102,4 +108,6 @@ static inline void static_destruct(void) {
                 default:
                         assert_not_reached();
                 }
+
+#undef SAFE_DESTROY
 }
