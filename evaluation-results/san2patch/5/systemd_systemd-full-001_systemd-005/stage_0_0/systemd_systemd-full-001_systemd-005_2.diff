diff --git a/src/basic/path-util.c b/src/basic/path-util.c
index 78ba10ed80..bac5323e99 100644
--- a/src/basic/path-util.c
+++ b/src/basic/path-util.c
@@ -540,77 +540,67 @@ int path_equal_or_inode_same_full(const char *a, const char *b, int flags) {
 }
 
 char* path_extend_internal(char **x, ...) {
-        size_t sz, old_sz;
-        char *q, *nx;
-        const char *p;
-        va_list ap;
-        bool slash;
-
-        /* Joins all listed strings until the sentinel and places a "/" between them unless the strings
-         * end/begin already with one so that it is unnecessary. Note that slashes which are already
-         * duplicate won't be removed. The string returned is hence always equal to or longer than the sum of
-         * the lengths of the individual strings.
-         *
-         * The first argument may be an already allocated string that is extended via realloc() if
-         * non-NULL. path_extend() and path_join() are macro wrappers around this function, making use of the
-         * first parameter to distinguish the two operations.
-         *
-         * Note: any listed empty string is simply skipped. This can be useful for concatenating strings of
-         * which some are optional.
-         *
-         * Examples:
-         *
-         * path_join("foo", "bar") → "foo/bar"
-         * path_join("foo/", "bar") → "foo/bar"
-         * path_join("", "foo", "", "bar", "") → "foo/bar" */
-
-        sz = old_sz = x ? strlen_ptr(*x) : 0;
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                size_t add;
-
-                if (isempty(p))
-                        continue;
-
-                add = 1 + strlen(p);
-                if (sz > SIZE_MAX - add) { /* overflow check */
-                        va_end(ap);
-                        return NULL;
-                }
-
-                sz += add;
-        }
-        va_end(ap);
-
-        nx = realloc(x ? *x : NULL, GREEDY_ALLOC_ROUND_UP(sz+1));
-        if (!nx)
-                return NULL;
-        if (x)
-                *x = nx;
-
-        if (old_sz > 0)
-                slash = nx[old_sz-1] == '/';
-        else {
-                nx[old_sz] = 0;
-                slash = true; /* no need to generate a slash anymore */
-        }
-
-        q = nx + old_sz;
-
-        va_start(ap, x);
-        while ((p = va_arg(ap, char*)) != POINTER_MAX) {
-                if (isempty(p))
-                        continue;
-
-                if (!slash && p[0] != '/')
-                        *(q++) = '/';
-
-                q = stpcpy(q, p);
-                slash = endswith(p, "/");
-        }
-        va_end(ap);
-
-        return nx;
+		static _Atomic bool in_use = false;
+		if (in_use)
+			return NULL; /* prevent re-entry that could lead to double-free */
+		in_use = true;
+
+		size_t sz, old_sz;
+		char *q, *nx;
+		const char *p;
+		va_list ap;
+		bool slash;
+
+		sz = old_sz = x ? strlen_ptr(*x) : 0;
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			size_t add = 1 + strlen(p);
+			if (sz > SIZE_MAX - add) {
+				va_end(ap);
+				in_use = false;
+				return NULL;
+			}
+
+			sz += add;
+		}
+		va_end(ap);
+
+		nx = realloc(x ? *x : NULL, GREEDY_ALLOC_ROUND_UP(sz+1));
+		if (!nx) {
+			in_use = false;
+			return NULL;
+		}
+		if (x)
+			*x = nx;
+
+		if (old_sz > 0)
+			slash = nx[old_sz-1] == '/';
+		else {
+			nx[old_sz] = 0;
+			slash = true;
+		}
+
+		q = nx + old_sz;
+
+		va_start(ap, x);
+		while ((p = va_arg(ap, char*)) != POINTER_MAX) {
+			if (isempty(p))
+				continue;
+
+			if (!slash && p[0] != '/')
+				*(q++) = '/';
+
+			/* FIXME: Crash CWE-415: Double Free */
+			q = stpcpy(q, p);
+			slash = endswith(p, "/");
+		}
+		va_end(ap);
+
+		in_use = false;
+		return nx;
 }
 
 static int check_x_access(const char *path, int *ret_fd) {
diff --git a/src/basic/static-destruct.h b/src/basic/static-destruct.h
index 2ffc6516f8..24338a6981 100644
--- a/src/basic/static-destruct.h
+++ b/src/basic/static-destruct.h
@@ -84,6 +84,7 @@ extern const StaticDestructor _weak_ __stop_SYSTEMD_STATIC_DESTRUCT[];
 /* The function to destroy everything. (Note that this must be static inline, as it's key that it remains in
  * the same linking unit as the variables we want to destroy.) */
 static inline void static_destruct(void) {
+        // Rationale: Clear destructor entries after running to avoid subsequent frees
         if (!__start_SYSTEMD_STATIC_DESTRUCT)
                 return;
 
@@ -102,4 +103,9 @@ static inline void static_destruct(void) {
                 default:
                         assert_not_reached();
                 }
+
+        // Prevent double free by zeroing destructors list
+        memset((void *)__start_SYSTEMD_STATIC_DESTRUCT, 0,
+               (__stop_SYSTEMD_STATIC_DESTRUCT -
+                __start_SYSTEMD_STATIC_DESTRUCT) * sizeof(StaticDestructor));
 }
