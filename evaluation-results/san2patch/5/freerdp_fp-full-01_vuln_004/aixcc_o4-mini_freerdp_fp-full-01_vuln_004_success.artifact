{"vuln_data": {"id": "freerdp_fp-full-01_vuln_004", "subject": "freerdp", "work_name": "freerdp", "project_name": "freerdp", "hiding_project_name": "", "project_full_name": "freerdp", "harness_name": "TestFuzzCoreServer", "branch_name": "fp-full-01", "project_repo_name": "official-afc-freerdp"}, "data_type": "oss-fuzz", "patch_success": ["build_failed", "build_failed", "build_failed", "build_failed", "success"], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "patched_code": "--- a/libfreerdp/core/gcc.c\n+++ b/libfreerdp/core/gcc.c\n@@\n /*\n  * Before using MAX_BLOCK_SIZE ensure it is defined.\n  */\n+#ifndef MAX_BLOCK_SIZE\n+#define MAX_BLOCK_SIZE (1024 * 1024) /* 1 MB maximum block size */\n+#endif\n@@ switch (type)\n \t\tcase CS_NET:\n \t\t{\n-\t\t\tUINT32 size = Stream_GetRemainingLength(sub);\n-\t\t\tif (size > MAX_BLOCK_SIZE)\n-\t\t\t{\n-\t\t\t\tWLog_ERR(TAG, \"Client network data block size %u exceeds policy limit %u\", size, MAX_BLOCK_SIZE);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\n-\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n-\t\t\t\treturn FALSE;\n+\t\t\tUINT32 size = Stream_GetRemainingLength(sub);\n+\t\t\t/* Reject overly large blocks to prevent out-of-bounds writes */\n+\t\t\tif (size > MAX_BLOCK_SIZE)\n+\t\t\t{\n+\t\t\t\tWLog_ERR(TAG, \"Client network data block size %u exceeds policy limit %u\",\n+\t\t\t\t         size, MAX_BLOCK_SIZE);\n+\t\t\t\treturn FALSE;\n+\t\t\t}\n+\n+\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n+\t\t\t\treturn FALSE;\n \t\t}\n \n \t\t\tbreak;", "func_def": "BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "patched_code": "--- a/libfreerdp/core/gcc.c\n+++ b/libfreerdp/core/gcc.c\n@@ -617,14 +617,17 @@ BOOL freeRDP_gcc_read_client_data(wStream* s,\n         case CS_NET:\n         {\n-            UINT32 size = Stream_GetRemainingLength(sub);\n-            if (size > MAX_BLOCK_SIZE)\n-            {\n-                WLog_WARN(TAG, \"Dropping oversized network data block: %u bytes > %u limit\", size, MAX_BLOCK_SIZE);\n-                Stream_Seek(sub, size);\n-                break;\n-            }\n+            UINT32 size = Stream_GetRemainingLength(sub);\n+            /* Limit network data block to prevent excessive or out-of-bounds reads */\n+            const UINT32 MAX_NET_BLOCK = 65535;\n+            if (size > MAX_NET_BLOCK)\n+            {\n+                WLog_WARN(TAG, \"Dropping oversized network data block: %u bytes > %u limit\", size, MAX_NET_BLOCK);\n+                Stream_Seek(sub, size);\n+                break;\n+            }\n\n             if (!gcc_read_client_network_data(sub, mcs))\n                 return FALSE;\n         }", "func_def": "BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "patched_code": "/* Prevent build errors: define maximum safe block size */", "func_def": "BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "patched_code": "--- a/libfreerdp/core/gcc.c\n+++ b/libfreerdp/core/gcc.c\n@@\n+/* Prevent undefined MAX_BLOCK_SIZE compile error */\n+#ifndef MAX_BLOCK_SIZE\n+#define MAX_BLOCK_SIZE (1024 * 1024)  /* 1 MiB safe upper bound */\n+#endif\n \n     switch (type)\n@@\n         case CS_NET:\n-        {\n-           UINT32 startPos = Stream_GetPosition(sub);\n-           UINT32 size = Stream_GetRemainingLength(sub);\n-           if (size > MAX_BLOCK_SIZE)\n-           {\n-               WLog_ERR(TAG, \"Network data block %u@%u exceeds limit %u\", size, startPos, MAX_BLOCK_SIZE);\n-               return FALSE;\n-           }\n-\n-           if (!gcc_read_client_network_data(sub, mcs))\n-               return FALSE;\n-        }\n+        {\n+            UINT32 startPos = Stream_GetPosition(sub);\n+            UINT32 size = Stream_GetRemainingLength(sub);\n+            if (size > MAX_BLOCK_SIZE)\n+            {\n+                WLog_ERR(TAG, \"Network data block %u@%u exceeds limit %u\", size, startPos, MAX_BLOCK_SIZE);\n+                return FALSE;\n+            }\n+            if (!gcc_read_client_network_data(sub, mcs))\n+                return FALSE;\n+        }\n", "func_def": "BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "patched_code": "switch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n\n\t\t\tcase CS_NET:\n\t\t\t\t/* Network data disabled to prevent buffer overflow */\n\t\t\t\tWLog_ERR(TAG, \"Client network data blocks are disabled for safety.\");\n\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_UNUSED1:\n\t\t\t\tif (!gcc_read_client_unused1_data(sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tgotMultitransport = TRUE;\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\twinpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));\n\t\t\t\tbreak;\n\t\t}", "func_def": "BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)", "func_ret": ["return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, "patch_result": "success"}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}, "guideline": "Enforce explicit bounds checks on every read into a fixed-size buffer.", "description": "Inside gcc_read_client_data_blocks, change calls to Stream_Read(s, buffer + offset, blockLength) to first verify blockLength <= (totalBufferSize - offset). If the check fails, log an error and abort. This ensures even per-block reads cannot overflow the buffer.", "rationale": "Per-block bounds checks guarantee that even valid overall lengths cannot be subdivided in a way that overruns the buffer, closing any secondary overflow paths.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly targets the identified overflow by enforcing per-block bounds checks against the fixed buffer size, which aligns well with the described heap-based out-of-bounds write (CWE-787). It plausibly integrates into gcc_read_client_data_blocks and prevents subdivided reads from overrunning the buffer. The strategy is neither overly vague nor unrealistically specific given the known code context, earning a high score. A more detailed code snippet could push it to perfect, but the guidance is solid and applicable."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, "guideline": "Perform explicit bounds checking on untrusted length parameters before any memory copy operations to prevent out-of-bounds writes (CWE-119, CWE-787).", "description": "In winpr/include/winpr/stream.h, modify Stream_Read to check _n against the stream\u2019s remaining capacity and return an error or abort if _n exceeds the capacity, instead of relying solely on assertions. Example patch:\n```c\nstatic INLINE BOOL Stream_Read(wStream* _s, void* _b, size_t _n)\n{\n    WINPR_ASSERT(_s);\n    WINPR_ASSERT(_b || (_n == 0));\n    size_t remaining = Stream_GetRemainingCapacity(_s);\n    if (_n > remaining)\n    {\n        /* prevent OOB: requested length exceed stream buffer */\n        WLog_ERR(TAG, \"Stream_Read: request %zu bytes exceeds remaining %zu bytes\", _n, remaining);\n        return FALSE; /* or handle error appropriately */\n    }\n    memcpy(_b, _s->pointer, _n);\n    Stream_Seek(_s, _n);\n    return TRUE;\n}\n```", "rationale": "Adding an explicit runtime check in Stream_Read guarantees that untrusted _n cannot exceed the stream\u2019s buffer capacity, preventing heap corruption even if assertions are disabled in production builds.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy directly addresses the root cause by adding an explicit runtime bounds check before the memcpy, which prevents the OOB write even when assertions are disabled. It matches the CWE guidelines and applies at the correct location in Stream_Read. The use of logging and a boolean return makes it safer in production. The only minor gap is that the change of Stream_Read\u2019s signature to return BOOL requires updating all callers to handle the error, which wasn\u2019t discussed. Overall, it\u2019s a solid, plausible fix aligned with the vulnerability details."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Validate all untrusted length parameters against the actual buffer capacity before performing any memory read or write operations.", "description": "In gcc_read_client_data_blocks(), immediately after extracting the length field from the network stream, insert:\n\n    if (length > BLOCK_BUFFER_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds maximum %u\", length, BLOCK_BUFFER_SIZE);\n        return FALSE;\n    }\n\nbefore any call to Stream_Read, so that no read can exceed the 992-byte buffer.", "rationale": "Rejecting oversized lengths immediately prevents any out-of-bounds access on the fixed-size buffer, eliminating the heap corruption vector (CWE-787).", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the root cause (missing bounds check on untrusted length) by validating the length against the fixed buffer size before calling Stream_Read. It pinpoints the correct function (gcc_read_client_data_blocks) and insertion point (after length extraction), matching the vulnerability description. The fix is practical, minimal, and unlikely to break other functionality. It isn\u2019t overly general or hallucinated and avoids unrealistic detail. Hence, it merits a high score."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Use explicit upper\u2010bound checks (per SEI CERT MEM05-C) or safe helper functions that enforce a maximum length, rejecting or clamping unexpected values.", "description": "Alternatively, clamp the read size to the buffer capacity:\n\n    size_t n = (length > BLOCK_BUFFER_SIZE) ? BLOCK_BUFFER_SIZE : length;\n    Stream_Read(stream, dataBlocks, n);\n    if (n < length) {\n        WLog_WARN(TAG, \"Truncated client data block from %u to %zu bytes\", length, n);\n    }\n\nso that excess bytes are dropped rather than overflowing.", "rationale": "Clamping the read ensures that even if a malicious length is provided, the system only processes up to the safe maximum, preserving service availability while avoiding overflow.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the out-of-bounds write by adding an explicit upper\u2010bound check and clamping the requested read size to the buffer capacity, which aligns perfectly with the identified root cause. It follows recommended SEI CERT MEM05-C practices and includes a warning log for truncated packets, preserving availability and aiding debugging. The advice is neither too generic nor unrealistically specific, making it a plausible and appropriate fix for the given location."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, "guideline": "Where variable\u2010length data is expected, dynamically allocate or resize the buffer to the validated length, or refuse requests that exceed a defined policy limit.", "description": "For a more flexible approach, validate length against a global policy limit (e.g. MAX_BLOCK_SIZE), then realloc the buffer to 'length' bytes when safe:\n\n    if (length > MAX_BLOCK_SIZE) {\n        WLog_ERR(TAG, \"Client data block size %u exceeds policy limit %u\", length, MAX_BLOCK_SIZE);\n        return FALSE;\n    }\n    dataBlocks = realloc(dataBlocks, length);\n    if (!dataBlocks) return FALSE;\n    Stream_Read(stream, dataBlocks, length);\n", "rationale": "Dynamically resizing the buffer to a validated length allows legitimate large blocks to be handled safely and rejects only truly excessive requests, balancing security and functionality.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the missing bounds check and addresses it by validating the untrusted length against a policy limit before reading data. Dynamically reallocating (or initially allocating) the buffer to the exact validated size directly mitigates the CWE-787 overflow without impacting legitimate use cases. The approach is neither overly general nor unrealistically specific and fits naturally at the indicated code location. The only minor detail is mapping the generic realloc call back to the project\u2019s memory allocator (mcs_new/mcs_realloc), but conceptually the fix is sound and applicable."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, "guideline": "Perform explicit bounds checking on untrusted length parameters before any memory copy operations to prevent out-of-bounds writes (CWE-119, CWE-787).", "description": "In winpr/include/winpr/stream.h, modify Stream_Read to check _n against the stream\u2019s remaining capacity and return an error or abort if _n exceeds the capacity, instead of relying solely on assertions. Example patch:\n```c\nstatic INLINE BOOL Stream_Read(wStream* _s, void* _b, size_t _n)\n{\n    WINPR_ASSERT(_s);\n    WINPR_ASSERT(_b || (_n == 0));\n    size_t remaining = Stream_GetRemainingCapacity(_s);\n    if (_n > remaining)\n    {\n        /* prevent OOB: requested length exceed stream buffer */\n        WLog_ERR(TAG, \"Stream_Read: request %zu bytes exceeds remaining %zu bytes\", _n, remaining);\n        return FALSE; /* or handle error appropriately */\n    }\n    memcpy(_b, _s->pointer, _n);\n    Stream_Seek(_s, _n);\n    return TRUE;\n}\n```", "rationale": "Adding an explicit runtime check in Stream_Read guarantees that untrusted _n cannot exceed the stream\u2019s buffer capacity, preventing heap corruption even if assertions are disabled in production builds.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy directly addresses the root cause by adding an explicit runtime bounds check before the memcpy, which prevents the OOB write even when assertions are disabled. It matches the CWE guidelines and applies at the correct location in Stream_Read. The use of logging and a boolean return makes it safer in production. The only minor gap is that the change of Stream_Read\u2019s signature to return BOOL requires updating all callers to handle the error, which wasn\u2019t discussed. Overall, it\u2019s a solid, plausible fix aligned with the vulnerability details."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, "guideline": "Enforce defense-in-depth by validating lengths both at the low-level Stream_Read implementation and at each high-level caller site. Never trust network-supplied sizes without clamping to the known buffer capacity.", "description": "In libfreerdp/core/gcc.c, at the caller site, clamp the name length to CHANNEL_NAME_LEN and ensure null termination, then check the return value of Stream_Read. Example patch:\n```c\nsize_t name_len = CHANNEL_NAME_LEN;\nif (!Stream_Read(s, channel->Name, name_len))\n{\n    /* handle malformed packet */\n    return ERROR_INVALID_PACKET;\n}\nchannel->Name[name_len] = '\\0';\n```", "rationale": "Clamping the requested read length to the known fixed buffer size at the high-level caller stops any malformed packet from supplying a too-large value and gives the caller a chance to gracefully abort.", "score": 4, "confidence": 8, "reliability_score": 7.2, "eval_rationale": "The proposed strategy correctly identifies clamping the length at the caller as a mitigation and emphasizes defense-in-depth, but it\u2019s incomplete and somewhat inconsistent with the existing code. It only addresses the high-level site and fails to modify Stream_Read itself (despite the guideline), leaving the low-level implementation unchecked. The example patch also assumes Stream_Read returns a status, which it doesn\u2019t, making the suggested code inapplicable without further API changes. Overall the approach is on the right track but lacks the necessary detail and consistency to be a solid, directly applicable fix."}, {"fix_location": {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, "guideline": "Use safe buffer-copy primitives or manually clamp lengths and ensure proper null-termination for fixed-size name fields to avoid overflow and ensure memory safety.", "description": "Optionally, replace raw memcpy calls for fixed-size name fields with secure functions like strncpy_s or strlcpy if available, to automatically handle bounds and termination. Example:\n```c\nchar tempName[CHANNEL_NAME_LEN + 1] = {0};\nif (!Stream_Read(s, tempName, CHANNEL_NAME_LEN))\n    return ERROR_INVALID_PACKET;\nstrlcpy(channel->Name, tempName, sizeof(channel->Name));\n```", "rationale": "Using secure copy functions or manual clamping plus null-termination provides an additional safety net for fixed-size fields, ensuring no overflow and proper string termination regardless of malformed data.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The suggested strategy directly addresses the root cause by clamping the read length and using safer copy functions (strlcpy/strncpy_s) to prevent buffer overruns and ensure null termination. It aligns well with the vulnerability (out-of-bounds write in channel->Name) and the proposed fix location. While the approach is practical and avoids undue generality, it slightly misaligns with the existing Stream_Read signature (void return) when checking for errors. Overall, it is a solid, plausible fix but would require minor adjustments to integrate fully."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}, "guideline": "Validate all untrusted length parameters before use.", "description": "In libfreerdp/core/gcc.c, before calling gcc_read_client_data_blocks, insert a check: if (length > 992) { WLog_ERR(TAG, \"Client data length %u exceeds maximum allowed %u\", length, 992); return FALSE; } This prevents any read beyond the allocated 992-byte buffer.", "rationale": "By rejecting any length value above the known safe capacity of 992 bytes, we eliminate the possibility of an 8-byte out-of-bounds write.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly addresses the root cause by validating the untrusted length against the known buffer capacity, preventing the 8-byte overflow in gcc_read_client_data_blocks. Inserting the check at the specified location is plausible and aligns with the vulnerability description and guidelines. The solution is neither overly general nor unrealistically detailed. It could be further improved by replacing the magic constant with a named buffer-size constant, but overall it is a solid, appropriate patch strategy."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}, "guideline": "Enforce explicit bounds checks on every read into a fixed-size buffer.", "description": "Inside gcc_read_client_data_blocks, change calls to Stream_Read(s, buffer + offset, blockLength) to first verify blockLength <= (totalBufferSize - offset). If the check fails, log an error and abort. This ensures even per-block reads cannot overflow the buffer.", "rationale": "Per-block bounds checks guarantee that even valid overall lengths cannot be subdivided in a way that overruns the buffer, closing any secondary overflow paths.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly targets the identified overflow by enforcing per-block bounds checks against the fixed buffer size, which aligns well with the described heap-based out-of-bounds write (CWE-787). It plausibly integrates into gcc_read_client_data_blocks and prevents subdivided reads from overrunning the buffer. The strategy is neither overly vague nor unrealistically specific given the known code context, earning a high score. A more detailed code snippet could push it to perfect, but the guidance is solid and applicable."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}, "guideline": "When variable lengths must be accepted, allocate buffers dynamically only after validating the requested size.", "description": "Replace the fixed calloc allocation of 992 bytes (mcs_new(0, 992)) with a dynamic allocation of mcs_new(0, length) only after validating length <= MAX_CLIENT_DATA_SIZE (e.g., 992). This ties buffer size to the validated data length.", "rationale": "Dynamic allocation after validation ensures the buffer size always matches the actual expected read size, preventing both under- and over-allocation vulnerabilities.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies that untrusted length must be validated before allocation, and ties buffer size directly to the validated length, which directly addresses the heap overflow root cause. It aligns with the sanitizer findings and can be applied at the specified code location. The answer is neither too general nor overly specific given the context. It cleanly fixes CWE-787 without introducing side effects, earning a high score."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, {"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}], "fix_location_candidates": [{"locations": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 700, "end_line": 710, "function_name": "", "code": "static INLINE void Stream_Read(wStream* _s, void* _b, size_t _n)\n\t{\n\t\tWINPR_ASSERT(_s);\n\t\tWINPR_ASSERT(_b || (_n == 0));\n\t\tWINPR_ASSERT(Stream_GetRemainingCapacity(_s) >= _n);\n\t\tmemcpy(_b, (_s->pointer), (_n));\n\t\tStream_Seek(_s, _n);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1870, "end_line": 1880, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Apply bounds checking both at the low-level Stream_Read implementation and at the high-level caller to enforce a defense-in-depth strategy, ensuring untrusted length values cannot trigger an out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The selected locations directly target the root cause: the unsafe memcpy in Stream_Read and the unvalidated length passed by the high-level caller. Patching the low-level function ensures all Stream_Read calls are hardened, and adding a check at the gcc.c call site provides defense-in-depth for the known CHANNEL_NAME_LEN buffer. The locations are accurate, relevant, and unlikely to break existing features."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1868, "end_line": 1882, "function_name": "", "code": "rdpMcsChannel* channel = &mcs->channels[i];\n\t\tStream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 610, "end_line": 630, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Adding explicit bounds checks at the points where untrusted length values drive Stream_Read ensures no read request can exceed the buffer capacity, eliminating the heap overflow in both client network data and data block parsing paths.", "score": 6, "confidence": 7, "reliability_score": 10.200000000000001, "eval_rationale": "The selected locations broadly align with the vulnerability\u2014adding bounds checks before Stream_Read calls driven by untrusted lengths is appropriate\u2014but the proposal is somewhat generic and incomplete. Patching the channel name read (an 8-byte name) does protect against overflow there, but the core issue described involves a 992-byte buffer overflow in the data-block parsing path (gcc_read_client_data_blocks), which isn\u2019t explicitly addressed. Similarly, pointing to the gcc_read_client_network_data call site is a valid hook but lacks detail on exactly where and how to validate the length against the actual buffer size. A more precise fix would validate the length parameter right before each Stream_Read against the specific buffer\u2019s capacity (including the 992-byte case) or adjust Stream_Read itself. Because the suggestions are on the right track yet miss the key data-block path and lack specificity, the score reflects a partially correct but incomplete location selection."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 615, "end_line": 620, "function_name": "", "code": ":\n\t\t\t\tif (!gcc_read_client_network_data(sub, mcs))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check in gcc_read_client_data_blocks to validate the length extracted from network data against the allocated buffer size, stopping any read that would overflow the buffer.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The proposed fix location (lines 615\u2013620 in gcc.c) is merely the call site to gcc_read_client_network_data, not within the actual data\u2010block reading function (gcc_read_client_data_blocks) where the out-of-bounds write occurs. Thus it fails to target the true root cause or ensure a proper length check before the unsafe Stream_Read call. Modifying this generic call site is unlikely to resolve the buffer overflow without deeper changes in the correct function, and risks missing the precise vulnerability point."}, {"locations": [{"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 410, "end_line": 420, "function_name": "", "code": "if (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "A bounds check at the point where untrusted length is used to read into a fixed-size buffer prevents an attacker from supplying a length that overflows the allocation, thus eliminating the heap corruption CWE-787.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The LLM correctly identified the spot immediately before the vulnerable call to gcc_read_client_data_blocks in libfreerdp/core/gcc.c (lines 410\u2013420), which aligns with inserting a bounds check at the exact use of the untrusted length. This matches the vulnerability\u2019s root cause and is likely to block out-of-bounds reads. However, the patch only covers one of the two affected parsing paths (it omits gcc_read_client_network_data), and the suggested Stream_CheckAndLogRequiredLength utility appears designed for stream/packet bounds rather than the buffer\u2019s fixed allocation size. Thus, while the chosen location is relevant and well-placed, it\u2019s not fully sufficient to resolve all instances of the CWE-787 issue."}, {"locations": [{"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 695, "end_line": 705, "function_name": "", "code": "if (!ber_read_octet_string_tag(s, &length) ||\n\t    (!Stream_CheckAndLogRequiredLength(TAG, s, length)))\n\t\treturn FALSE;\n\n\tif (!gcc_read_conference_create_request(s, mcs))\n\t\treturn FALSE;\n\n\tif (!mcs_merge_domain_parameters(&mcs->targetParameters, &mcs->minimumParameters,\n\t                                 &mcs->maximumParameters, &mcs->domainParameters))\n\t\treturn FALSE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check in mcs_recv_connect_initial to ensure the length read from the network does not exceed the allocated buffer size, closing the gap that allowed an 8\u2010byte out\u2010of\u2010bounds write.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The LLM\u2019s chosen location in mcs.c (the MCS connect\u2010initial path) does not align with the described vulnerability, which occurs in the GCC channel data parsing functions (gcc_read_client_network_data and gcc_read_client_data_blocks). The proposed bounds check in mcs_recv_connect_initial will not stop an out\u2010of\u2010bounds write in the GCC channel path, making the fix irrelevant to the root cause. Therefore, the selected location is unlikely to resolve the issue and does not address the correct code path."}], "location_candidates": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 703, "end_line": 703, "function_name": "Stream_Read", "code": "memcpy(_b, (_s->pointer), (_n));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1875, "end_line": 1875, "function_name": "gcc_read_client_network_data", "code": "Stream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 617, "end_line": 617, "function_name": "gcc_read_client_data_blocks", "code": "if (!gcc_read_client_network_data(sub, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 414, "end_line": 414, "function_name": "gcc_read_conference_create_request", "code": "if (!gcc_read_client_data_blocks(s, mcs, length))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 700, "end_line": 700, "function_name": "mcs_recv_connect_initial", "code": "if (!gcc_read_conference_create_request(s, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1441, "end_line": 1441, "function_name": "freerdp_is_valid_mcs_create_request", "code": "BOOL result = mcs_recv_connect_initial(mcs, s);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 1446, "start_line": 1446, "end_line": 1446, "function_name": "mcs_new", "code": "mcs->channels = (rdpMcsChannel*)calloc(CHANNEL_MAX_COUNT, sizeof(rdpMcsChannel));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "freerdp_is_valid_mcs_create_request", "code": "rdpMcs* mcs = test_mcs_new();", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "An unchecked read operation in the MCS conference create request handling can cause Stream_Read to write past the end of its heap buffer. Specifically, the code in gcc_read_client_network_data and gcc_read_client_data_blocks calls Stream_Read without verifying that the stream contains enough data for the requested 8-byte read, resulting in a heap buffer overflow.", "rationale": "The vulnerability stems from missing bounds checks on the WStream object\u2019s remaining length before invoking Stream_Read. Fuzzer inputs can supply more data than the allocated 992-byte buffer, causing an out-of-bounds write (CWE-787) and heap corruption. Adding proper length validation before each read will prevent overflow."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The function Stream_Read in gcc_read_client_network_data processes client data blocks using a length value from untrusted input, but it does not verify that this length fits within the fixed-size heap buffer allocated by mcs_new. As a result, a maliciously crafted length can cause Stream_Read to write beyond the end of the allocated buffer, leading to a heap-based out-of-bounds write.", "rationale": "AddressSanitizer logs show an 8-byte write immediately past the 992-byte heap allocation in Stream_Read when handling a malformed network packet. The code lacks a check to ensure the requested read size does not exceed the buffer\u2019s capacity, directly causing the overflow (CWE-787)."}, {"type": "CWE-122: Heap-based Buffer Overflow", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the GCC channel data parsing path, untrusted length values from the client network stream are used to read into a heap-allocated buffer without verifying that the buffer has sufficient space. Specifically, Stream_Read in winpr/stream.h reads an 8-byte block beyond the end of a 992-byte buffer, leading to a heap-based buffer overflow.", "rationale": "The code in gcc_read_client_network_data and related functions trusts a length field from the network without checking against the allocated buffer size (allocated via calloc in mcs_new). This missing bounds validation allows an out-of-bounds write of 8 bytes, triggering a heap buffer overflow (CWE-122)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "An unchecked read operation in the MCS conference create request handling can cause Stream_Read to write past the end of its heap buffer. Specifically, the code in gcc_read_client_network_data and gcc_read_client_data_blocks calls Stream_Read without verifying that the stream contains enough data for the requested 8-byte read, resulting in a heap buffer overflow.", "rationale": "The vulnerability stems from missing bounds checks on the WStream object\u2019s remaining length before invoking Stream_Read. Fuzzer inputs can supply more data than the allocated 992-byte buffer, causing an out-of-bounds write (CWE-787) and heap corruption. Adding proper length validation before each read will prevent overflow."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the GCC channel data parsing path (in gcc_read_client_network_data and gcc_read_client_data_blocks), Stream_Read uses a length value extracted from untrusted client network data to read blocks into a fixed-size heap buffer allocated via mcs_new (calloc). No bounds check is performed to ensure the requested read size does not exceed the buffer's capacity, allowing a maliciously crafted length to trigger an 8-byte write beyond the 992-byte allocation, resulting in heap corruption.", "rationale": "AddressSanitizer logs show that Stream_Read writes 8 bytes past the end of a 992-byte heap buffer when processing a malformed network packet. The code lacks validation of the requested read length against the buffer's allocated size, directly causing a heap-based out-of-bounds write (CWE-787)."}, "crash_stack_trace": [{"file_name": "winpr/include/winpr/stream.h", "fix_line": 703, "start_line": 703, "end_line": 703, "function_name": "Stream_Read", "code": "memcpy(_b, (_s->pointer), (_n));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 1875, "start_line": 1875, "end_line": 1875, "function_name": "gcc_read_client_network_data", "code": "Stream_Read(s, channel->Name, CHANNEL_NAME_LEN + 1); /* name (8 bytes) */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 617, "start_line": 617, "end_line": 617, "function_name": "gcc_read_client_data_blocks", "code": "if (!gcc_read_client_network_data(sub, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/gcc.c", "fix_line": 414, "start_line": 414, "end_line": 414, "function_name": "gcc_read_conference_create_request", "code": "if (!gcc_read_client_data_blocks(s, mcs, length))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/mcs.c", "fix_line": 700, "start_line": 700, "end_line": 700, "function_name": "mcs_recv_connect_initial", "code": "if (!gcc_read_conference_create_request(s, mcs))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1441, "start_line": 1441, "end_line": 1441, "function_name": "freerdp_is_valid_mcs_create_request", "code": "BOOL result = mcs_recv_connect_initial(mcs, s);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [{"file_name": "libfreerdp/core/mcs.c", "fix_line": 1446, "start_line": 1446, "end_line": 1446, "function_name": "mcs_new", "code": "mcs->channels = (rdpMcsChannel*)calloc(CHANNEL_MAX_COUNT, sizeof(rdpMcsChannel));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/core/freerdp.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "freerdp_is_valid_mcs_create_request", "code": "rdpMcs* mcs = test_mcs_new();", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/freerdp_fp-full-01_vuln_004/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "freerdp_fp-full-01_vuln_004", "sanitizer_output": "+ FUZZER=TestFuzzCoreServer\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer TestFuzzCoreServer -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/TestFuzzCoreServer -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 2884325085\nINFO: Loaded 1 modules   (70193 inline 8-bit counters): 70193 [0x55ecce390594, 0x55ecce3a17c5), \nINFO: Loaded 1 PC tables (70193 PCs): 70193 [0x55ecce3a17c8,0x55ecce4b3ad8), \n/out/TestFuzzCoreServer: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: *************************************************\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: This build is using [runtime-check] build options:\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: * 'WITH_VERBOSE_WINPR_ASSERT=ON'\n[02:02:27:717] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: \n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: [runtime-check] build options might slow down the application\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core.rdp] - [log_build_warn][0x519000000080]: *************************************************\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_SOCKET, SO_KEEPALIVE\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() IPPROTO_TCP, TCP_KEEPIDLE\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_KEEPCNT\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_KEEPINTVL\n[02:02:27:718] [18:00000012] [WARN][com.freerdp.core] - [freerdp_tcp_set_keep_alive_mode]: setsockopt() SOL_TCP, TCP_USER_TIMEOUT\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_send_update_pdu]: fast path update size (2) exceeds the client's maximum request size (0)\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_update]: Fastpath update Synchronize [3] failed, status 0\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_update_data]: fastpath_recv_update() - -1\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core.fastpath] - [fastpath_recv_updates]: fastpath_recv_update_data() fail\n[02:02:27:719] [18:00000012] [WARN][com.freerdp.core.rdp] - [rdp_read_security_header][0x519000000080]: invalid security header length, have 0, must be >= 4\n[02:02:27:719] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 88 > tpkt header length 0\n[02:02:27:719] [18:00000012] [WARN][com.freerdp.core.rdp] - [Stream_CheckAndLogRequiredLengthWLogExVa][0x519000000080]: [rdp_read_share_control_header(/src/FreeRDP/libfreerdp/core/rdp.c:314)] invalid length, got 169, require at least 16699 [element size=1]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 10: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 11: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:720] [18:00000012] [WARN][com.freerdp.core.rdp] - [winpr_log_backtrace_ex][0x519000000080]: 12: unresolvable, address=(nil)\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core.update] - [update_recv_altsec_window_order]: Stream short orderSize\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core.surface] - [update_recv_surfcmds]: unknown cmdType 0x4141\n[02:02:27:720] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 65 > tpkt header length 0\n[02:02:27:720] [18:00000012] [WARN][com.winpr.wStream] - [Stream_CheckAndLogRequiredLengthWLogExVa]: [rdp_recv_demand_active(/src/FreeRDP/libfreerdp/core/capabilities.c:4528)] invalid length, got 126, require at least 22616 [element size=1]\n[02:02:27:720] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 10: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 11: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 12: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.winpr.wStream] - [winpr_log_backtrace_ex]: 13: unresolvable, address=(nil)\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [Stream_CheckAndLogRequiredLengthWLogExVa]: [rdp_recv_confirm_active(/src/FreeRDP/libfreerdp/core/capabilities.c:4660)] invalid length, got 116, require at least 22532 [element size=1]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 0: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 1: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 2: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 3: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 4: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 5: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 6: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 7: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 8: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 9: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 10: dli_fname=/lib/x86_64-linux-gnu/libc.so.6 [0x7fb409ce3000], dli_sname=__libc_start_main [0x7fb409d06f90]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 11: dli_fname=/out/TestFuzzCoreServer [0x55eccd4b8000], dli_sname=(null) [(nil)]\n[02:02:27:721] [18:00000012] [WARN][com.freerdp.core.capabilities] - [winpr_log_backtrace_ex]: 12: unresolvable, address=(nil)\n[02:02:27:721] [18:00000012] [ERROR][com.freerdp.core] - [tpdu_read_header]: tpdu length 65 > tpkt header length 0\n=================================================================\n==18==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x519000001d60 at pc 0x55eccdd52d91 bp 0x7ffe05bf4ad0 sp 0x7ffe05bf4ac8\nWRITE of size 8 at 0x519000001d60 thread T0\nSCARINESS: 42 (8-byte-write-heap-buffer-overflow)\n    #0 0x55eccdd52d90 in Stream_Read /src/FreeRDP/winpr/include/winpr/stream.h:703:3\n    #1 0x55eccdd52d90 in gcc_read_client_network_data /src/FreeRDP/libfreerdp/core/gcc.c:1875:3\n    #2 0x55eccdd52d90 in gcc_read_client_data_blocks /src/FreeRDP/libfreerdp/core/gcc.c:617:10\n    #3 0x55eccdd4d00b in gcc_read_conference_create_request /src/FreeRDP/libfreerdp/core/gcc.c:414:7\n    #4 0x55eccdc952ff in mcs_recv_connect_initial /src/FreeRDP/libfreerdp/core/mcs.c:700:7\n    #5 0x55eccda6cefb in freerdp_is_valid_mcs_create_request /src/FreeRDP/libfreerdp/core/freerdp.c:1441:16\n    #6 0x55eccd9f4785 in test_server /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:82:3\n    #7 0x55eccd9f4785 in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:106:2\n    #8 0x55eccd8ab100 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #9 0x55eccd896375 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #10 0x55eccd89be0f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #11 0x55eccd8c70b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #12 0x7fb409d07082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #13 0x55eccd88e55d in _start (/out/TestFuzzCoreServer+0x3d655d)\n\nDEDUP_TOKEN: Stream_Read--gcc_read_client_network_data--gcc_read_client_data_blocks\n0x519000001d60 is located 0 bytes after 992-byte region [0x519000001980,0x519000001d60)\nallocated by thread T0 here:\n    #0 0x55eccd9b7099 in calloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:75:3\n    #1 0x55eccdc9a9b6 in mcs_new /src/FreeRDP/libfreerdp/core/mcs.c:1446:34\n    #2 0x55eccda6cee4 in freerdp_is_valid_mcs_create_request /src/FreeRDP/libfreerdp/core/freerdp.c:1438:16\n    #3 0x55eccd9f4785 in test_server /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:82:3\n    #4 0x55eccd9f4785 in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/core/test/TestFuzzCoreServer.c:106:2\n    #5 0x55eccd8ab100 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #6 0x55eccd896375 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #7 0x55eccd89be0f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #8 0x55eccd8c70b2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #9 0x7fb409d07082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n\nDEDUP_TOKEN: __interceptor_calloc--mcs_new--freerdp_is_valid_mcs_create_request\nSUMMARY: AddressSanitizer: heap-buffer-overflow /src/FreeRDP/winpr/include/winpr/stream.h:703:3 in Stream_Read\nShadow bytes around the buggy address:\n  0x519000001a80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x519000001c80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x519000001d00: 00 00 00 00 00 00 00 00 00 00 00 00[fa]fa fa fa\n  0x519000001d80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001e00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001e80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001f00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x519000001f80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/freerdp:/out -v /home/user/aixcc/dataset/tarballs/freerdp_fp-full-01/pov/freerdp_fp-full-01_vuln_004:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TestFuzzCoreServer -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-freerdp", "last_node": "patch_end"}