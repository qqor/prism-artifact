{"vuln_data": {"id": "wireshark_ws-delta-01_vuln_003", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_ber", "branch_name": "ws-delta-01", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["build_failed", "build_failed", "build_failed", "build_failed", "build_failed", "success", "", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n", "patched_code": "case BER_UNI_TAG_GeneralString:\n{\n    /* Rationale: clamp copy length using the actual context field and use unsigned int to match the API */\n    unsigned int copy_len = asn1_ctx.len;\n    if (copy_len > sizeof(name_string) - 1)\n        copy_len = sizeof(name_string) - 1;\n    offset = dissect_ber_GeneralString(&asn1_ctx,\n                                       tree,\n                                       tvb,\n                                       start_offset,\n                                       hf_ber_unknown_GeneralString,\n                                       name_string,\n                                       copy_len);\n    name_string[copy_len] = '\\0';\n}\nbreak;", "func_def": "static int\n// NOLINTNEXTLINE(misc-no-recursion)\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, int nest_level)", "func_ret": ["return tvb_reported_length(tvb);"]}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n", "patched_code": "@@ -931,12 +931,15 @@ packet_ber(proto_tree *tree, tvbuff_t *tvb, gint start_offset)", "func_def": "static int\n// NOLINTNEXTLINE(misc-no-recursion)\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, int nest_level)", "func_ret": ["return tvb_reported_length(tvb);"]}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n", "patched_code": "--- a/epan/dissectors/packet-ber.c\n+++ b/epan/dissectors/packet-ber.c\n@@ case BER_UNI_TAG_GeneralString:\n-                /* Rationale: use MIN() to bound the copy length */\n-                offset = dissect_ber_GeneralString(&asn1_ctx,\n-                                                   tree,\n-                                                   tvb,\n-                                                   start_offset,\n-                                                   hf_ber_unknown_GeneralString,\n-                                                   name_string,\n-                                                   (size_t)(asn1_ctx.length < sizeof(name_string) - 1 ? asn1_ctx.length : sizeof(name_string) - 1));\n-                name_string[(size_t)(asn1_ctx.length < sizeof(name_string) - 1 ? asn1_ctx.length : sizeof(name_string) - 1)] = '\\0';\n+                /* Rationale: use the context's 'length' field correctly; renamed to 'length' -> 'length' member is 'length', use asn1_ctx.length_in_octets */\n+                {\n+                    size_t copy_len = ASN1_MIN(asn1_ctx.length_in_octets, sizeof(name_string) - 1);\n+                    offset = dissect_ber_GeneralString(&asn1_ctx,\n+                                                       tree,\n+                                                       tvb,\n+                                                       start_offset,\n+                                                       hf_ber_unknown_GeneralString,\n+                                                       name_string,\n+                                                       copy_len);\n+                    name_string[copy_len] = '\\0';\n+                }\n", "func_def": "static int\n// NOLINTNEXTLINE(misc-no-recursion)\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, int nest_level)", "func_ret": ["return tvb_reported_length(tvb);"]}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n", "patched_code": "                case BER_UNI_TAG_GeneralString:\n                    /* Rationale: skip oversized payload to avoid overflow */\n                    if (asn1_ctx.length_data > sizeof(name_string) - 1) {\n                        /* consume the TLV and skip string parsing */\n                        offset = start_offset + asn1_ctx.length_data;\n                    } else {\n                        offset = dissect_ber_GeneralString(&asn1_ctx,\n                                                           tree,\n                                                           tvb,\n                                                           start_offset,\n                                                           hf_ber_unknown_GeneralString,\n                                                           name_string,\n                                                           sizeof(name_string));\n                        name_string[asn1_ctx.length_data] = '\\0';\n                    }\n                    break;", "func_def": "static int\n// NOLINTNEXTLINE(misc-no-recursion)\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, int nest_level)", "func_ret": ["return tvb_reported_length(tvb);"]}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n", "patched_code": "case BER_UNI_TAG_GeneralString:\n    /* Ensure buffer is null-terminated without accessing non-existent ctx fields */\n    offset = dissect_ber_GeneralString(\n                   &asn1_ctx,\n                   tree,\n                   tvb,\n                   start_offset,\n                   hf_ber_unknown_GeneralString,\n                   name_string,\n                   sizeof(name_string));\n    /* Guarantee null termination at buffer end */\n    name_string[sizeof(name_string) - 1] = '\\0';\n    break;", "func_def": "static int\n// NOLINTNEXTLINE(misc-no-recursion)\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, int nest_level)", "func_ret": ["return tvb_reported_length(tvb);"]}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    /* Rationale: clamp tvb_len to buffer capacity to prevent overflow */\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            /* compute safe copy length */\n            unsigned copy_len = 0;\n            if (tvb_len > 0) {\n                if ((unsigned)tvb_len < name_len)\n                    copy_len = (unsigned)tvb_len;\n                else\n                    copy_len = name_len - 1;\n            }\n            tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, copy_len);\n            name_string[copy_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    /* Rationale: treat length as unsigned and clamp at name_len-1 */\n    tvbuff_t *out_tvb = NULL;\n    unsigned tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            /* clamp to at most name_len-1 */\n            unsigned copy_len = (tvb_len >= name_len) ? (name_len - 1) : tvb_len;\n            tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, copy_len);\n            name_string[copy_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    /* Rationale: use a single bounded copy approach */\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            /* clamp tvb_len between 0 and name_len-1 */\n            unsigned bounded = (tvb_len < 0) ? 0 : ((unsigned)tvb_len < name_len ? (unsigned)tvb_len : name_len - 1);\n            tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, bounded);\n            name_string[bounded] = '\\0';\n        }\n    }\n\n    return offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    /* Rationale: validate tvb_len and clamp to prevent overflow */\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if (tvb_len < 0) {\n                /* nothing to copy */\n                name_string[0] = '\\0';\n            } else if ((unsigned)tvb_len >= name_len) {\n                /* too big, truncate to fit */\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len - 1);\n                name_string[name_len - 1] = '\\0';\n            } else {\n                /* safe to copy full tvb_len */\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, (unsigned)tvb_len);\n                name_string[tvb_len] = '\\0';\n            }\n        }\n    }\n\n    return offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    /* Rationale: unified min/max clamping of copy length */\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            /* clamp between 0 and name_len-1 */\n            unsigned copy_len = (unsigned)tvb_len;\n            if ((unsigned)tvb_len >= name_len)\n                copy_len = name_len - 1;\n            /* perform bounded copy */\n            tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, copy_len);\n            name_string[copy_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, {"fix_location": {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}, "guideline": "Employ safer copy primitives (e.g., memcpy_s or strlcpy) that enforce bounds checking at runtime.", "description": "Switch to a secure copy routine that enforces the destination buffer size:\n\n```c\nsize_t len = ber_get_length(pkt, &offset);\nchar name_string[256];\nif (memcpy_s(name_string, sizeof(name_string), pkt->data + offset, len) != 0) {\n    /* handle overflow error */\n    return ASN1_ERROR;\n}\nname_string[len < sizeof(name_string) ? len : sizeof(name_string)-1] = '\\0';\n```\n\n`memcpy_s` will fail if `len` exceeds the buffer, preventing any out-of-bounds write.", "rationale": "Secure APIs like `memcpy_s` automatically compare copy length against the buffer capacity and return errors on violation, reducing manual-check mistakes and improving code clarity.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause\u2014a missing bounds check on a fixed-size stack buffer\u2014and replaces the unsafe memcpy with memcpy_s to enforce runtime size validation, including proper null-termination. This approach aligns well with the vulnerability details and would effectively prevent the one-byte overflow. However, the answer stops short of providing concrete patch context (e.g., exact file and function diff), error-handling integration, or portability considerations (availability of memcpy_s), making it less actionable as a stand-alone patch."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Enforce explicit bounds checking of the ASN.1 length field against the fixed buffer size before any memory copy (CWE-787).", "description": "In dissect_ber_GeneralString, immediately clamp the read length tvb_len to at most name_len-1. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len)\n        tvb_len = name_len - 1;\n\nThen proceed to use tvb_len for strcpy/memcpy and NUL-terminate.", "rationale": "Clamping tvb_len to name_len-1 ensures the buffer name_string can always hold the copied data plus a terminating NUL, eliminating the one-byte overflow.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed strategy directly addresses the root cause by clamping the ASN.1 length to the buffer capacity minus one, then using that safe length for the copy and explicit NUL-termination. It aligns perfectly with the CWE-787 mitigation guideline, is actionable at the identified code location, and avoids over- or under-specification. A minor detail\u2014ensuring both branches use the same clamped length\u2014can be easily refined, but overall the fix is sound and practical."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Use bounded copy operations or clamp lengths to the buffer\u2019s capacity to guarantee no out-of-bounds write occurs (CERT C STR31-C).", "description": "Replace the existing two-branch memcpy with a single, bounded copy using the clamped tvb_len. For example:\n\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "Using a single bounded copy simplifies the logic and guarantees the copy length never exceeds the buffer\u2019s capacity, preventing out-of-bounds writes (addresses CWE-787).", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked length) and chooses the proper fix location. It simplifies the logic by consolidating the memcpy and promises a clamped copy to prevent out-of-bounds writes, aligning with CERT C STR31-C. However, the snippet omits an explicit clamp of tvb_len to the buffer\u2019s capacity (name_len-1), which is essential to guarantee safety. This oversight weakens the proposal\u2019s completeness, so the score is tempered to reflect a generally correct but incomplete fix strategy."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, "guideline": "Validate or reject overly large ASN.1 length values early in parsing, failing safely instead of proceeding with unsafe memory operations (CWE-119).", "description": "Before performing any copy, validate the ASN.1 length against a defined maximum. If the length exceeds the maximum, log an error and abort dissection or skip this field. For example:\n\n    if (raw_length > MAX_GENERAL_STRING_LEN) {\n        expert_add_info_format(pinfo, NULL, PI_MALFORMED, PI_ERROR,\n            \"GeneralString length %u exceeds maximum %u\", raw_length, MAX_GENERAL_STRING_LEN);\n        return -1;\n    }", "rationale": "Early validation of the ASN.1 length rejects malformed or malicious inputs before any memory operation, enforcing a fail-safe parsing strategy and preventing buffer overflow at the source.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed strategy correctly identifies the root cause (unchecked ASN.1 length) and outlines an appropriate early validation approach that prevents buffer overflow by rejecting oversized inputs. It aligns with CWE-119 mitigation guidelines and can be applied at the suggested location before the memcpy. However, the answer remains somewhat generic\u2014it doesn\u2019t specify how to choose or define MAX_GENERAL_STRING_LEN relative to name_string\u2019s actual size nor integrate directly with the existing code (e.g., updating name_len or using a MIN macro). While the approach is sound and plausible, it lacks the specific implementation details needed for a complete patch, so it earns a solid but not top score."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Perform explicit bounds checking on the ASN.1 length field before copying into a fixed-size buffer.", "description": "In dissect_ber_GeneralString, read the ASN.1 length into a local variable, then clamp it to the buffer\u2019s capacity minus one for a terminator:\n\n```c\n/* before */\nmemcpy(name_string, tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII), asn1_ctx.length);\nname_string[asn1_ctx.length] = '\\0';\n```\n\n```c\n/* after */\nsize_t copy_len = asn1_ctx.length;\nif (copy_len > sizeof(name_string) - 1)\n    copy_len = sizeof(name_string) - 1;\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, copy_len, ENC_ASCII),\n       copy_len);\nname_string[copy_len] = '\\0';\n```", "rationale": "Clamping the copy length to the buffer capacity minus one ensures we never write past the end of `name_string`, eliminating the one-byte overflow while preserving existing logic.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause (unchecked ASN.1 length) by clamping the copy length to the buffer capacity minus one and adding a null terminator. It aligns perfectly with the vulnerability description and the intended fix location, and it is both realistic to implement and specific enough without hallucinating irrelevant details. This strategy should effectively eliminate the one-byte stack overflow without altering other logic."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Use dynamic allocation for variable\u2010length data rather than a fixed\u2010size stack buffer when the input length may exceed compile\u2010time limits.", "description": "Replace the fixed\u2010size `name_string` buffer with a heap allocation sized to the ASN.1 length plus one, then free it when done:\n\n```c\n/* declare */\nchar *name_string = NULL;\n\n/* in function */\nsize_t len = asn1_ctx.length;\nname_string = wmem_malloc(len + 1);\nmemcpy(name_string,\n       tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, len, ENC_ASCII),\n       len);\nname_string[len] = '\\0';\n/* use name_string */\nwmem_free(name_string);\n```", "rationale": "Dynamic allocation sized to the actual length plus one removes the need for fixed\u2010size limits and avoids any stack overflow risk when processing larger GeneralString values.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the out-of-bounds write and replaces the fixed-size stack buffer with a dynamically sized allocation based on the ASN.1 length plus one. It aligns well with the vulnerability details and fix location, preventing overflow while preserving functionality. The use of wmem_malloc and free demonstrates awareness of Wireshark\u2019s memory contexts, though in practice wmem_packet_scope typically obviates manual frees. Minor stylistic details aside, the approach is sound and applicable."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, "guideline": "Employ length\u2010restricted memory or string operations (e.g., capped memcpy or g_strndup) and always ensure null termination.", "description": "Use a bounded helper routine (or g_strndup) to copy and null-terminate in one call, ensuring no overflow and proper allocation:\n\n```c\n/* allocate and copy with safety */\nchar *name_string = g_strndup(\n    tvb_get_string_enc(wmem_packet_scope(), tvb, offset+hdr_len, asn1_ctx.length, ENC_ASCII),\n    asn1_ctx.length\n);\n/* g_strndup will allocate asn1_ctx.length+1 and null-terminate */\n/* use name_string and free when done */\n```", "rationale": "Using a well-tested, length-restricted helper (like g_strndup) centralizes bounds checking and null termination, reducing manual error and ensuring safety in a single call.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly addresses the unchecked copy by replacing the fixed\u2010size stack buffer with a dynamically allocated, length\u2010bounded helper (g_strndup), ensuring both bounds checking and null-termination. This aligns well with the root cause (overflow of name_string) and uses standard, safe routines. The suggestion is applicable to the identified switch case, concise, and avoids manual off-by-one pitfalls. It loses a point only because it omits details on updating the function signature and memory freeing, but overall it is a solid, plausible remediation."}, {"fix_location": {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}, "guideline": "Validate the decoded length against the fixed buffer\u2019s capacity before copying to prevent out-of-bounds writes (CWE-787).", "description": "Insert an explicit bounds check immediately after parsing the BER length. For example:\n\n```c\nsize_t len = ber_get_length(pkt, &offset);\nchar name_string[256];\nif (len >= sizeof(name_string)) {\n    /* length too large, truncate or fail */\n    len = sizeof(name_string) - 1;\n}\nmemcpy(name_string, pkt->data + offset, len);\nname_string[len] = '\\0';\n```\nThis ensures no more than 255 bytes are written and reserves one byte for the NUL terminator.", "rationale": "By checking and capping the copy length, we eliminate the one-byte overflow condition and guarantee the buffer remains NUL-terminated.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the root cause (unbounded memcpy of BER length) and applies a textbook CWE-787 mitigation: validate and cap the length before copying into the fixed buffer, with space reserved for the NUL terminator. It aligns precisely with the sanitizer report and the dissect_ber_GeneralString function context. The solution is neither overly general nor unrealistically specific, and it directly addresses the one-byte overflow without impacting other functionality. Therefore, it is a high-quality, plausible fix."}, {"fix_location": {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}, "guideline": "Use dynamically allocated buffers sized to the validated length to avoid fixed-size stack buffers when the ASN.1 length is untrusted (CWE-119).", "description": "Replace the fixed-size stack buffer with a heap allocation based on the validated length:\n\n```c\nsize_t len = ber_get_length(pkt, &offset);\n/* guard against integer overflow */\nif (len > MAX_REASONABLE_SIZE) return ASN1_ERROR;\nchar *name_string = malloc(len + 1);\nif (!name_string) return ASN1_OUT_OF_MEMORY;\nmemcpy(name_string, pkt->data + offset, len);\nname_string[len] = '\\0';\n/* use name_string... */\nfree(name_string);\n```\n\nThis adapts to any legal BER length while preventing stack overflows.", "rationale": "Dynamically sizing the allocation to exactly `len+1` bytes removes assumptions about maximum string size and moves large or unexpected data off the stack, mitigating stack overflow risks.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix directly addresses the root cause\u2014using an unbounded fixed-size stack buffer\u2014and replaces it with a heap allocation sized to the validated ASN.1 length. It includes a reasonable upper-bound check (MAX_REASONABLE_SIZE), guards against integer overflow, performs proper null-termination, and frees the buffer when done. The strategy is plausible, aligns with CWE-119 mitigation practices, and won\u2019t inadvertently break other functionality. The answer is not overly specific about code locations (which aren\u2019t provided) but gives enough detail to implement correctly, so it merits a high score."}, {"fix_location": {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}, "guideline": "Employ safer copy primitives (e.g., memcpy_s or strlcpy) that enforce bounds checking at runtime.", "description": "Switch to a secure copy routine that enforces the destination buffer size:\n\n```c\nsize_t len = ber_get_length(pkt, &offset);\nchar name_string[256];\nif (memcpy_s(name_string, sizeof(name_string), pkt->data + offset, len) != 0) {\n    /* handle overflow error */\n    return ASN1_ERROR;\n}\nname_string[len < sizeof(name_string) ? len : sizeof(name_string)-1] = '\\0';\n```\n\n`memcpy_s` will fail if `len` exceeds the buffer, preventing any out-of-bounds write.", "rationale": "Secure APIs like `memcpy_s` automatically compare copy length against the buffer capacity and return errors on violation, reducing manual-check mistakes and improving code clarity.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The proposed strategy correctly identifies the root cause\u2014a missing bounds check on a fixed-size stack buffer\u2014and replaces the unsafe memcpy with memcpy_s to enforce runtime size validation, including proper null-termination. This approach aligns well with the vulnerability details and would effectively prevent the one-byte overflow. However, the answer stops short of providing concrete patch context (e.g., exact file and function diff), error-handling integration, or portability considerations (availability of memcpy_s), making it less actionable as a stand-alone patch."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3198, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Insert a bounds check on the ASN.1 length before copying into the fixed-size stack buffer to prevent the one-byte overflow (CWE-787) in dissect_ber_GeneralString.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The proposed fix targets the copying into the output tvbuff (`out_tvb`) rather than the vulnerable fixed-size stack buffer `name_string`. The actual overflow occurs earlier when data from the input tvbuff is memcpy\u2019ed into `name_string` without bounds checking. Modifying the code at lines 3188\u20133198 does not address the root cause of the one-byte stack buffer overflow. Thus, the selected location is irrelevant and unlikely to resolve the vulnerability."}, {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 930, "end_line": 940, "function_name": "", "code": "case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(false, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add a bounds check on the ASN.1 length field so that we never copy more bytes than name_string can hold, eliminating the one-byte overflow while retaining normal dissector behavior.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The LLM correctly identifies the switch case in packet-ber.c where the vulnerable buffer (name_string) is supplied to dissect_ber_GeneralString and proposes adding a length check against sizeof(name_string). This location is directly tied to the overflow and addressing it here will stop the out-of-bounds write for the GeneralString path without impacting other dissectors. However, a more comprehensive fix would enforce bounds checking inside dissect_ber_GeneralString itself (covering any future callers), so while the chosen spot is effective for the immediate issue, it\u2019s not the most robust centralization of the fix."}, {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 1053, "start_line": 1050, "end_line": 1055, "function_name": "", "code": "switch (ber_class) {\n        case BER_CLASS_UNI:\n            next_tree = proto_tree_add_subtree(tree, tvb, offset, len, ett_ber_SEQUENCE, NULL,\n                                               val_to_str_ext_const(tag, &ber_uni_tag_codes_ext, \"Unknown\"));\n            while (offset < (int)(start_offset + len + hdr_len))\n                offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n            break;\n        case BER_CLASS_APP:\n        case BER_CLASS_CON:\n        case BER_CLASS_PRI:\n        default:\n            next_tree = proto_tree_add_subtree_format(tree, tvb, offset, len, ett_ber_SEQUENCE, NULL,\n                            \"[%s %d]\", val_to_str_const(ber_class, ber_class_codes, \"Unknown\"), tag);\n            while (offset < (int)(start_offset + len + hdr_len))\n                offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n            break;\n\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability is caused by copying an unvalidated length from the BER length field into a fixed-size local buffer. By inserting a bounds check in packet-ber.c\u2019s dissect_ber_GeneralString function immediately before the memcpy, we ensure that the length cannot exceed name_string\u2019s capacity, thus eliminating the out-of-bounds write while preserving the original functionality for valid lengths.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in the switch statement handling BER classes (lines 1050\u20131055) is unrelated to the out-of-bounds write in dissect_ber_GeneralString. The vulnerability stems from an unchecked memcpy into the fixed-size name_string buffer, but the LLM\u2019s location addresses sequence subtree parsing rather than the GeneralString dissector. Modifying that switch cannot prevent the buffer overflow, making the selection ineffective and off-target."}, {"locations": [], "rationale": "Requesting code context for dissect_ber_GeneralString in packet-ber.c to identify the exact buffer allocation and memcpy usage. Once we have the code, we can pinpoint the unsafe copy and insert proper bounds checking.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to specify any code modification location; the <Where-To-Fix_Fix_Location> is empty. Without a concrete location, it cannot address the buffer overflow, making the response ineffective."}, {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 323, "start_line": 320, "end_line": 327, "function_name": "", "code": "/* Reassembled data field */\n    NULL,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The unchecked memcpy of the ASN.1 length into the stack buffer name_string in dissect_ber_GeneralString can exceed its fixed size by one byte. Inserting a boundary check and capping the length ensures no out-of-bounds write occurs while preserving normal string decoding functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The chosen location (packet-ber.c:320\u2013327 around a NULL entry in the dissector table) does not correspond to the actual memcpy within dissect_ber_GeneralString. It is unrelated to the code copying into name_string and therefore would not address the buffer overflow. This makes the fix location inappropriate and unlikely to resolve the vulnerability."}], "location_candidates": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3194, "end_line": 3194, "function_name": "dissect_ber_GeneralString", "code": "name_string[tvb_len] = '\\0';", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 935, "end_line": 935, "function_name": "try_dissect_unknown_ber", "code": "offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The BER GeneralString dissector in packet-ber.c uses a fixed-size stack buffer (`name_string`) but fails to verify that the ASN.1 length fits within that buffer. A specially crafted BER packet with an oversized length field can trigger a write just past the end of `name_string`, corrupting adjacent stack memory.", "rationale": "AddressSanitizer reports a one-byte stack-buffer overflow in `dissect_ber_GeneralString` when writing into `name_string`. The code copies data based on the decoded length without capping it to the buffer\u2019s capacity, resulting in an out-of-bounds write (CWE-787) and underlying buffer overflow (CWE-119)."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The BER dissector function dissect_ber_GeneralString writes decoded string bytes into a fixed-size, stack-allocated buffer (\u201cname_string\u201d) without verifying that the input length fits, allowing an out-of-bounds write past the buffer\u2019s end.", "rationale": "AddressSanitizer reports a 1-byte write beyond the end of name_string in dissect_ber_GeneralString, demonstrating missing bounds checking on the buffer. This unchecked write into a stack buffer constitutes a buffer overflow (CWE-119) and specifically an out-of-bounds write (CWE-787)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the BER dissector, the code in dissect_ber_GeneralString copies incoming string data into a fixed-size stack buffer (name_string) without enforcing an upper bound on the length. A maliciously crafted BER GeneralString can exceed the buffer\u2019s capacity, causing a one-byte write past the end of the stack array.", "rationale": "AddressSanitizer identifies a stack-buffer overflow in packet-ber.c: dissect_ber_GeneralString performs an out-of-bounds write to name_string because it uses the length field from the BER data without verifying it against the buffer\u2019s size. This matches CWE-787 (Out-of-bounds Write) and stems from the broader CWE-119 (Buffer Overflow)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The BER GeneralString dissector in packet-ber.c uses a fixed-size stack buffer (`name_string`) but fails to verify that the ASN.1 length fits within that buffer. A specially crafted BER packet with an oversized length field can trigger a write just past the end of `name_string`, corrupting adjacent stack memory.", "rationale": "AddressSanitizer reports a one-byte stack-buffer overflow in `dissect_ber_GeneralString` when writing into `name_string`. The code copies data based on the decoded length without capping it to the buffer\u2019s capacity, resulting in an out-of-bounds write (CWE-787) and underlying buffer overflow (CWE-119)."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The BER GeneralString dissector in packet-ber.c uses a fixed-size stack buffer (name_string) to hold decoded string data. It takes the length directly from the ASN.1 length field and memcpy\u2019s that many bytes into the buffer without enforcing an upper bound. A maliciously crafted BER packet with an oversized length can therefore write one byte past the end of name_string, corrupting adjacent stack memory and causing a stack-based buffer overflow.", "rationale": "AddressSanitizer reports a one-byte stack-buffer overflow in packet-ber.c\u2019s dissect_ber_GeneralString function. The code reads a length field from the BER GeneralString and copies that many bytes into a fixed-size, stack-allocated buffer without verifying the length against the buffer\u2019s capacity. This unchecked copy results in an out-of-bounds write past the end of the buffer, reflecting CWE-787 within the broader context of CWE-119."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3194, "end_line": 3194, "function_name": "dissect_ber_GeneralString", "code": "name_string[tvb_len] = '\\0';", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 935, "end_line": 935, "function_name": "try_dissect_unknown_ber", "code": "offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-delta-01_vuln_003/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-delta-01_vuln_003", "sanitizer_output": "+ FUZZER=handler_ber\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_ber -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_ber -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: ber\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 380317709\nINFO: Loaded 1 modules   (420438 inline 8-bit counters): 420438 [0xa9f3f00, 0xaa5a956), \nINFO: Loaded 1 PC tables (420438 PCs): 420438 [0xaa5a958,0xb0c4eb8), \n/out/handler_ber: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n=================================================================\n==18==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc598809df at pc 0x000005431adb bp 0x7ffc59880850 sp 0x7ffc59880848\nWRITE of size 1 at 0x7ffc598809df thread T0\nSCARINESS: 46 (1-byte-write-stack-buffer-overflow)\n    #0 0x5431ada in dissect_ber_GeneralString /src/wireshark/epan/dissectors/packet-ber.c:3194:34\n    #1 0x542899b in try_dissect_unknown_ber /src/wireshark/epan/dissectors/packet-ber.c:935:26\n    #2 0x5b84ecd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #3 0x5b84ecd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #4 0x5b8fb24 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #5 0x5b8fb24 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #6 0x544aad7 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #7 0x5b84ecd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #8 0x5b84ecd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #9 0x5b809c7 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #10 0x5b809c7 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #11 0x5b809c7 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #12 0x52bd530 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #13 0x50b3f48 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #14 0x4f66c20 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #15 0x4f51245 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #16 0x4f56cdf in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #17 0x4f82bd2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #18 0x7fa8ba7b2082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #19 0x4f4942d in _start (/out/handler_ber+0x4f4942d)\n\nDEDUP_TOKEN: dissect_ber_GeneralString--try_dissect_unknown_ber--call_dissector_through_handle\nAddress 0x7ffc598809df is located in stack of thread T0 at offset 159 in frame\n    #0 0x5427a1f in try_dissect_unknown_ber /src/wireshark/epan/dissectors/packet-ber.c:814\n\nDEDUP_TOKEN: try_dissect_unknown_ber\n  This frame has 12 object(s):\n    [32, 40) 'val.i510' (line 2021)\n    [64, 72) 'val.i' (line 2021)\n    [96, 97) 'ber_class' (line 816)\n    [112, 113) 'pc' (line 817)\n    [128, 132) 'tag' (line 818)\n    [144, 148) 'len' (line 821)\n    [160, 240) 'name_string' (line 825) <== Memory access at offset 159 underflows this variable\n    [272, 480) 'asn1_ctx' (line 833)\n    [544, 568) 'except_sn' (line 892)\n    [608, 856) 'except_ch' (line 892)\n    [928, 952) 'except_sn149' (line 992)\n    [992, 1240) 'except_ch150' (line 992)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /src/wireshark/epan/dissectors/packet-ber.c:3194:34 in dissect_ber_GeneralString\nShadow bytes around the buggy address:\n  0x7ffc59880700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880900: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f8 f2 f2 f2\n=>0x7ffc59880980: f8 f2 f2 f2 01 f2 01 f2 04 f2 04[f2]00 00 00 00\n  0x7ffc59880a00: 00 00 00 00 00 00 f2 f2 f2 f2 00 00 00 00 00 00\n  0x7ffc59880a80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880b00: 00 00 00 00 f2 f2 f2 f2 f2 f2 f2 f2 f8 f8 f8 f2\n  0x7ffc59880b80: f2 f2 f2 f2 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n  0x7ffc59880c00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x1b,0x84,0x0,0x0,0x0,0xc5,0x41,0x84,0x0,0x0,0x0,0xc6,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x88,0xff,\n\\033\\204\\000\\000\\000\\305A\\204\\000\\000\\000\\306\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\210\\377\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/user/aixcc/dataset/tarballs/wireshark_ws-delta-01/pov/wireshark_ws-delta-01_vuln_003:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_ber -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}