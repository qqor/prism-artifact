diff --git a/libexif/exif-data.c b/libexif/exif-data.c
index f3f6dbc..e344425 100644
--- a/libexif/exif-data.c
+++ b/libexif/exif-data.c
@@ -146,15 +146,15 @@ exif_data_new_mem (ExifMem *mem)
 
 	/* Default data type: none */
 	exif_data_set_data_type (data, EXIF_DATA_TYPE_COUNT);
-
-	return (data);
+    return (data);
 }
 
 ExifData *
 exif_data_new_from_data (const unsigned char *data, unsigned int size)
 {
 	ExifData *edata;
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 
 	edata = exif_data_new ();
 	exif_data_load_data (edata, data, size);
 	return (edata);
@@ -162,12 +162,24 @@ exif_data_new_from_data (const unsigned char *data, unsigned int size)
 
 static int
 exif_data_load_data_entry (ExifData *data, ExifEntry *entry,
-			   const unsigned char *d,
-			   unsigned int size, unsigned int offset)
+                           const unsigned char *d,
+                           unsigned int size, unsigned int offset)
 {
 	unsigned int s, doff;
 
-	entry->tag        = exif_get_short (d + offset + 0, data->priv->order);
+	/* Validate offset */
+	if (offset > size)
+		return 1;
+
+	/* Compute length and check offset + length */
+	s = entry->components * entry->format_size;
+	/* detect overflow of offset + s */
+	if (offset + s < offset || offset + s > size)
+		return 1;
+
+	doff = offset;
+	memcpy (entry->data, d + doff, s);
+	/* rest of original code follows... */	entry->tag        = exif_get_short (d + offset + 0, data->priv->order);
 	entry->format     = exif_get_short (d + offset + 2, data->priv->order);
 	entry->components = exif_get_long  (d + offset + 4, data->priv->order);
 
@@ -233,6 +245,7 @@ exif_data_load_data_entry (ExifData *data, ExifEntry *entry,
 		data->priv->offset_mnote = doff;
 	}
 	return 1;
+// FIXME: Crash CWE-125: Out-of-bounds Read
 }
 
 static void
@@ -243,9 +256,17 @@ exif_data_save_data_entry (ExifData *data, ExifEntry *e,
 	unsigned int doff, s;
 	unsigned int ts;
 
-	if (!data || !data->priv) 
+	if (!data || !data->priv)
 		return;
 
+	/* Candidate 3: detect integer overflow and out-of-range */
+	s = e->size;
+	/* overflow if offset + s wraps or exceeds buffer */
+	if (offset > *ds || offset + s < offset || offset + s > *ds) {
+		return;
+	}
+	doff = offset;
+	/* safe to proceed */
 	/*
 	 * Each entry is 12 bytes long. The memory for the entry has
 	 * already been allocated.
