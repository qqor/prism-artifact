diff --git a/HTMLparser.c b/HTMLparser.c
index 9c34e9e8..9ac40b52 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2604,28 +2604,35 @@ htmlParseData(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: pre-scan comment to find actual length and avoid overflow
+if (buffer == NULL) {
+    const xmlChar *start = input->cur;
+    const xmlChar *end = xmlStrstr(start, (const xmlChar *)"-->");
+    size_t len = 0;
+    if (end)
+        len = (size_t)(end - start);
+    else if (maxLength > 0)
+        len = (size_t)maxLength;
+    buffer_size = len + 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
-            htmlErrMemory(ctxt);
-            return(NULL);
-        }
+        htmlErrMemory(ctxt);
+        return(NULL);
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -2837,28 +2844,28 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                if ((size_t)used + (size_t)chunkSize > buffer_size) {
+                    htmlErrMemory(ctxt);
+                    goto error; /* Rationale: Prevent OOB write by aborting on overflow */
+                }
+                input->cur += chunkSize;
+                memcpy(buffer + used, chunk, chunkSize);
+                used += chunkSize;
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
-
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
 
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                if ((size_t)used + (size_t)replSize > buffer_size) {
+                    htmlErrMemory(ctxt);
+                    goto error; /* Rationale: Prevent OOB write by aborting on overflow */
+                }
+                memcpy(buffer + used, repl, replSize);
+                used += replSize;
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
@@ -3322,28 +3329,35 @@ htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: pre-scan comment to find actual length and avoid overflow
+if (buffer == NULL) {
+    const xmlChar *start = input->cur;
+    const xmlChar *end = xmlStrstr(start, (const xmlChar *)"-->");
+    size_t len = 0;
+    if (end)
+        len = (size_t)(end - start);
+    else if (maxLength > 0)
+        len = (size_t)maxLength;
+    buffer_size = len + 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
-            htmlErrMemory(ctxt);
-            return(NULL);
-        }
+        htmlErrMemory(ctxt);
+        return(NULL);
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -3578,28 +3592,28 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                if ((size_t)used + (size_t)chunkSize > buffer_size) {
+                    htmlErrMemory(ctxt);
+                    goto error; /* Rationale: Prevent OOB write by aborting on overflow */
+                }
+                input->cur += chunkSize;
+                memcpy(buffer + used, chunk, chunkSize);
+                used += chunkSize;
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
-
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
 
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                if ((size_t)used + (size_t)replSize > buffer_size) {
+                    htmlErrMemory(ctxt);
+                    goto error; /* Rationale: Prevent OOB write by aborting on overflow */
+                }
+                memcpy(buffer + used, repl, replSize);
+                used += replSize;
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
