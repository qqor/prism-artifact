diff --git a/HTMLparser.c b/HTMLparser.c
index 9c34e9e8..b5788e81 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2604,28 +2604,28 @@ htmlParseData(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: allocate based on maxLength to prevent overflow
+if (buffer == NULL) {
+    buffer_size = (size_t)(maxLength > 0 ? maxLength : 0) + 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
-            htmlErrMemory(ctxt);
-            return(NULL);
-        }
+        htmlErrMemory(ctxt);
+        return(NULL);
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -2837,28 +2837,34 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                input->cur += chunkSize;
+                size_t avail = buffer_size - used;
+                /* Rationale: Clip chunkSize to available buffer to prevent overflow */
+                size_t copySize = (chunkSize < avail) ? chunkSize : avail;
+                memcpy(buffer + used, chunk, copySize);
+                used += copySize;
+                if (copySize < (size_t)chunkSize) {
+                    htmlErrMemory(ctxt);
+                    goto error;
+                }
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
-
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
 
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                size_t avail2 = buffer_size - used;
+                /* Rationale: Clip replSize to available buffer to prevent overflow */
+                size_t copyRepl = (replSize < avail2) ? replSize : avail2;
+                memcpy(buffer + used, repl, copyRepl);
+                used += copyRepl;
+                if (copyRepl < (size_t)replSize) {
+                    htmlErrMemory(ctxt);
+                    goto error;
+                }
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
@@ -3322,28 +3328,28 @@ htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: allocate based on maxLength to prevent overflow
+if (buffer == NULL) {
+    buffer_size = (size_t)(maxLength > 0 ? maxLength : 0) + 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
-            htmlErrMemory(ctxt);
-            return(NULL);
-        }
+        htmlErrMemory(ctxt);
+        return(NULL);
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -3578,28 +3584,34 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                input->cur += chunkSize;
+                size_t avail = buffer_size - used;
+                /* Rationale: Clip chunkSize to available buffer to prevent overflow */
+                size_t copySize = (chunkSize < avail) ? chunkSize : avail;
+                memcpy(buffer + used, chunk, copySize);
+                used += copySize;
+                if (copySize < (size_t)chunkSize) {
+                    htmlErrMemory(ctxt);
+                    goto error;
+                }
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
-
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
 
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                size_t avail2 = buffer_size - used;
+                /* Rationale: Clip replSize to available buffer to prevent overflow */
+                size_t copyRepl = (replSize < avail2) ? replSize : avail2;
+                memcpy(buffer + used, repl, copyRepl);
+                used += copyRepl;
+                if (copyRepl < (size_t)replSize) {
+                    htmlErrMemory(ctxt);
+                    goto error;
+                }
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
