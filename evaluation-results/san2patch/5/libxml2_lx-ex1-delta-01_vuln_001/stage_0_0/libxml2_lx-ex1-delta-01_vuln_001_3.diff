diff --git a/HTMLparser.c b/HTMLparser.c
index 9c34e9e8..d724e5ce 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2604,28 +2604,40 @@ htmlParseData(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: allocate minimal then resize buffer to exact comment length
+if (buffer == NULL) {
+    buffer_size = 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
+        htmlErrMemory(ctxt);
+        return(NULL);
+    }
+    {
+        const xmlChar *start = input->cur;
+        size_t len = xmlStrlen(start);
+        xmlChar *tmp = xmlRealloc(buffer, len + 1);
+        if (tmp == NULL) {
+            xmlFree(buffer);
             htmlErrMemory(ctxt);
             return(NULL);
         }
+        buffer = tmp;
+        buffer_size = len + 1;
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -2837,28 +2849,41 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                input->cur += chunkSize;
+                if ((size_t)used + (size_t)chunkSize > buffer_size) {
+                    size_t new_buf_size = used + chunkSize + 1;
+                    /* Rationale: expand buffer to accommodate data */
+                    xmlChar *new_buf = xmlRealloc(buffer, new_buf_size);
+                    if (new_buf == NULL) {
+                        htmlErrMemory(ctxt);
+                        goto error;
+                    }
+                    buffer = new_buf;
+                    buffer_size = new_buf_size;
+                }
+                memcpy(buffer + used, chunk, chunkSize);
+                used += chunkSize;
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
 
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
-
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                if ((size_t)used + (size_t)replSize > buffer_size) {
+                    size_t new_buf_size2 = used + replSize + 1;
+                    xmlChar *new_buf2 = xmlRealloc(buffer, new_buf_size2);
+                    if (new_buf2 == NULL) {
+                        htmlErrMemory(ctxt);
+                        goto error;
+                    }
+                    buffer = new_buf2;
+                    buffer_size = new_buf_size2;
+                }
+                memcpy(buffer + used, repl, replSize);
+                used += replSize;
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
@@ -3322,28 +3347,40 @@ htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
     xmlChar *buffer;
     xmlChar utf8Char[4];
     size_t buffer_size;
-    size_t used;
-    int eof = PARSER_PROGRESSIVE(ctxt);
-    int line, col;
-    int termSkip = -1;
-
-    used = 0;
-    buffer_size = ctxt->spaceMax;
-    buffer = (xmlChar *) ctxt->spaceTab;
+size_t used;
+int eof = PARSER_PROGRESSIVE(ctxt);
+int line, col;
+int termSkip = -1;
+
+used = 0;
+buffer_size = ctxt->spaceMax;
+buffer = (xmlChar *) ctxt->spaceTab;
+// Rationale: allocate minimal then resize buffer to exact comment length
+if (buffer == NULL) {
+    buffer_size = 1;
+    buffer = xmlMalloc(buffer_size);
     if (buffer == NULL) {
-        buffer_size = 500;
-        buffer = xmlMalloc(buffer_size + 1);
-        if (buffer == NULL) {
+        htmlErrMemory(ctxt);
+        return(NULL);
+    }
+    {
+        const xmlChar *start = input->cur;
+        size_t len = xmlStrlen(start);
+        xmlChar *tmp = xmlRealloc(buffer, len + 1);
+        if (tmp == NULL) {
+            xmlFree(buffer);
             htmlErrMemory(ctxt);
             return(NULL);
         }
+        buffer = tmp;
+        buffer_size = len + 1;
     }
+}
 
-    line = input->line;
-    col = input->col;
+line = input->line;
+col = input->col;
 
-    while (!PARSER_STOPPED(ctxt)) {
-        const xmlChar *chunk, *in, *repl;
+while (!PARSER_STOPPED(ctxt)) {        const xmlChar *chunk, *in, *repl;
         size_t avail, chunkSize, extraSize;
         int replSize;
         int skip = 0;
@@ -3578,28 +3615,41 @@ next_chunk:
             size_t newSize = (used + extraSize) * 2;
             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
 
-            if (tmp == NULL) {
-                htmlErrMemory(ctxt);
-                goto error;
+            // FIXME: Crash CWE-787: Out-of-bounds Write
+            if (chunkSize > 0) {
+                input->cur += chunkSize;
+                if ((size_t)used + (size_t)chunkSize > buffer_size) {
+                    size_t new_buf_size = used + chunkSize + 1;
+                    /* Rationale: expand buffer to accommodate data */
+                    xmlChar *new_buf = xmlRealloc(buffer, new_buf_size);
+                    if (new_buf == NULL) {
+                        htmlErrMemory(ctxt);
+                        goto error;
+                    }
+                    buffer = new_buf;
+                    buffer_size = new_buf_size;
+                }
+                memcpy(buffer + used, chunk, chunkSize);
+                used += chunkSize;
             }
-            buffer = tmp;
-            buffer_size = newSize;
-        }
 
-        if (chunkSize > 0) {
-            input->cur += chunkSize;
-            memcpy(buffer + used, chunk, chunkSize);
-            used += chunkSize;
-        }
-
-        input->cur += skip;
-        if (replSize > 0) {
-            memcpy(buffer + used, repl, replSize);
-            used += replSize;
-        }
-
-        SHRINK;
+            input->cur += skip;
+            if (replSize > 0) {
+                if ((size_t)used + (size_t)replSize > buffer_size) {
+                    size_t new_buf_size2 = used + replSize + 1;
+                    xmlChar *new_buf2 = xmlRealloc(buffer, new_buf_size2);
+                    if (new_buf2 == NULL) {
+                        htmlErrMemory(ctxt);
+                        goto error;
+                    }
+                    buffer = new_buf2;
+                    buffer_size = new_buf_size2;
+                }
+                memcpy(buffer + used, repl, replSize);
+                used += replSize;
+            }
 
+            SHRINK;
         if (termSkip >= 0)
             break;
 
