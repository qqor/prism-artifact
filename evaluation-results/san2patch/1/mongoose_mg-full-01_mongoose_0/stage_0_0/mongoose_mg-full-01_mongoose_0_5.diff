diff --git a/src/json.c b/src/json.c
index cf6bc57b..b4437f24 100644
--- a/src/json.c
+++ b/src/json.c
@@ -16,6 +16,10 @@ static char json_esc(int c, int esc) {
 
 static int mg_pass_string(const char *s, int len) {
   int i;
+  /* Rationale: reject null pointers or non‚Äêpositive lengths to avoid unexpected behavior */
+  if (s == NULL || len <= 0) {
+    return MG_JSON_INVALID;
+  }
   for (i = 0; i < len; i++) {
     if (s[i] == '\\' && i + 1 < len && json_esc(s[i + 1], 1)) {
       i++;
@@ -173,7 +177,8 @@ int mg_json_get(struct mg_str json, const char *path, int *toklen) {
           expecting = S_KEY;
           break;
         } else if (c == '[') {
-          if (depth > MG_JSON_MAX_NESTING) return MG_JSON_TOO_DEEP;
+          /* Prevent depth from reaching or exceeding buffer size */
+          if (depth >= MG_JSON_MAX_NESTING) return MG_JSON_TOO_DEEP;
           if (depth == ed && path[pos] == '[' && ei == ci) {
             ed++, pos++, ci = 0;
             for (ei = 0; path[pos] != ']' && path[pos] != '\0'; pos++) {
@@ -181,7 +186,9 @@ int mg_json_get(struct mg_str json, const char *path, int *toklen) {
               ei += path[pos] - '0';
             }
             if (path[pos] != 0) pos++;
+// Fixed: removed unsafe write inside this block
           }
+          /* Safe because depth < MG_JSON_MAX_NESTING */
           nesting[depth++] = c;
           break;
         } else if (c == ']' && depth > 0) {  // Empty array
