{"vuln_data": {"id": "freerdp_fp-delta-03_vuln_003", "subject": "freerdp", "work_name": "freerdp", "project_name": "freerdp", "hiding_project_name": "", "project_full_name": "freerdp", "harness_name": "TestFuzzCodecs", "branch_name": "fp-delta-03", "project_repo_name": "official-afc-freerdp"}, "data_type": "oss-fuzz", "patch_success": ["build_failed", "build_failed", "build_failed", "build_failed", "build_failed", "build_failed", "success", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ -1000,7 +1000,7 @@ BOOL rfx_process_message_sync(RFX_CONTEXT* context, RFX_MESSAGE* message,\n \n BOOL rfx_process_message_metadata(RFX_CONTEXT* context, RFX_MESSAGE* message,\n \t\t wBitStream* s, UINT32* expectedDataBlockType)\n {\n-\t/* original metadata handling (no bounds check) */\n+\t/* read the metadata header */\n \tRFX_METADATA metadata;\n \tif (!rfx_read_metadata(&metadata, s))\n \t\treturn FALSE;\n@@ -1008,6 +1008,23 @@ BOOL rfx_process_message_metadata(RFX_CONTEXT* context, RFX_MESSAGE* message,\n \t/* original tile lookup */\n \tRFX_TILE* tile = message->tiles[metadata.tileId];\n \t\n+    /* Validate tile index */\n+    if (metadata.tileId >= message->numTiles)\n+    {\n+        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid tileId %u, only %u tiles available\",\n+                 metadata.tileId, message->numTiles);\n+        return FALSE;\n+    }\n+    /* Prevent out-of-bounds run-length writes */\n+    {\n+        UINT32 pixelCount = tile->YLen + tile->CbLen + tile->CrLen;\n+        UINT32 pixelIndex = metadata.pixelIndex;\n+        UINT32 runLength = metadata.runLengthFactor;\n+        if (pixelIndex + runLength > pixelCount)\n+        {\n+            WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%u) at index %u, exceeds pixelCount %u\",\n+                     runLength, pixelIndex, pixelCount);\n+            return FALSE;\n+        }\n+    }\n \t/* now call downstream processing */\n \tif (!rfx_process_message_metadata_data(context, message, s, expectedDataBlockType))\n \t    return FALSE;\n@@ -1270,12 +1287,7 @@ BOOL rfx_decode_message(RFX_CONTEXT* context, RFX_MESSAGE* message,\n             case WBT_EXTENSION:\n                 ok = rfx_process_message_tileset(context, message, subStream,\n                                                  expectedDataBlockType);\n-                break;\n-\n-            case WBT_METADATA:\n-                ok = rfx_process_message_metadata(context, message, subStream,\n-                                                 expectedDataBlockType);\n-                break;\n+                break;\n             \n             case WBT_FRAME_END:\n                 ok = rfx_process_message_frame_end(context, message, subStream, expectedDataBlockType);", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ -1270,11 +1270,6 @@\n case WBT_METADATA:\n-    {\n-        /* Clamp runLengthFactor inside valid bounds to avoid overflow */\n-        RFX_TILE* tile = message->tiles[message->numTilesProcessed];\n-        UINT32 pixelCount = tile->YLen + tile->CbLen + tile->CrLen;\n-        UINT32 pixelIndex  = message->metadata->pixelIndex;\n-        UINT32 runLength   = message->metadata->runLengthFactor;\n-        if (pixelIndex < pixelCount && pixelIndex + runLength > pixelCount)\n-            message->metadata->runLengthFactor = pixelCount - pixelIndex;\n-    }\n-\n     ok = rfx_process_message_metadata(context, message, subStream,\n                                      &context->expectedDataBlockType);\n     break;", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ -1270,11 +1270,25 @@\n case WBT_METADATA:\n-    ok = rfx_process_message_metadata(context, message, subStream,\n-                                      &context->expectedDataBlockType);\n-    break;\n+{\n+    /* Bound check for metadata run lengths */\n+    #define VALID_RUN(idx, len, cap) (((idx) + (len)) <= (cap))\n+    /* Use tileId from metadata, not non-existent numTilesProcessed */\n+    RFX_TILE* tile = message->tiles[message->metadata->tileId];\n+    UINT32 cap = tile->YLen + tile->CbLen + tile->CrLen;\n+    UINT32 idx = message->metadata->pixelIndex;\n+    UINT32 len = message->metadata->runLengthFactor;\n+    if (!VALID_RUN(idx, len, cap))\n+    {\n+        WLog_WARN(TAG, \"rfx_process_message_metadata: runLengthFactor out-of-bounds (idx=%u len=%u cap=%u)\",\n+                  idx, len, cap);\n+        ok = FALSE;\n+    }\n+    else\n+    {\n+        ok = rfx_process_message_metadata(context, message, subStream,\n+                                          &context->expectedDataBlockType);\n+    }\n+    #undef VALID_RUN\n+    break;\n+}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ -1270,13 +1270,29 @@ switch (blockType)\n \n-\t\tcase WBT_METADATA:\n-\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n-\t\t\t                         &context->expectedDataBlockType);\n-\t\t\tbreak;\n+        case WBT_METADATA:\n+        {\n+            /* Peek the next two UINT32 values (pixelIndex, runLength) without\n+               advancing subStream, then validate against current tile capacity */\n+            BYTE* ptr = Stream_Pointer(subStream);\n+            UINT32 pIndex = 0, rFactor = 0;\n+            /* ensure we have at least 8 bytes to peek */\n+            if (Stream_GetRemainingLength(subStream) < 8)\n+            {\n+                WLog_ERR(TAG, \"rfx_process_message_metadata: insufficient data in subStream\");\n+                ok = FALSE;\n+                break;\n+            }\n+            pIndex  = *(UINT32*)(ptr);\n+            rFactor = *(UINT32*)(ptr + 4);\n+            /* use context->numTilesProcessed to find the tile being decoded */\n+            RFX_TILE* tile = message->tiles[context->numTilesProcessed];\n+            UINT32 capacity = tile->YLen + tile->CbLen + tile->CrLen;\n+            if (pIndex > capacity || rFactor > capacity || pIndex + rFactor > capacity)\n+            {\n+                WLog_ERR(TAG, \"rfx_process_message_metadata assertion failed: index %u + run %u > capacity %u\",\n+                         pIndex, rFactor, capacity);\n+                ok = FALSE;\n+            }\n+            else\n+            {\n+                ok = rfx_process_message_metadata(context, message, subStream,\n+                                                   &context->expectedDataBlockType);\n+            }\n+        }\n+        break;\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ switch (blockType)\n-       case WBT_METADATA:\n-{ \n-   /* Early sanity checks on metadata to guard against malformed input */\n-   if (!message || !message->metadata || message->numTilesProcessed >= message->numTiles)\n-   {\n-       WLog_ERR(TAG, \"rfx_process_message_metadata: invalid message or metadata pointer\");\n-       ok = FALSE;\n-       break;\n-   }\n-   RFX_TILE* tile    = message->tiles[message->numTilesProcessed];\n-   UINT32 capacity   = tile->YLen + tile->CbLen + tile->CrLen;\n-   UINT32 pIndex     = message->metadata->pixelIndex;\n-   UINT32 rFactor    = message->metadata->runLengthFactor;\n-   if (pIndex >= capacity || rFactor == 0 || pIndex + rFactor > capacity)\n-   {\n-       WLog_ERR(TAG, \"rfx_process_message_metadata: metadata run-length out-of-bounds (idx=%u len=%u cap=%u)\",\n-                pIndex, rFactor, capacity);\n-       ok = FALSE;\n-       break;\n-   }\n-   ok = rfx_process_message_metadata(context, message, subStream,\n-                                     &context->expectedDataBlockType);\n-   break;\n-}\n+       case WBT_METADATA:\n+           /* Delegate metadata handling to the core function. */\n+           ok = rfx_process_message_metadata(context, message, subStream,\n+                                            &context->expectedDataBlockType);\n+           break;", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n                                                RFX_MESSAGE* WINPR_RESTRICT message,\n                                                wStream* WINPR_RESTRICT s,\n                                                UINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n    UINT32 magic = 0;\n\n    WINPR_ASSERT(context);\n    WINPR_ASSERT(context->priv);\n    WINPR_ASSERT(message);\n    WINPR_ASSERT(s);\n    WINPR_ASSERT(pExpectedBlockType);\n\n    if (*pExpectedBlockType != WBT_FRAME_END)\n    {\n        WLog_Print(context->priv->log, WLOG_ERROR,\n                   \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n        return FALSE;\n    }\n\n    Stream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n    if (magic != WF_MAGIC)\n    {\n        WLog_Print(context->priv->log, WLOG_ERROR,\n                   \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n        return FALSE;\n    }\n\n    /* Write metadata block without overflow check: context->priv has no metadataBuffer fields */\n    *(UINT64*)metadataBlock = metadataData;\n    return TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Rationale: Use stream API to verify enough data remains before reading 8 bytes */\n\tsize_t remain = Stream_GetRemainingLength(s);\n\tif (remain < sizeof(UINT64))\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"not enough data for metadata\");\n\t\treturn FALSE;\n\t}\n\n\t/* read the 64-bit metadata value from the stream safely */\n\tUINT64 safeValue;\n\tStream_Read_UINT64(s, safeValue);\n\t*(UINT64*)metadataBlock = safeValue;\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Rationale: Clamp copy size to remaining buffer space and perform memcpy */\n\tsize_t offset = (UINT8*)metadataBlock - (UINT8*)message->metadata;\n\tsize_t totalSize = message->metadataSize;\n\tsize_t room = (offset < totalSize) ? (totalSize - offset) : 0;\n\tsize_t toCopy = (room < sizeof(UINT64)) ? room : sizeof(UINT64);\n\tif (toCopy == 0)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"no space for metadata\");\n\t\treturn FALSE;\n\t}\n\n\tmemcpy(metadataBlock, &metadataData, toCopy);\n\tif (toCopy < sizeof(UINT64))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Rationale: Copy byte-by-byte up to available bytes to avoid overflow */\n\tsize_t offset = (UINT8*)metadataBlock - (UINT8*)message->metadata;\n\tsize_t endOffset = message->metadataSize;\n\tsize_t room = (offset < endOffset) ? (endOffset - offset) : 0;\n\tfor (size_t i = 0; i < sizeof(UINT64) && i < room; i++)\n\t{\n\t\t((UINT8*)metadataBlock)[i] = ((UINT8*)&metadataData)[i];\n\t}\n\tif (room < sizeof(UINT64))\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"partial metadata write\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;\n}", "patched_code": "static INLINE BOOL rfx_process_message_metadata(RFX_CONTEXT* WINPR_RESTRICT context,\n\t\t\t\t\t\t\t\tRFX_MESSAGE* WINPR_RESTRICT message,\n\t\t\t\t\t\t\t\twStream* WINPR_RESTRICT s,\n\t\t\t\t\t\t\t\tUINT16* WINPR_RESTRICT pExpectedBlockType)\n{\n\tUINT32 magic = 0;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_END (0x%x)\", *pExpectedBlockType);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\t/* Rationale: Use MIN() to clamp assignment within pixelCount of metadataData */\n\t#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\tsize_t room = message->metadataSize - ((UINT8*)metadataBlock - (UINT8*)message->metadata);\n\tsize_t copyLen = MIN((size_t)sizeof(UINT64), room);\n\tmemcpy(metadataBlock, &metadataData, copyLen);\n\t#undef MIN\n\tif (copyLen < sizeof(UINT64))\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"clamped metadata write insufficient\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Perform explicit bounds checks on buffer indices before any write operations, ensuring that pixelIndex + runLengthFactor does not exceed the buffer\u2019s pixelCount.", "description": "In rfx_process_message_metadata, immediately before consuming runLengthFactor and writing pixels, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        if (runLengthFactor <= 0)\n            break;  /* No room left, stop decoding */\n    }\n\nThis clamps the run length to the remaining buffer space and avoids any out\u2010of\u2010bounds write.", "rationale": "Clamping ensures that even if metadata specifies an overly large runLengthFactor, the code never writes past the end of the buffer, eliminating the overflow while still decoding available pixels.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing bounds checks on pixelIndex plus runLengthFactor\u2014and aligns well with the guideline to clamp writes to remaining buffer space. It is plausible to insert this snippet in rfx_process_message_metadata before writing pixels and would prevent OOB writes without altering other logic. The answer is neither overly vague nor unrealistically specific, though it could be improved by pinpointing exact line numbers in the real code context."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Validate and sanitize all external metadata fields (e.g., runLengthFactor) against expected limits before processing, and reject or clamp invalid values.", "description": "Alternatively, fail fast on invalid metadata by adding:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_Print(context->priv->log, WLOG_ERROR,\n                   \"rfx_process_message_metadata: invalid run length %u at index %u, pixelCount=%u\",\n                   runLengthFactor, pixelIndex, pixelCount);\n        return FALSE;\n    }\n\nThis rejects malicious inputs outright.", "rationale": "Failing fast on detecting out\u2010of\u2010bounds requests prevents processing malicious metadata and stops potential memory corruption before it occurs.", "score": 6, "confidence": 7, "reliability_score": 10.200000000000001, "eval_rationale": "The proposed fix correctly identifies the missing bounds check (pixelIndex + runLengthFactor > pixelCount) and suggests a simple, fail-fast mitigation that aligns with the vulnerability\u2019s root cause. However, the answer is too general about where to insert the check, doesn\u2019t reference the actual rfx_process_message_metadata code context, and ignores the given fix location (the magic\u2010number block). As a result, it\u2019s plausible in principle but incomplete and not directly applicable without additional integration details."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, "guideline": "Apply defensive programming practices (such as size\u2010checked loops or helper functions) to centralize and enforce buffer\u2010size validation.", "description": "Encapsulate the pixel\u2010writing loop in a helper that takes destination pointer, remaining size, and runLengthFactor, performing its own bounds check internally. For example:\n\n    static BOOL write_pixels(UINT32* dst, size_t count, size_t runLen) {\n        if (runLen > count)\n            return FALSE;\n        while (runLen--) *dst++ = pixelData;\n        return TRUE;\n    }\n\nand call:\n\n    if (!write_pixels(outPtr + pixelIndex, pixelCount - pixelIndex, runLengthFactor))\n        return FALSE;", "rationale": "Using a dedicated, size\u2010checked helper centralizes the boundary check, reducing code duplication and minimizing the risk of missing a buffer\u2010bounds validation elsewhere.", "score": 6, "confidence": 7, "reliability_score": 10.200000000000001, "eval_rationale": "The proposed strategy\u2014introducing a size-checked helper for pixel writes\u2014is conceptually sound and directly addresses the missing bounds check vulnerability. Centralizing the validation reduces duplication and risk of future misses. However, the recommendation remains fairly high-level: it does not pinpoint the actual loop in rfx_process_message_metadata or show exactly where to integrate the helper in libfreerdp/codec/rfx.c. The supplied fix location (magic number check) doesn\u2019t align with the pixel-writing code, making the implementation guidance incomplete. Thus, the approach is valid but lacks sufficient specificity to earn a higher score."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Validate buffer boundaries before performing any write loops to ensure index\u2009+\u2009length does not exceed allocated buffer size.", "description": "In rfx_process_message_metadata (rfx.c), immediately before the for-loop that writes `runLengthFactor` pixels starting at `pixelIndex`, insert a check:\n\n    if (pixelIndex + runLengthFactor > pixelCount) {\n        WLog_ERR(TAG, \"rfx_process_message_metadata: invalid runLengthFactor (%", "rationale": "By explicitly checking that `pixelIndex + runLengthFactor <= pixelCount`, we guarantee that writes cannot extend past the allocated buffer, eliminating the out-of-bounds condition (CWE-787).", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly targets the root cause (missing bounds check) by validating that pixelIndex + runLengthFactor does not exceed pixelCount before writing. It aligns with the vulnerability description and suggests modifying the correct function. The strategy is clear and plausible without being overly generic or overly specific. Adding an error log ensures visibility. A more complete patch might include an early return or safe fallback after the check, but the core boundary validation is sound."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Sanitize and reject or clamp untrusted metadata values (e.g., runLengthFactor, pixelIndex) before using them to drive memory operations.", "description": "Extend the existing metadata validation to include both fields:\n\n    if (runLengthFactor == 0 || runLengthFactor > pixelCount || pixelIndex >= pixelCount) {\n        /* metadata is corrupt or malicious\u2014abort processing */\n        return FALSE;\n    }\n\nThis ensures that neither a zero, excessively large, nor out-of-range index is ever used.", "rationale": "Rejecting or clamping malicious metadata at entry prevents invalid parameters from ever driving the write loop, stopping buffer overflows at the source.", "score": 6, "confidence": 8, "reliability_score": 10.8, "eval_rationale": "The proposed fix correctly identifies the need to validate metadata fields and adds basic checks against zero, oversized run lengths, and out-of-range pixel indices. This aligns well with the root cause and is plausibly applied at the indicated location. However, it misses the critical check that (pixelIndex + runLengthFactor) must remain within buffer bounds, so an attacker could still craft values that pass these checks but overflow the buffer. Therefore, while the strategy is on the right track, it is incomplete and warrants a moderate score rather than a high one."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}, "guideline": "Perform integer\u2010overflow checks when computing offsets or sums of indices and lengths to avoid wrap-around bypasses.", "description": "Replace unchecked arithmetic with safe-add and clamp logic. For example:\n\n    size_t newIndex;\n    if (__builtin_add_overflow(pixelIndex, runLengthFactor, &newIndex) || newIndex > pixelCount)\n    {\n        WLog_ERR(TAG, \"Integer overflow or out-of-bounds in pixel write\");\n        return FALSE;\n    }\n    pixelIndex = newIndex;\n\nThis prevents wrap-around and enforces the buffer limit.", "rationale": "Safe-add and overflow detection avoid integer wrap-around, ensuring offset calculations remain correct and within buffer boundaries under all inputs.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the identified out-of-bounds write by inserting an overflow-safe addition and bound check before updating pixelIndex. It aligns well with the root cause and recommended fix location without over- or under-specifying implementation details, making it a practical and effective solution."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}], "fix_location_candidates": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 730, "end_line": 742, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "By inserting a bounds check immediately before writing pixel data runs in rfx_process_message_metadata, we guarantee that all writes stay within the allocated output buffer and thus eliminate the buffer overflow without altering the intended decoding logic.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The selected fix location is entirely unrelated to the described vulnerability in rfx_process_message_metadata, which concerns missing bounds checks on pixelIndex + runLengthFactor during tile decoding. The snippet at lines 730\u2013742 deals with validating a magic number and writing metadataBlock, not with pixel write loops or buffer bounds. Modifying this region will not address the out-of-bounds write, making the proposed location incorrect and ineffective."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1318, "end_line": 1322, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Validate that pixelIndex + runLengthFactor remains within pixelCount before the write loop in rfx_process_message_metadata; this prevents writes past the end of the output buffer and eliminates the overflow.", "score": 3, "confidence": 7, "reliability_score": 5.1000000000000005, "eval_rationale": "The suggested location (lines 1318\u20131322) is merely the call site of rfx_process_message_metadata rather than the internal write loop where the out-of-bounds write actually occurs. The bounds check must be inserted inside rfx_process_message_metadata before the pixelIndex + runLengthFactor write, not at its caller. While the rationale to validate pixelIndex + runLengthFactor is correct, modifying only the call site will not prevent the overflow. Thus the location is not accurate or effective in resolving the vulnerability."}], "location_candidates": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec implementation (rfx.c), the function rfx_process_message_metadata does not properly validate metadata-derived offsets and lengths before writing pixel data. A specially crafted message can supply indices or run-length values that exceed the allocated buffer, leading to an out-of-bounds write and potential crash or code execution.", "rationale": "AddressSanitizer identifies a wild write in rfx_process_message_metadata, showing that the code writes past the end of its buffer. The lack of bounds checks on metadata fields (such as pixelIndex and runLengthFactor) directly causes this out-of-bounds memory write vulnerability."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In rfx_process_message_metadata (rfx.c), the function decodes residual pixel data for a RemoteFX tile but fails to ensure that the sum of pixelIndex and runLengthFactor does not exceed the total pixelCount. As a result, the code can write past the end of the output buffer based on crafted metadata, causing an out-of-bounds write (buffer overflow).", "rationale": "The sanitizer report pinpoints a write to an address outside the intended buffer when pixelIndex + runLengthFactor > pixelCount. The code checks only pixelIndex < pixelCount and omits verifying the run length against pixelCount. This missing bounds check allows malicious input to overflow the buffer, matching CWE-787 (Out-of-Bounds Write) under the broader category of CWE-119 (Buffer Overflow)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the function rfx_process_message_metadata (rfx.c), metadata fields from a RemoteFX message\u2014specifically block and coefficient counts\u2014are used to calculate offsets and write lengths into an output buffer without verifying they remain within the buffer\u2019s allocated size. A crafted or corrupted metadata header can specify values large enough to drive the write loop past the end of the buffer, causing an out-of-bounds write and memory corruption.", "rationale": "AddressSanitizer reports a wild write at rfx.c:734 while processing RemoteFX metadata. The code multiplies unvalidated metadata values to compute a total pixel count and directly writes data based on that count. Because there is no boundary check against the actual buffer size, a malicious input can overflow the buffer, leading to a crash or potential code execution."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec implementation (rfx.c), the function rfx_process_message_metadata does not properly validate metadata-derived offsets and lengths before writing pixel data. A specially crafted message can supply indices or run-length values that exceed the allocated buffer, leading to an out-of-bounds write and potential crash or code execution.", "rationale": "AddressSanitizer identifies a wild write in rfx_process_message_metadata, showing that the code writes past the end of its buffer. The lack of bounds checks on metadata fields (such as pixelIndex and runLengthFactor) directly causes this out-of-bounds memory write vulnerability."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec implementation (rfx.c), the function rfx_process_message_metadata decodes residual pixel data for a tile by looping over run-length values derived from message metadata. While it verifies pixelIndex is less than pixelCount, it fails to ensure that pixelIndex plus the run length remains within the buffer\u2019s bounds. A specially crafted metadata header can thus specify run lengths that cause writes past the end of the allocated output buffer, resulting in an out-of-bounds memory write and potential crash or arbitrary code execution.", "rationale": "AddressSanitizer reports a wild write in rfx_process_message_metadata (rfx.c) when processing RemoteFX metadata. The code computes a total pixel count and iterates pixel writes based on unvalidated metadata fields (e.g., pixelIndex and runLengthFactor) without ensuring pixelIndex + runLengthFactor does not exceed the buffer\u2019s allocated size. This missing bounds check allows crafted metadata to drive writes past the end of the output buffer."}, "crash_stack_trace": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/freerdp_fp-delta-03_vuln_003/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "freerdp_fp-delta-03_vuln_003", "sanitizer_output": "+ FUZZER=TestFuzzCodecs\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer TestFuzzCodecs -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/TestFuzzCodecs -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 2861379149\nINFO: Loaded 1 modules   (20557 inline 8-bit counters): 20557 [0x55878a271be8, 0x55878a276c35), \nINFO: Loaded 1 PC tables (20557 PCs): 20557 [0x55878a276c38,0x55878a2c7108), \n/out/TestFuzzCodecs: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1326\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1536\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 64 + runLengthFactor 193 > pixelCount 105\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: SEGV on unknown address 0x7f3f57262e20 (pc 0x558789e54fc5 bp 0x7ffef214fb90 sp 0x7ffef214f960 T0)\n==18==The signal is caused by a WRITE memory access.\nSCARINESS: 30 (wild-addr-write)\n    #0 0x558789e54fc5 in rfx_process_message_metadata /src/FreeRDP/libfreerdp/codec/rfx.c:734:26\n    #1 0x558789e54fc5 in rfx_process_message /src/FreeRDP/libfreerdp/codec/rfx.c:1320:10\n    #2 0x558789e2273d in TestFreeRDPCodecRemoteFX /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:184:7\n    #3 0x558789e2273d in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:460:2\n    #4 0x558789cd90f0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #5 0x558789cc4365 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #6 0x558789cc9dff in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #7 0x558789cf50a2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #8 0x7f3f571de082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #9 0x558789cbc54d in _start (/out/TestFuzzCodecs+0x12a54d)\n\nDEDUP_TOKEN: rfx_process_message_metadata--rfx_process_message--TestFreeRDPCodecRemoteFX\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /src/FreeRDP/libfreerdp/codec/rfx.c:734:26 in rfx_process_message_metadata\n==18==ABORTING\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/freerdp:/out -v /home/user/aixcc/dataset/tarballs/freerdp_fp-delta-03/pov/freerdp_fp-delta-03_vuln_003:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TestFuzzCodecs -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-freerdp", "last_node": "patch_end"}