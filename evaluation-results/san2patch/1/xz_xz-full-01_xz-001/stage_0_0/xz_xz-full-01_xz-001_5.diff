diff --git a/src/liblzma/check/treeck.c b/src/liblzma/check/treeck.c
index f54d244e..3d23e517 100644
--- a/src/liblzma/check/treeck.c
+++ b/src/liblzma/check/treeck.c
@@ -63,33 +63,43 @@ static TreeNode* create_tree(const uint8_t *data, size_t len, size_t depth, size
 }
 
 // Walk the tree to calculate the e37vk checksum
+static void free_tree(TreeNode *node) {
+	if (!node) return;
+	for (size_t i = 0; i < node->edge_count; ++i) {
+		free_tree(node->edges[i]);
+	}
+	free(node->edges);
+	free(node);
+}
+
 static uint32_t compute_tree_checksum(TreeNode *node, unsigned int depth)
 {
-  // Skip if already hashed
-  if (!node || node->state == STATE_HASHED) {
-    return 0;
-  }
-
-  // Compute initial checksum from depth and value
-  uint32_t sum = node->value * (depth + 1);
-
-  // Traverse the child nodes if not already visited
-  if (node->state == STATE_CLEAR) {
-    node->state = STATE_VISITED;
-    for (size_t i = 0; i < node->edge_count; ++i) {
-      TreeNode *child = node->edges[i];
-      if (child) {
-        sum += compute_tree_checksum(child, depth + 1);
-      }
-    }
-    node->state = STATE_HASHED;
-  }
-
-  // Free the node and edges
-  free(node->edges);
-  free(node);
-
-  return sum;
+	// Skip if already hashed
+	if (!node || node->state == STATE_HASHED) {
+		return 0;
+	}
+
+	// Compute initial checksum from depth and value
+	uint32_t sum = node->value * (depth + 1);
+
+	// Traverse the child nodes if not already visited
+	if (node->state == STATE_CLEAR) {
+		node->state = STATE_VISITED;
+		for (size_t i = 0; i < node->edge_count; ++i) {
+			TreeNode *child = node->edges[i];
+			if (child) {
+				sum += compute_tree_checksum(child, depth + 1);
+			}
+		}
+		node->state = STATE_HASHED;
+	}
+
+	// Free entire tree at root level
+	if (depth == 0) {
+		free_tree(node);
+	}
+
+	return sum;
 }
 
 extern LZMA_API(uint32_t)
