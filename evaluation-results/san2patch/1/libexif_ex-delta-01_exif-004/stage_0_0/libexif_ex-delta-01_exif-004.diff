diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
index 83a9cb1..8ecdaf9 100644
--- a/libexif/apple/exif-mnote-data-apple.c
+++ b/libexif/apple/exif-mnote-data-apple.c
@@ -106,7 +106,8 @@ exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned
         return;
     }
 
-    for (i = 0; i < tcount; i++) {
+    /* Rationale: Ensure that the copy does not read past the end of the source buffer by validating that dofs + dsize is within buf_size */
+for (i = 0; i < tcount; i++) {
         d->entries[i].tag = exif_get_short(buf + ofs, d->order);
         d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);
         d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);
@@ -117,11 +118,13 @@ exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned
         } else {
             dofs = ofs + 8;
         }
-	if (dofs > buf_size) {
-		exif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,
-                                  "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", dofs, buf_size);
-		continue;
-	}
+        /* Combined bounds check: start offset and end offset must both lie within buf_size */
+        if (dofs > buf_size || dofs + dsize > buf_size) {
+            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                     "ExifMnoteApple", "Tag size overflow detected (offset %u, size %u, buf size %u)",
+                     dofs, dsize, buf_size);
+            continue;
+        }
         ofs += 12;
         d->entries[i].data = exif_mem_alloc(md->mem, dsize);
         if (!d->entries[i].data) {
