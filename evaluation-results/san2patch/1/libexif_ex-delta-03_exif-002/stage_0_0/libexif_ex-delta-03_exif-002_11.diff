diff --git a/libexif/exif-data.c b/libexif/exif-data.c
index f3f6dbc..ff5ac3d 100644
--- a/libexif/exif-data.c
+++ b/libexif/exif-data.c
@@ -444,96 +444,42 @@ exif_data_load_data_content (ExifData *data, ExifIfd ifd,
 
 		tag = exif_get_short (d + offset + 12 * i, data->priv->order);
 		switch (tag) {
-		case EXIF_TAG_EXIF_IFD_POINTER:
-		case EXIF_TAG_GPS_INFO_IFD_POINTER:
-		case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:
-		case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:
-		case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:
-			o = exif_get_long (d + offset + 12 * i + 8,
-					   data->priv->order);
-			if (o >= ds) {
-				exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, "ExifData",
-					  "Tag data past end of buffer (%u > %u)", offset+2, ds);
-				return;
-			}
-			/* FIXME: IFD_POINTER tags aren't marked as being in a
-			 * specific IFD, so exif_tag_get_name_in_ifd won't work
-			 */
-			exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-				  "Sub-IFD entry 0x%x ('%s') at %u.", tag,
-				  exif_tag_get_name(tag), o);
-			switch (tag) {
-			case EXIF_TAG_EXIF_IFD_POINTER:
-				CHECK_REC (EXIF_IFD_EXIF);
-				exif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,
-					recursion_cost + level_cost(n));
-				break;
-			case EXIF_TAG_GPS_INFO_IFD_POINTER:
-				CHECK_REC (EXIF_IFD_GPS);
-				exif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,
-					recursion_cost + level_cost(n));
-				break;
-			case EXIF_TAG_INTEROPERABILITY_IFD_POINTER:
-				CHECK_REC (EXIF_IFD_INTEROPERABILITY);
-				exif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,
-					recursion_cost + level_cost(n));
-				break;
-			case EXIF_TAG_JPEG_INTERCHANGE_FORMAT:
-				thumbnail_offset = o;
-				if (thumbnail_offset && thumbnail_length)
-					exif_data_load_data_thumbnail (data, d,
-								       ds, thumbnail_offset,
-								       thumbnail_length);
+	â€¦
+	default:
+
+		/* Keep unknown-tag logic as before */
+		if (!exif_tag_get_name_in_ifd (tag, ifd)) {
+			if (!memcmp (d + offset + 12 * i, "\0\0\0\0", 4)) {
+				exif_log (...);
 				break;
-			case EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:
-				thumbnail_length = o;
-				if (thumbnail_offset && thumbnail_length)
-					exif_data_load_data_thumbnail (data, d,
-								       ds, thumbnail_offset,
-								       thumbnail_length);
+			}
+			exif_log (...);
+			if (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)
 				break;
-			default:
+		}
+
+		/* Minimal bounds check: ensure entry record fits */
+		{
+			unsigned int entry_offset = offset + 12 * i;
+			/* We need at least 12 bytes for the entry tag+format+components+value/offset */
+			if (entry_offset + 12 > ds) {
+				exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, "ExifData",
+				  "Entry past end of buffer (%u > %u)", entry_offset + 12, ds);
 				return;
 			}
-			break;
-		default:
-
-			/*
-			 * If we don't know the tag, don't fail. It could be that new 
-			 * versions of the standard have defined additional tags. Note that
-			 * 0 is a valid tag in the GPS IFD.
-			 */
-			if (!exif_tag_get_name_in_ifd (tag, ifd)) {
+		}
 
-				/*
-				 * Special case: Tag and format 0. That's against specification
-				 * (at least up to 2.2). But Photoshop writes it anyways.
-				 */
-				if (!memcmp (d + offset + 12 * i, "\0\0\0\0", 4)) {
-					exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-						  "Skipping empty entry at position %u in '%s'.", i, 
-						  exif_ifd_get_name (ifd));
-					break;
-				}
-				exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, "ExifData",
-					  "Unknown tag 0x%04x (entry %u in '%s'). Please report this tag "
-					  "to <libexif-devel@lists.sourceforge.net>.", tag, i,
-					  exif_ifd_get_name (ifd));
-				if (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)
-					break;
-			}
-			entry = exif_entry_new_mem (data->priv->mem);
-			if (!entry) {
-				  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, "ExifData",
-                                          "Could not allocate memory");
-				  return;
-			}
-			if (exif_data_load_data_entry (data, entry, d, ds,
-						   offset + 12 * i))
-				exif_content_add_entry (data->ifd[ifd], entry);
-			exif_entry_unref (entry);
-			break;
+		entry = exif_entry_new_mem (data->priv->mem);
+		if (!entry) {
+			exif_log (...);
+			return;
 		}
+		if (exif_data_load_data_entry (data, entry, d, ds,
+			   offset + 12 * i))
+			exif_content_add_entry (...);
+		exif_entry_unref (entry);
+		break;
+}
 	}
 }
 
