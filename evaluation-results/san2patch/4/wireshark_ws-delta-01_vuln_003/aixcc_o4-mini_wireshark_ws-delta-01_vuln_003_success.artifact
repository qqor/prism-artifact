{"vuln_data": {"id": "wireshark_ws-delta-01_vuln_003", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_ber", "branch_name": "ws-delta-01", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["success", "", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n\ttvbuff_t *out_tvb = NULL;\n\tint8_t  tvb_len;\n\n\toffset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n\tif (name_string) {\n\t\tif (out_tvb) {\n\t\t\t/* Rationale: compute a safe copy length <= name_len-1 to avoid overflow */\n\t\t\ttvb_len = tvb_get_uint8(tvb, offset);\n\t\t\tunsigned copy_len = (unsigned)tvb_len < name_len ? (unsigned)tvb_len : name_len - 1;\n\t\t\ttvb_memcpy(out_tvb, (uint8_t*)name_string, 0, copy_len);\n\t\t\tname_string[copy_len] = '\\0';\n\t\t}\n\t}\n\n\treturn offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n\ttvbuff_t *out_tvb = NULL;\n\tint8_t  tvb_len;\n\n\toffset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n\tif (name_string) {\n\t\tif (out_tvb) {\n\t\t\t/* Rationale: bail out on oversized BER string to prevent any write */\n\t\t\ttvb_len = tvb_get_uint8(tvb, offset);\n\t\t\tif ((unsigned)tvb_len >= name_len) {\n\t\t\t\texpert_add_info(actx->pinfo, NULL, &ei_malformed_string);\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t\ttvb_memcpy(out_tvb, (uint8_t*)name_string, 0, (unsigned)tvb_len);\n\t\t\tname_string[(unsigned)tvb_len] = '\\0';\n\t\t}\n\t}\n\n\treturn offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n\ttvbuff_t *out_tvb = NULL;\n\tint8_t  tvb_len;\n\n\toffset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n\tif (name_string) {\n\t\tif (out_tvb) {\n\t\t\t/* Rationale: zero buffer first, then copy up to safe limit and rely on initial nulls */\n\t\t\tmemset(name_string, 0, name_len);\n\t\t\ttvb_len = tvb_get_uint8(tvb, offset);\n\t\t\tunsigned copy_len = (unsigned)tvb_len < name_len ? (unsigned)tvb_len : name_len - 1;\n\t\t\ttvb_memcpy(out_tvb, (uint8_t*)name_string, 0, copy_len);\n\t\t\t/* name_string is already null-terminated by memset */\n\t\t}\n\t}\n\n\treturn offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n\ttvbuff_t *out_tvb = NULL;\n\tint8_t  tvb_len;\n\n\toffset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n\tif (name_string) {\n\t\tif (out_tvb) {\n\t\t\t/* Rationale: always truncate and place terminator at the last byte */\n\t\t\ttvb_len = tvb_get_uint8(tvb, offset);\n\t\t\tif ((unsigned)tvb_len >= name_len) {\n\t\t\t\ttvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len - 1);\n\t\t\t\tname_string[name_len - 1] = '\\0';\n\t\t\t} else {\n\t\t\t\ttvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n\t\t\t\tname_string[tvb_len] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n    tvbuff_t *out_tvb = NULL;\n    int8_t  tvb_len;\n\n    offset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n    if (name_string) {\n        /*\n         * XXX - do we want to just get what's left in the tvbuff\n         * if the full length isn't available in the tvbuff, or\n         * do we want to throw an exception?\n         */\n        if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }\n    }\n\n    return offset;\n}", "patched_code": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)\n{\n\ttvbuff_t *out_tvb = NULL;\n\tint8_t  tvb_len;\n\n\toffset = dissect_ber_restricted_string(false, BER_UNI_TAG_GeneralString, actx, tree, tvb, offset, hf_id, (name_string) ? &out_tvb : NULL);\n\n\tif (name_string) {\n\t\tif (out_tvb) {\n\t\t\t/* Rationale: use tvb_get_ptr + memcpy to avoid tvb_len > name_len */\n\t\t\ttvb_len = tvb_get_uint8(tvb, offset);\n\t\t\tunsigned raw_len = (unsigned)tvb_len;\n\t\t\tunsigned copy_len = raw_len < name_len ? raw_len : name_len - 1;\n\t\t\tconst guint8 *data = tvb_get_ptr(out_tvb, 0, copy_len);\n\t\t\tmemcpy(name_string, data, copy_len);\n\t\t\tname_string[copy_len] = '\\0';\n\t\t}\n\t}\n\n\treturn offset;\n}", "func_def": "int\n// NOLINTNEXTLINE(misc-no-recursion)\ndissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, int hf_id, char *name_string, unsigned name_len)", "func_ret": ["return offset;"]}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, {"fix_location": {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}, "guideline": "Validate all externally-controlled length or size fields against the capacity of your buffers before copying or writing data (CWE-120, CERT STR30-C).", "description": "In dissect_ber_GeneralString, immediately after reading the length from the BER header, insert a check: if (length + 1 > sizeof(name_string)) return an error (or truncate) rather than proceeding to memcpy.", "rationale": "By checking (length + 1) <= sizeof(name_string) up front, we prevent any write past the end of the local array, eliminating the out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the identified one-byte out-of-bounds write by validating the BER string length against the fixed buffer size before copying. It aligns with CWE-120 and CERT STR30-C guidelines, pinpoints the correct location in dissect_ber_GeneralString, and offers a clear error/truncate path. The strategy is neither too vague nor unrealistically detailed, making it both practical and secure."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Always validate and clamp the incoming length against the actual buffer size before any copy or write operations to prevent out-of-bounds writes (CWE-787).", "description": "Clamp the parsed tvb_len to at most name_len - 1 before performing memcpy and null-termination. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len > name_len - 1) {\n        tvb_len = name_len - 1;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "By clamping tvb_len to name_len - 1, we ensure that the subsequent memcpy and null-termination cannot write beyond the end of name_string, directly eliminating the off-by-one overflow.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly identifies and addresses the off-by-one buffer overflow by clamping `tvb_len` to `name_len - 1` before the memcpy and null termination. It aligns well with the vulnerability root cause and the fixing guideline, and the strategy is directly applicable to the specified code region without overgeneralizing or hallucinating implementation details. The answer strikes a good balance in specificity and practicality, making it a solid remediation approach."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Prefer using safe string or buffer copy routines (e.g., strlcpy, strncpy_s, or g_strlcpy) that enforce a maximum length and automatically null-terminate.", "description": "Replace the manual memcpy + null write with a single safe copy call that both limits length and null-terminates. For example, using g_strlcpy:\n\n    const uint8_t *src = tvb_get_ptr(tvb, offset, length);\n    g_strlcpy(name_string, (const char *)src, name_len);\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, strlen(name_string));", "rationale": "Safe copy functions like g_strlcpy enforce a maximum buffer size and guarantee null-termination, reducing manual errors and preventing both overruns and missing terminators.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the out-of-bounds write by replacing manual memcpy and null-termination with a single safe copy routine (g_strlcpy), ensuring the buffer can\u2019t overflow and is always null-terminated. It aligns well with the recommended fix location and vulnerability root cause, is practical to implement, and avoids unnecessary over-specificity. There are no obvious hallucinations, and the approach is both robust and concise."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, "guideline": "Implement an explicit boundary check and fail\u2010safe path when the parsed length exceeds the buffer capacity, returning an error or truncating safely as appropriate.", "description": "Add an explicit check before any copy to bail out or log an error if the BER string length exceeds the buffer. For example:\n\n    tvb_len = tvb_get_uint8(tvb, offset);\n    if (tvb_len >= name_len) {\n        /* length too large, drop or mark as malformed */\n        expert_add_info(pinfo, NULL, &ei_malformed_string);\n        return;\n    }\n    tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n    name_string[tvb_len] = '\\0';", "rationale": "An explicit bounds check with a fail\u2010safe path on oversize input prevents processing of malformed data altogether, ensuring that the buffer is never overflowed and that error conditions are handled cleanly.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix correctly implements an explicit bounds check before copying, addresses the root cause (missing length validation), uses the project\u2019s error handling pathway (expert_add_info and return), and prevents the buffer overflow without over\u2010engineering. It\u2019s neither too vague nor unrealistically detailed given the context. Therefore it\u2019s a high\u2010quality, plausible solution."}, {"fix_location": {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}, "guideline": "Validate all externally-controlled length or size fields against the capacity of your buffers before copying or writing data (CWE-120, CERT STR30-C).", "description": "In dissect_ber_GeneralString, immediately after reading the length from the BER header, insert a check: if (length + 1 > sizeof(name_string)) return an error (or truncate) rather than proceeding to memcpy.", "rationale": "By checking (length + 1) <= sizeof(name_string) up front, we prevent any write past the end of the local array, eliminating the out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the identified one-byte out-of-bounds write by validating the BER string length against the fixed buffer size before copying. It aligns with CWE-120 and CERT STR30-C guidelines, pinpoints the correct location in dissect_ber_GeneralString, and offers a clear error/truncate path. The strategy is neither too vague nor unrealistically detailed, making it both practical and secure."}, {"fix_location": {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}, "guideline": "When data can be larger than your static buffers, use dynamic allocation sized to the received length (CWE-119).", "description": "Alternatively, replace the fixed array 'char name_string[512]' with a pointer. After reading 'length', call malloc(length + 1) and copy data into the heap buffer. Free the buffer on error or when done.", "rationale": "Dynamic allocation sized exactly for the incoming length removes any arbitrary static limit and avoids stack overflows while still preserving exact BER string content.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy\u2014replacing the fixed-size stack buffer with a heap allocation of exactly (length + 1) bytes\u2014is directly aligned with the root cause (stack overflow via out-of-bounds write) and follows established CWE-119 guidelines. It plausibly fixes the overflow without imposing arbitrary limits, and the suggestion to free the buffer handles cleanup. It is appropriately targeted at dissect_ber_GeneralString. However, the answer remains somewhat high-level, omitting details around allocation failure handling, choice of safe copy functions, and integration with existing error paths, so it falls short of a perfect score."}, {"fix_location": {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}, "guideline": "Use bounded copy functions (e.g., strncpy, memcpy with explicit length checks) and always ensure space for a terminating null.", "description": "Use a single safe copy call such as 'memcpy(name_string, p, MIN(length, sizeof(name_string)-1)); name_string[MIN(length, sizeof(name_string)-1)] = '\\0';' to ensure no more than sizeof-1 bytes are written and the result is null-terminated.", "rationale": "Using a bounded copy with explicit size arithmetic guarantees we never write more bytes than the buffer can hold and always leave room for the null terminator.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM\u2019s proposed fix strategy directly addresses the one-byte out-of-bounds write by using a bounded copy (memcpy with MIN(length, sizeof(name_string)-1)) and explicitly null-terminating the buffer. This aligns well with the root cause (lack of bounds checking) and matches the provided guidelines. The recommendation is realistic and applicable in dissect_ber_GeneralString without over-specifying code locations. It is not overly general or hallucinated, though it remains at a high-level rather than presenting a full code patch, which is acceptable for a strategy overview. Therefore, it merits a high score."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3188, "end_line": 3200, "function_name": "", "code": "if (out_tvb) {\n            tvb_len = tvb_get_uint8(tvb, offset);\n            if ((unsigned)tvb_len >= name_len) {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, name_len-1);\n            } else {\n                tvb_memcpy(out_tvb, (uint8_t*)name_string, 0, tvb_len);\n            }\n            name_string[tvb_len] = '\\0';\n        }", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds write occurs when 'name_string[len]' is written without verifying that 'len' < sizeof(name_string). Inserting a bounds check around the copy in dissect_ber_GeneralString directly addresses the root cause (CWE-787/CWE-119) by preventing overflow while preserving functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM\u2019s proposed patch location focuses on the out_tvb branch that copies from the local name_string buffer to an output tvb and then null-terminates name_string. However, the actual overflow occurs earlier when reading BER data into the fixed-size stack buffer name_string without bounds checking. Adjusting the memcpy in the out_tvb section will not prevent the initial out-of-bounds write during input parsing, so this location is unlikely to resolve the CWE-787/CWE-119 issue and does not align with the root cause."}, {"locations": [], "rationale": "Need to inspect the implementation of dissect_ber_GeneralString around the buffer allocation and copy to identify appropriate bounds checks or dynamic allocation. Requesting code context from packet-ber.c.", "score": 1, "confidence": 8, "reliability_score": 1.8, "eval_rationale": "The LLM failed to identify any specific code location for applying the patch. Instead of proposing a fix site in dissect_ber_GeneralString, it merely requested additional context. This does not address the vulnerability and provides no actionable guidance, warranting the lowest score."}], "location_candidates": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3194, "end_line": 3194, "function_name": "dissect_ber_GeneralString", "code": "name_string[tvb_len] = '\\0';", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 935, "end_line": 935, "function_name": "try_dissect_unknown_ber", "code": "offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In dissect_ber_GeneralString (packet-ber.c), the code reads a length field from a BER GeneralString element and writes that many bytes into a fixed-size stack buffer (name_string) without checking that the length does not exceed the buffer\u2019s capacity, resulting in a one-byte out-of-bounds write.", "rationale": "AddressSanitizer traced a 1-byte write past the end of the stack-allocated name_string array when parsing a malicious GeneralString. Because there is no bounds check on the length before copying into the buffer, an attacker can trigger a buffer overflow (CWE-119) via an out-of-bounds write (CWE-787)."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the BER dissector (packet-ber.c), the function dissect_ber_GeneralString copies or writes string data into a fixed-size stack buffer (`name_string`) without validating the incoming length. When presented with an overly long GeneralString value, the code performs an out-of-bounds write past the end of the buffer, causing a stack-based buffer overflow.", "rationale": "AddressSanitizer reports a one-byte stack-buffer-overflow at the end of `name_string` in dissect_ber_GeneralString, demonstrating that boundary checks on the input length are missing or incorrect, leading to an out-of-bounds write (CWE-787) and buffer overflow (CWE-119)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the BER dissector\u2019s handling of GeneralString values, the function allocates a fixed-size local buffer for the extracted string but does not verify that the reported length from the input fits within that buffer. When a malformed or overly long string is encountered, writing the string data (and null terminator) overruns the stack buffer, resulting in a classic stack-based buffer overflow (out-of-bounds write).", "rationale": "AddressSanitizer pinpointed a one-byte write past the end of the local \u201cname_string\u201d buffer in dissect_ber_GeneralString. The code computes the string length from the BER length field without bounding it against the buffer size, allowing an attacker-controlled length to cause an overflow."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In dissect_ber_GeneralString (packet-ber.c), the code reads a length field from a BER GeneralString element and writes that many bytes into a fixed-size stack buffer (name_string) without checking that the length does not exceed the buffer\u2019s capacity, resulting in a one-byte out-of-bounds write.", "rationale": "AddressSanitizer traced a 1-byte write past the end of the stack-allocated name_string array when parsing a malicious GeneralString. Because there is no bounds check on the length before copying into the buffer, an attacker can trigger a buffer overflow (CWE-119) via an out-of-bounds write (CWE-787)."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-ber.c, the function dissect_ber_GeneralString allocates a fixed-size local array 'name_string' to hold the BER GeneralString content. It reads the length field from the BER element but does not verify that this length (plus a terminating null) fits within the buffer\u2019s capacity. When an excessively long or malformed GeneralString is parsed, the code copies data (and a null terminator) past the end of the stack buffer, causing a one-byte out-of-bounds write and triggering a stack-based buffer overflow.", "rationale": "AddressSanitizer flagged a one-byte write past the end of the 'name_string' buffer in dissect_ber_GeneralString. The absence of a bounds check against the BER-encoded string length before copying into the fixed-size stack buffer allows attacker-controlled input to overwrite memory beyond the allocated buffer, leading to an out-of-bounds write (CWE-787) and stack-based buffer overflow (CWE-119)."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-ber.c", "fix_line": 3194, "start_line": 3194, "end_line": 3194, "function_name": "dissect_ber_GeneralString", "code": "name_string[tvb_len] = '\\0';", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-ber.c", "fix_line": 935, "start_line": 935, "end_line": 935, "function_name": "try_dissect_unknown_ber", "code": "offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, name_string, sizeof(name_string));", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/qqor/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-delta-01_vuln_003/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-delta-01_vuln_003", "sanitizer_output": "+ FUZZER=handler_ber\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_ber -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_ber -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: ber\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 380317709\nINFO: Loaded 1 modules   (420438 inline 8-bit counters): 420438 [0xa9f3f00, 0xaa5a956), \nINFO: Loaded 1 PC tables (420438 PCs): 420438 [0xaa5a958,0xb0c4eb8), \n/out/handler_ber: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n=================================================================\n==18==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc598809df at pc 0x000005431adb bp 0x7ffc59880850 sp 0x7ffc59880848\nWRITE of size 1 at 0x7ffc598809df thread T0\nSCARINESS: 46 (1-byte-write-stack-buffer-overflow)\n    #0 0x5431ada in dissect_ber_GeneralString /src/wireshark/epan/dissectors/packet-ber.c:3194:34\n    #1 0x542899b in try_dissect_unknown_ber /src/wireshark/epan/dissectors/packet-ber.c:935:26\n    #2 0x5b84ecd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #3 0x5b84ecd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #4 0x5b8fb24 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #5 0x5b8fb24 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #6 0x544aad7 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #7 0x5b84ecd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #8 0x5b84ecd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #9 0x5b809c7 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #10 0x5b809c7 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #11 0x5b809c7 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #12 0x52bd530 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #13 0x50b3f48 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #14 0x4f66c20 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #15 0x4f51245 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #16 0x4f56cdf in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #17 0x4f82bd2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #18 0x7fa8ba7b2082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #19 0x4f4942d in _start (/out/handler_ber+0x4f4942d)\n\nDEDUP_TOKEN: dissect_ber_GeneralString--try_dissect_unknown_ber--call_dissector_through_handle\nAddress 0x7ffc598809df is located in stack of thread T0 at offset 159 in frame\n    #0 0x5427a1f in try_dissect_unknown_ber /src/wireshark/epan/dissectors/packet-ber.c:814\n\nDEDUP_TOKEN: try_dissect_unknown_ber\n  This frame has 12 object(s):\n    [32, 40) 'val.i510' (line 2021)\n    [64, 72) 'val.i' (line 2021)\n    [96, 97) 'ber_class' (line 816)\n    [112, 113) 'pc' (line 817)\n    [128, 132) 'tag' (line 818)\n    [144, 148) 'len' (line 821)\n    [160, 240) 'name_string' (line 825) <== Memory access at offset 159 underflows this variable\n    [272, 480) 'asn1_ctx' (line 833)\n    [544, 568) 'except_sn' (line 892)\n    [608, 856) 'except_ch' (line 892)\n    [928, 952) 'except_sn149' (line 992)\n    [992, 1240) 'except_ch150' (line 992)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /src/wireshark/epan/dissectors/packet-ber.c:3194:34 in dissect_ber_GeneralString\nShadow bytes around the buggy address:\n  0x7ffc59880700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880900: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f8 f2 f2 f2\n=>0x7ffc59880980: f8 f2 f2 f2 01 f2 01 f2 04 f2 04[f2]00 00 00 00\n  0x7ffc59880a00: 00 00 00 00 00 00 f2 f2 f2 f2 00 00 00 00 00 00\n  0x7ffc59880a80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x7ffc59880b00: 00 00 00 00 f2 f2 f2 f2 f2 f2 f2 f2 f8 f8 f8 f2\n  0x7ffc59880b80: f2 f2 f2 f2 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n  0x7ffc59880c00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x1b,0x84,0x0,0x0,0x0,0xc5,0x41,0x84,0x0,0x0,0x0,0xc6,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x88,0xff,\n\\033\\204\\000\\000\\000\\305A\\204\\000\\000\\000\\306\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\210\\377\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/qqor/aixcc/dataset/tarballs/wireshark_ws-delta-01/pov/wireshark_ws-delta-01_vuln_003:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_ber -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/qqor/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}