diff --git a/src/fmt.c b/src/fmt.c
index 8164e1ca..856f51ec 100644
--- a/src/fmt.c
+++ b/src/fmt.c
@@ -220,7 +220,7 @@ static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {
   // Reverse a string
   for (i = 0; i < n / 2; i++) {
     char t = buf[s + i];
-    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
+buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
   }
   if (val == 0) buf[n++] = '0';  // Handle special case
   return n + s;
@@ -228,9 +228,15 @@ static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {
 
 static size_t scpy(void (*out)(char, void *), void *ptr, char *buf,
                           size_t len) {
-  size_t i = 0;
-  while (i < len && buf[i] != '\0') out(buf[i++], ptr);
-  return i;
+// Ensure buffer is null-terminated to avoid overflow
+   size_t i = 0;
+   if (len > 0) {
+     buf[len - 1] = '\0';
+   }
+   while (i < len && buf[i] != '\0') {
+     out(buf[i++], ptr);
+   }
+   return i;
 }
 
 size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {
@@ -241,7 +247,6 @@ size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {
   va_end(ap);
   return len;
 }
-
 size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
                    va_list *ap) {
   size_t i = 0, n = 0;
@@ -315,17 +320,15 @@ size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
         for (j = 0; minus && pr < w && j + pr < w; j++)
           n += scpy(out, param, &pad, 1);
       } else if (c == 'e' || c == 'E') {
-		  char tmp[8];
+          /* Rationale: use snprintf to safely format exponential */
+          char tmp[64];
           double d = va_arg(*ap, double);
-          int64_t exponent = (int64_t)log10(my_fabs(d));
-          double mantissa = d / power(10, exponent);
-          k = mg_dtoa(tmp, 10, mantissa, 8, c == 'e');
-          n += scpy(out, param, tmp, k);
-          out(c, param);
-          n++;
-		  k = mg_lld(tmp, exponent, 1, 0);
-          n += scpy(out, param, tmp, k);
-	  } else if (c == '%') {
+          int prec = (pr == ~0U ? 6 : (int)pr);
+          int len = snprintf(tmp, sizeof(tmp), "%.*e", prec, d);
+          if (len < 0) len = 0;
+          else if ((size_t)len >= sizeof(tmp)) len = sizeof(tmp) - 1;
+          n += scpy(out, param, tmp, (size_t)len);
+      } else if (c == '%') {
         out('%', param);
         n++;
       } else {
