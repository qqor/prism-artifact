diff --git a/libfreerdp/core/gcc.c b/libfreerdp/core/gcc.c
index d135d8353..093fbf1cc 100644
--- a/libfreerdp/core/gcc.c
+++ b/libfreerdp/core/gcc.c
@@ -599,70 +599,22 @@ BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, UINT16 length)
 
 		Stream_Seek(s, blockLength - 4);
 
-		switch (type)
-		{
-			case CS_CORE:
-				if (!gcc_read_client_core_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_SECURITY:
-				if (!gcc_read_client_security_data(sub, mcs))
-					return FALSE;
-
-				break;
-
+					// Verify available capacity using Stream_GetRemainingCapacity
 			case CS_NET:
-				if (!gcc_read_client_network_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_CLUSTER:
-				if (!gcc_read_client_cluster_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_MONITOR:
-				if (!gcc_read_client_monitor_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_MCS_MSGCHANNEL:
-				if (!gcc_read_client_message_channel_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_MONITOR_EX:
-				if (!gcc_read_client_monitor_extended_data(sub, mcs))
-					return FALSE;
-
-				break;
-
-			case CS_UNUSED1:
-				if (!gcc_read_client_unused1_data(sub))
-					return FALSE;
-
-				break;
+				{
+					UINT32 avail = Stream_GetRemainingCapacity(sub);
+					if (avail < length)
+					{
+						WLog_ERR(TAG, "CS_NET: only %u bytes available but %u required", avail, length);
+						return FALSE;
+					}
+				}
 
-			case 0xC009:
-			case CS_MULTITRANSPORT:
-				gotMultitransport = TRUE;
-				if (!gcc_read_client_multitransport_channel_data(sub, mcs))
+				if (!gcc_read_client_network_data(sub, mcs))
 					return FALSE;
 
 				break;
 
-			default:
-				WLog_ERR(TAG, "Unknown GCC client data block: 0x%04" PRIX16 "", type);
-				winpr_HexDump(TAG, WLOG_TRACE, Stream_Pointer(sub), Stream_GetRemainingLength(sub));
-				break;
-		}
-
 		const size_t rem = Stream_GetRemainingLength(sub);
 		if (rem > 0)
 		{
