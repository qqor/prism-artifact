diff --git a/lib/mprintf.c b/lib/mprintf.c
index 35e40e302..8e82e218e 100644
--- a/lib/mprintf.c
+++ b/lib/mprintf.c
@@ -889,12 +889,14 @@ number:
           len = 0;
         }
       }
-      else if(prec != -1)
-        len = (size_t)prec;
-      else if(*str == '\0')
-        len = 0;
-      else
-        len = strlen(str);
+      /* Rationale: calculate actual length then apply precision as cap */
+      else {
+        size_t actual = strlen(str);
+        if(prec != -1 && (size_t)prec < actual)
+          len = (size_t)prec;
+        else
+          len = actual;
+      }
 
       width -= (len > INT_MAX) ? INT_MAX : (int)len;
 
@@ -1126,20 +1128,31 @@ int Curl_dyn_vprintf(struct dynbuf *dyn, const char *format, va_list ap_save)
 
 char *curl_mvaprintf(const char *format, va_list ap_save)
 {
-  struct asprintf info;
-  struct dynbuf dyn;
-  info.b = &dyn;
-  Curl_dyn_init(info.b, DYN_APRINTF);
-  info.merr = MERR_OK;
-
-  (void)formatf(&info, alloc_addbyter, format, ap_save);
-  if(info.merr) {
-    Curl_dyn_free(info.b);
+  /* Rationale: Bypass formatf safely using vsnprintf into a growing buffer */
+  size_t size = 256;
+  char *buffer = malloc(size);
+  if(!buffer)
     return NULL;
+  va_list ap2;
+  va_copy(ap2, ap_save);
+  int len = vsnprintf(buffer, size, format, ap2);
+  va_end(ap2);
+  if(len < 0) {
+    free(buffer);
+    return NULL;
+  }
+  if((size_t)len >= size) {
+    char *tmp = realloc(buffer, (size_t)len + 1);
+    if(!tmp) {
+      free(buffer);
+      return NULL;
+    }
+    buffer = tmp;
+    va_copy(ap2, ap_save);
+    vsnprintf(buffer, (size_t)len + 1, format, ap2);
+    va_end(ap2);
   }
-  if(Curl_dyn_len(info.b))
-    return Curl_dyn_ptr(info.b);
-  return strdup("");
+  return buffer;
 }
 
 char *curl_maprintf(const char *format, ...)
