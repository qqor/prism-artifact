diff --git a/lib/mprintf.c b/lib/mprintf.c
index 35e40e302..18e634a9a 100644
--- a/lib/mprintf.c
+++ b/lib/mprintf.c
@@ -889,24 +889,24 @@ number:
           len = 0;
         }
       }
-      else if(prec != -1)
-        len = (size_t)prec;
-      else if(*str == '\0')
-        len = 0;
-      else
-        len = strlen(str);
-
-      width -= (len > INT_MAX) ? INT_MAX : (int)len;
+      /* Rationale: remove len-based loop; do direct safe iteration */
+      if(prec != -1) {
+        for(size_t i = 0; i < (size_t)prec && str[i]; i++)
+          OUTCHAR(str[i]);
+      }
+      else {
+        for(size_t i = 0; str[i]; i++)
+          OUTCHAR(str[i]);
+      }
+      /* Skip original len-based loop to avoid OOB read */
 
+      /* Handle padding */
       if(flags & FLAGS_ALT)
         OUTCHAR('"');
 
       if(!(flags & FLAGS_LEFT))
         while(width-- > 0)
           OUTCHAR(' ');
-
-      for(; len && *str; len--)
-        OUTCHAR(*str++);
       if(flags & FLAGS_LEFT)
         while(width-- > 0)
           OUTCHAR(' ');
@@ -1130,9 +1130,26 @@ char *curl_mvaprintf(const char *format, va_list ap_save)
   struct dynbuf dyn;
   info.b = &dyn;
   Curl_dyn_init(info.b, DYN_APRINTF);
-  info.merr = MERR_OK;
+  /* Rationale: Truncate overly long format to safe limit and reserve buffer */
+  enum { SAFE_LIMIT = 4096 };
+  size_t fmtlen = strnlen(format, SAFE_LIMIT + 1);
+  const char *usefmt = format;
+  char *tmpfmt = NULL;
+  if(fmtlen > SAFE_LIMIT) {
+    tmpfmt = strndup(format, SAFE_LIMIT);
+    if(!tmpfmt) {
+      Curl_dyn_free(info.b);
+      return NULL;
+    }
+    usefmt = tmpfmt;
+    fmtlen = SAFE_LIMIT;
+  }
+  Curl_dyn_reserve(info.b, fmtlen + 1);
+   info.merr = MERR_OK;
 
-  (void)formatf(&info, alloc_addbyter, format, ap_save);
+  (void)formatf(&info, alloc_addbyter, usefmt, ap_save);
+  if(tmpfmt)
+    free(tmpfmt);
   if(info.merr) {
     Curl_dyn_free(info.b);
     return NULL;
