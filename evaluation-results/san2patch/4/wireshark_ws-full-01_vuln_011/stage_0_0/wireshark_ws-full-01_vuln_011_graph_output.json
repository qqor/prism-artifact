{"vuln_data": {"id": "wireshark_ws-full-01_vuln_011", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_aim", "branch_name": "ws-full-01", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["success", "", "", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\t/* Define maximum buddyname length to prevent overflow */\n\tenum { MAX_BUDDYNAME_LEN = 255 };\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\t/* Clamp length to buffer capacity */\n\tif (buddyname_length > MAX_BUDDYNAME_LEN)\n\t\tbuddyname_length = MAX_BUDDYNAME_LEN;\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, buddyname_length), buddyname_length);\n\t\t/* Explicitly null-terminate */\n\t\t(*name)[buddyname_length] = '\\0';\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\tconst uint16_t MAX_BUDDYNAME_LEN = 255;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\t/* Reject over-length names */\n\tif (buddyname_length > MAX_BUDDYNAME_LEN) {\n\t\t/* return error code to caller */\n\t\treturn -1;\n\t}\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, buddyname_length), buddyname_length);\n\t\t(*name)[buddyname_length] = '\\0';\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\t/* Use MIN to cap copy length */\n\tsize_t copy_len = (buddyname_length > 255) ? 255 : buddyname_length;\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, copy_len), copy_len);\n\t\t/* null-terminate within allocated buffer */\n\t\t(*name)[copy_len] = '\\0';\n\t}\n\n\treturn (int)copy_len;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t/* Allocate full buffer and zero it to ensure clean termination */\n\t*name = wmem_alloc(pool, 256);\n\tmemset(*name, 0, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\t/* Prevent overflow by capping length to buffer minus null */\n\tif (buddyname_length >= 256)\n\t\tbuddyname_length = 255;\n\n\tif (pool) {\n\t\t/* strlcpy will copy up to buffer size and always null-terminate */\n\t\tstrlcpy((char *)*name,\n\t\t       (char *)tvb_get_ptr(tvb, offset, buddyname_length),\n\t\t       256);\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "patched_code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\tsize_t available = tvb_reported_length_remaining(tvb, offset);\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\t/* First, ensure packet actually contains that many bytes */\n\tif (buddyname_length > available)\n\t\tbuddyname_length = (uint16_t)available;\n\t/* Then, clamp to our buffer capacity minus null */\n\tif (buddyname_length > 255)\n\t\tbuddyname_length = 255;\n\n\tif (pool) {\n\t\tmemcpy(*name, tvb_get_ptr(tvb, offset, buddyname_length), buddyname_length);\n\t\t(*name)[buddyname_length] = '\\0';\n\t}\n\n\treturn buddyname_length;\n}", "func_def": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)", "func_ret": ["return buddyname_length;"]}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}, "guideline": "Use a safe, length-bounded copy function (e.g., g_strlcpy or strncpy+safeguard) to guarantee null-termination and avoid overflow.", "description": "Replace the raw memcpy with g_strlcpy, which takes a target size and always NUL-terminates:\n\n    g_strlcpy(buddy_name,\n              (const gchar *)tvb_get_ptr(tvb, offset, name_len),\n              sizeof(buddy_name));\n\nThis both bounds the copy and guarantees a terminating '\\0'.", "rationale": "Using g_strlcpy enforces both a maximum copy length and automatic null-termination, removing the risk of overflow while preserving valid input data.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly addresses the root cause\u2014an unchecked memcpy\u2014by using g_strlcpy to enforce a maximum copy length and automatic NUL-termination. This aligns well with the guideline and is practical for preventing the out-of-bounds write in aim_get_buddyname. However, the answer stops short of suggesting explicit error handling when the length field exceeds the buffer capacity, and the fix location isn\u2019t tied precisely to the memcpy call in the function, making it slightly too general. These minor gaps prevent a perfect score but overall it\u2019s a solid, applicable solution."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}, "guideline": "When data size is untrusted and may exceed static limits, consider either truncating to a safe maximum or using dynamic allocation with an upper bound check (CWE-119 mitigation).", "description": "Remove the local fixed-size buffer entirely. After validating buddy_name_len <= MAX_ALLOWED_NAME (e.g. 256), allocate buddy_name_buf = g_malloc(buddy_name_len+1), memcpy exactly buddy_name_len bytes, set buddy_name_buf[buddy_name_len]='\\0', use it, then g_free() when done.", "rationale": "Switching to a dynamic buffer with explicit upper bounds allows handling larger valid names safely while retaining a hard limit to prevent both stack and heap overflows.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed strategy correctly addresses the out-of-bounds write by replacing the fixed-size stack buffer with a dynamically allocated buffer after validating the incoming length against a safe maximum. It aligns well with the CWE-787 and CWE-119 mitigation guidelines and is broadly applicable. However, it remains somewhat high-level and does not show exact code modifications or integration points in packet-aim.c, so it loses some points for lacking code-level specificity and context integration."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Always perform explicit bounds checking on any length or size field read from untrusted input before using it in a memory operation to ensure it does not exceed the destination buffer\u2019s capacity (CWE-787).", "description": "Introduce a MAX_BUDDYNAME_LEN constant (e.g. 255). After reading buddyname_length from the packet, clamp it to MAX_BUDDYNAME_LEN if it exceeds that value, then perform memcpy of the clamped length and explicitly null-terminate the buffer.", "rationale": "By clamping the copy length to a known safe maximum and null-terminating, we prevent any overflow of the fixed buffer, eliminating the out-of-bounds write while preserving legacy allocation size.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly targets the root cause\u2014unbounded memcpy\u2014by introducing an explicit MAX_BUDDYNAME_LEN clamp and null-termination. It aligns well with the vulnerability description and can be applied at the identified location without breaking existing functionality. The answer is neither vague nor overly specific, and it follows best practices for mitigating CWE-787. The only minor omission is an explicit mention of adjusting the tvb_get_ptr offset past the length field, but this does not detract from the validity of the fix approach."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "When possible, allocate buffers dynamically based on a validated or clamped length, rather than using a large fixed-size buffer, to minimize waste while preventing overflow (CWE-119).", "description": "Instead of always allocating a 256-byte buffer, allocate pool memory of size (validated_length + 1). Validate that buddyname_length is below a defined maximum; if it is too large, either reject the packet or clamp it before allocation. Copy buddyname_length bytes and set the trailing NUL.", "rationale": "Allocating exactly the required size based on a validated length guarantees there is never more data copied than the buffer holds, removing the reliance on large fixed buffers and preventing overflow.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly identifies the root cause (missing bounds check) and suggests dynamically allocating based on the validated length, clamping or rejecting oversized names, and adding a NUL terminator. This approach aligns well with CWE-119 mitigation guidelines and would prevent overflow while minimizing wasted memory. The answer is plausible and could be applied to the location in packet-aim.c. It loses a couple of points because it remains somewhat high-level (no exact code snippet or constants) and doesn\u2019t specify the maximum allowed length or error handling details, but it is solid and directly addresses the vulnerability."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, "guideline": "Prefer safe copy routines or wrappers (e.g., strndup, tvb_strndup, wmem_strndup) that enforce maximum lengths and automatically null-terminate, reducing the risk of off-by-one or missing terminator issues.", "description": "Replace manual memcpy with the tvb_strndup API: call tvb_strndup(pool, tvb, offset + 2, buddyname_length) after validating buddyname_length, which will allocate the right amount of memory, copy up to the specified length, and append a NUL terminator.", "rationale": "Using a vetted helper function centralizes length checking, allocation, copying, and termination in one call, reducing custom code paths and the chance of missing a bounds check or terminator.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly identifies the out-of-bounds write in the memcpy call and recommends using the vetted tvb_strndup helper to handle allocation, copying, and null-termination in one safe API. It also notes the need to validate buddyname_length before calling the helper. The fix location (replacing memcpy in aim_get_buddyname) is accurate and the approach aligns with the guideline to prefer safe copy routines. The response is neither too vague nor unrealistically detailed, making it both practical and secure."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}, "guideline": "Validate all protocol-supplied length fields against the capacity of fixed-size buffers before any memory copy or write operation (CWE-787).", "description": "In packet-aim.c around aim_get_buddyname, insert a check after reading buddy_name_len: if buddy_name_len >= sizeof(buddy_name_buf), clamp buddy_name_len to sizeof(buddy_name_buf)-1 or bail out with a protocol error. Then call memcpy with that bounded length and explicitly append a '\\0' terminator.", "rationale": "Clamping or rejecting oversized length values prevents any out-of-bounds write into the fixed buffer, directly mitigating the overflow condition.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed fix directly addresses the CWE-787 out-of-bounds write by validating the packet-supplied length against the fixed buffer size and clamping or rejecting oversized values. It aligns well with the described root cause and is a realistic strategy for insertion into aim_get_buddyname. The recommendation to append a null terminator ensures safety for subsequent string operations. The answer is sufficiently specific without over-detailing exact line numbers or imposing unrealistic changes. It could be improved with a concrete code snippet, but overall it is sound and applicable."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}, "guideline": "Use bounded or safer copy functions (e.g. memcpy with explicit maximum length, strncat/strncpy, or API helpers that NUL-terminate) to prevent overflows (CERT C STR31-C).", "description": "Replace the raw memcpy call with the tvb_get_string_enc helper that accepts a maximum length argument: tvb_get_string_enc(tvb, offset, sizeof(buddy_name_buf)-1, ENC_ASCII); this function ensures no overflow and always null-terminates the buffer.", "rationale": "Using a library/helper function with built-in length checking and termination reduces manual errors and ensures safe bounded copying.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the out-of-bounds write in aim_get_buddyname by replacing the unchecked memcpy with a Wireshark-provided helper (tvb_get_string_enc) that enforces a maximum length and null-termination. This aligns with the given CWE-787 and CERT STR31-C guidance, is practically applicable at the identified location, and avoids hallucinatory or overly granular details. A minor deduction is due since explicit offset handling isn\u2019t shown, but overall the approach is sound and implementable."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}, "guideline": "When data size is untrusted and may exceed static limits, consider either truncating to a safe maximum or using dynamic allocation with an upper bound check (CWE-119 mitigation).", "description": "Remove the local fixed-size buffer entirely. After validating buddy_name_len <= MAX_ALLOWED_NAME (e.g. 256), allocate buddy_name_buf = g_malloc(buddy_name_len+1), memcpy exactly buddy_name_len bytes, set buddy_name_buf[buddy_name_len]='\\0', use it, then g_free() when done.", "rationale": "Switching to a dynamic buffer with explicit upper bounds allows handling larger valid names safely while retaining a hard limit to prevent both stack and heap overflows.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed strategy correctly addresses the out-of-bounds write by replacing the fixed-size stack buffer with a dynamically allocated buffer after validating the incoming length against a safe maximum. It aligns well with the CWE-787 and CWE-119 mitigation guidelines and is broadly applicable. However, it remains somewhat high-level and does not show exact code modifications or integration points in packet-aim.c, so it loses some points for lacking code-level specificity and context integration."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}, "guideline": "Perform explicit bounds checking on the packet-supplied length before copying into a fixed-size buffer (CWE-787).", "description": "Before calling memcpy, add a check:\n\n    if (name_len >= sizeof(buddy_name)) {\n        /* length too large: truncate to max-1 or bail out */\n        name_len = sizeof(buddy_name) - 1;\n        expert_add_info(pinfo, aim_tree, \"Buddy name length truncated to prevent overflow\");\n    }\n\nThis ensures name_len never exceeds the buffer size minus one for the NUL terminator.", "rationale": "By clamping the length to the buffer's capacity minus one, we eliminate any possibility of writing past the end of the local array, directly fixing the out-of-bounds write.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The provided strategy directly addresses the root cause (missing bounds check) by clamping the packet-supplied length to the fixed buffer size minus one and adding an informative expert message. It aligns well with the CWE-787 guideline and targets the correct function area without over-or under-specification. This approach is both practical and sufficient to prevent the out-of-bounds write while preserving existing functionality."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}, "guideline": "Use a safe, length-bounded copy function (e.g., g_strlcpy or strncpy+safeguard) to guarantee null-termination and avoid overflow.", "description": "Replace the raw memcpy with g_strlcpy, which takes a target size and always NUL-terminates:\n\n    g_strlcpy(buddy_name,\n              (const gchar *)tvb_get_ptr(tvb, offset, name_len),\n              sizeof(buddy_name));\n\nThis both bounds the copy and guarantees a terminating '\\0'.", "rationale": "Using g_strlcpy enforces both a maximum copy length and automatic null-termination, removing the risk of overflow while preserving valid input data.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed strategy correctly addresses the root cause\u2014an unchecked memcpy\u2014by using g_strlcpy to enforce a maximum copy length and automatic NUL-termination. This aligns well with the guideline and is practical for preventing the out-of-bounds write in aim_get_buddyname. However, the answer stops short of suggesting explicit error handling when the length field exceeds the buffer capacity, and the fix location isn\u2019t tied precisely to the memcpy call in the function, making it slightly too general. These minor gaps prevent a perfect score but overall it\u2019s a solid, applicable solution."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}, "guideline": "Validate that the tvb (packet buffer) actually contains at least the claimed number of bytes before any copy operation to prevent over-reads or under-reads.", "description": "Prior to any copy, verify the packet has at least name_len bytes remaining:\n\n    if (tvb_reported_length_remaining(tvb, offset) < name_len) {\n        expert_add_error(pinfo, aim_tree, \"Malformed packet: insufficient data for buddy name\");\n        return;\n    }\n\nThis prevents reading or writing beyond the available TVB data.", "rationale": "Checking tvb_reported_length_remaining ensures that we never attempt to read or copy more packet data than actually exists, preventing both OOB reads and subsequent OOB writes.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The provided fix directly addresses the out-of-bounds write by inserting a proper bounds check using tvb_reported_length_remaining before the memcpy. It aligns with the reported root cause (missing length check) and proposes a realistic error path without disrupting existing functionality. The strategy is neither overly vague nor unrealistically detailed, making it highly applicable to the specified code location."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 580, "end_line": 595, "function_name": "", "code": "static int\naim_get_buddyname(wmem_allocator_t *pool, uint8_t **name, tvbuff_t *tvb, int offset)\n{\n\tuint16_t buddyname_length;\n\n\t*name = wmem_alloc(pool, 256);\n\n\tbuddyname_length = tvb_get_ntohs(tvb, offset);\n\n\tif (pool)\n\t\tmemcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);\n\n\treturn buddyname_length;\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs because aim_get_buddyname copies a length-prefixed name field into a fixed-size local buffer without bounds checking. By validating or clamping the length before memcpy, we prevent buffer overflow while preserving existing functionality.", "score": 10, "confidence": 9, "reliability_score": 19.0, "eval_rationale": "The LLM correctly pinpointed the out-of-bounds write in the aim_get_buddyname function, precisely where memcpy uses an unchecked length against a fixed-size buffer. Modifying this location to add a bounds check or clamp the length directly addresses the root cause without affecting other functionality. No irrelevant code was selected, and patching here will effectively close the overflow."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 263, "start_line": 250, "end_line": 280, "function_name": "", "code": "typedef struct _aim_subtype {\n\tuint16_t id;\n\tconst char *name;\n\tint (*dissector) (tvbuff_t *, packet_info *, proto_tree *);\n} aim_subtype;\n\ntypedef struct _aim_family {\n\tint ett;\n\tint proto_id;\n\tprotocol_t *proto;\n\tuint16_t family;\n\tconst char *name;\n\tconst aim_subtype *subtypes;\n} aim_family;\n\nstatic int dissect_aim_tlv(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree, const aim_tlv *);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability occurs in aim_get_buddyname when memcpy is called without verifying that the packet-supplied length fits within the local buffer. We insert a length check to cap the copy length and ensure null-termination, eliminating the out-of-bounds write without altering normal functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The LLM\u2019s proposed patch location (in the dissect_aim_tlv function around lines 250\u2013280) does not correspond to the vulnerable aim_get_buddyname function where the out-of-bounds write occurs. Since the root cause is the unchecked memcpy in aim_get_buddyname, modifying dissect_aim_tlv will not address the overflow. This choice is therefore inappropriate and unlikely to resolve the issue, meriting a very low score."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1542, "start_line": 1540, "end_line": 1544, "function_name": "", "code": "static void\ndissect_aim_newconn(tvbuff_t *tvb, packet_info *pinfo, int offset,\n\t\t    proto_tree *tree)\n{\n\tcol_set_str(pinfo->cinfo, COL_INFO, \"New Connection\");\n\n\tif (tvb_reported_length_remaining(tvb, offset) > 0) {\n\t\tproto_tree_add_item(tree, hf_aim_version, tvb, offset, 4, ENC_NA);\n\t\toffset+=4;\n\t\toffset = dissect_aim_tlv_sequence(tvb, pinfo, offset, tree, aim_client_tlvs);\n\t}\n\n\tif (tvb_reported_length_remaining(tvb, offset) > 0)\n\t\tproto_tree_add_item(tree, hf_aim_data, tvb, offset, -1, ENC_NA);\n}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The function aim_get_buddyname reads a length from the packet and directly passes it to memcpy into a fixed-size local buffer. By adding a bounds check and capping name_len to sizeof(buffer) \u2013 1, we eliminate the buffer overflow while preserving existing functionality.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The LLM suggested modifying epan/dissectors/packet-aim.c at lines 1540\u20131544 in the dissect_aim_newconn function, but the vulnerability resides in aim_get_buddyname. The chosen location is unrelated to the described buffer overflow and addressing it there would not fix the root cause. This makes the fix location both inaccurate and ineffective."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1625, "start_line": 1622, "end_line": 1628, "function_name": "", "code": "case CHANNEL_FLAP_ERR:\n\t\tdissect_aim_flap_err(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_CLOSE_CONN:\n\t\tdissect_aim_close_conn(tvb, pinfo, offset, aim_tree);\n\t\tbreak;\n\tcase CHANNEL_KEEP_ALIVE:\n\t\tdissect_aim_keep_alive(tvb, pinfo, offset, aim_tree);\n\t\tbreak;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The root cause is that the packet-supplied length is passed unchecked to memcpy into a fixed-size local buffer. By validating or truncating the length to buffer capacity (size-1), we ensure no OOB write occurs while preserving valid packet parsing.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected patch location within the switch cases (lines 1622\u20131628) handling CHANNEL_FLAP_ERR, CHANNEL_CLOSE_CONN, and CHANNEL_KEEP_ALIVE is unrelated to the buffer overflow in aim_get_buddyname. The overflow occurs when copying the buddy name in aim_get_buddyname (not within these cases), so modifying these case labels will not address the root cause. A proper fix belongs in the function that allocates the fixed-size buffer and invokes memcpy, where a length check or truncation should be inserted. Therefore, the suggested location is ineffective and off-target."}, {"locations": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1600, "end_line": 1700, "function_name": "", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,\n\t\t\t dissect_aim_pdu, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "We select the call site in packet-aim.c around line 1655 where aim_get_buddyname copies the buddy name without checking its length. Adding a length check there prevents out-of-bounds writes while preserving existing functionality.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The proposed fix point at the tcp_dissect_pdus call site (lines 1600\u20131700) does not directly address the unchecked memcpy in aim_get_buddyname where the out-of-bounds write occurs. The vulnerability stems from missing bounds checking on the packet-provided length inside aim_get_buddyname itself, not at the outer PDU dissection call. Modifying tcp_dissect_pdus is unlikely to prevent the specific overflow, and it risks unintended side-effects in unrelated code paths. A correct patch must be placed within aim_get_buddyname around its memcpy call to validate the name length against the buffer size. Consequently, the location selection is misaligned with the root cause."}], "location_candidates": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 591, "end_line": 591, "function_name": "aim_get_buddyname", "code": "memcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1976, "start_line": 1976, "end_line": 1976, "function_name": "dissect_aim_chat_outgoing_msg", "code": "buddyname_length = aim_get_buddyname( pinfo->pool, &buddyname, tvb, 30 );", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 809, "start_line": 809, "end_line": 809, "function_name": "dissect_aim_snac", "code": "subtype->dissector(subtvb, pinfo, family_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1618, "start_line": 1618, "end_line": 1618, "function_name": "dissect_aim_pdu", "code": "dissect_aim_snac(tvb, pinfo, offset, aim_tree, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-tcp.c", "fix_line": 5569, "start_line": 5569, "end_line": 5569, "function_name": "tcp_dissect_pdus", "code": "(*dissect_pdu)(next_tvb, pinfo, tree, dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1655, "end_line": 1655, "function_name": "dissect_aim", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "fuzz/fuzzshark.c", "fix_line": 359, "start_line": 359, "end_line": 359, "function_name": "LLVMFuzzerTestOneInput", "code": "epan_dissect_run(edt, WTAP_FILE_TYPE_SUBTYPE_UNKNOWN, &rec, &fdlocal, NULL /* &fuzz_cinfo */);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-aim.c, the function aim_get_buddyname copies a length-specified name field from the incoming AIM packet into a fixed-size local buffer using memcpy without verifying that the declared length does not exceed the buffer\u2019s capacity. A specially crafted packet with an oversized name length will overflow this buffer, leading to an out-of-bounds write, program abort, or potential code execution.", "rationale": "AddressSanitizer pinpoints the overflow at the memcpy in aim_get_buddyname (packet-aim.c:591). The code reads a length from the packet and unconditionally passes it to memcpy, but never bounds-checks it against the destination buffer size. This missing validation directly causes the out-of-bounds write (CWE-787)."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The AIM protocol dissector\u2019s aim_get_buddyname function copies a username field from packet data into a fixed-size buffer using memcpy without verifying that the input length fits. A specially crafted packet can supply a length larger than the destination buffer, causing memcpy to write past the buffer boundary and corrupt adjacent memory.", "rationale": "The vulnerability stems from missing bounds checks on the data length before memcpy, leading to an out-of-bounds write (CWE-787). This classic buffer overflow (CWE-119) in packet-aim.c:591 makes it possible for attackers to overwrite memory and potentially crash or hijack the application."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The AIM protocol dissector in packet-aim.c uses memcpy to copy a user-controlled buddy name into a fixed-size buffer without verifying that the name length fits, resulting in an out-of-bounds write and potential crash.", "rationale": "AddressSanitizer reports a buffer overflow at memcpy in aim_get_buddyname (packet-aim.c:591) when the input name exceeds the destination buffer size. The lack of a bounds check before copying allows writing past the buffer\u2019s end, corrupting memory and aborting execution."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-aim.c, the function aim_get_buddyname copies a length-specified name field from the incoming AIM packet into a fixed-size local buffer using memcpy without verifying that the declared length does not exceed the buffer\u2019s capacity. A specially crafted packet with an oversized name length will overflow this buffer, leading to an out-of-bounds write, program abort, or potential code execution.", "rationale": "AddressSanitizer pinpoints the overflow at the memcpy in aim_get_buddyname (packet-aim.c:591). The code reads a length from the packet and unconditionally passes it to memcpy, but never bounds-checks it against the destination buffer size. This missing validation directly causes the out-of-bounds write (CWE-787)."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-aim.c, the AIM protocol dissector\u2019s aim_get_buddyname function allocates a fixed-size local buffer for the buddy name and uses memcpy to copy a length-prefixed name field from packet data. Because the code does not compare the packet-supplied length against the buffer\u2019s capacity, an attacker can send a crafted packet with an oversized name length to overflow the buffer. This results in memory corruption via an out-of-bounds write (CWE-787), causing application aborts or potential remote code execution (CWE-119).", "rationale": "The aim_get_buddyname function reads a length value from an incoming AIM packet and unconditionally passes it to memcpy without verifying that it does not exceed the fixed-size destination buffer. This missing bounds check leads to an out-of-bounds write that corrupts adjacent memory and can trigger application crashes or enable code execution."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-aim.c", "fix_line": 591, "start_line": 591, "end_line": 591, "function_name": "aim_get_buddyname", "code": "memcpy(*name, tvb_get_ptr(tvb,offset,1), buddyname_length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1976, "start_line": 1976, "end_line": 1976, "function_name": "dissect_aim_chat_outgoing_msg", "code": "buddyname_length = aim_get_buddyname( pinfo->pool, &buddyname, tvb, 30 );", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 809, "start_line": 809, "end_line": 809, "function_name": "dissect_aim_snac", "code": "subtype->dissector(subtvb, pinfo, family_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1618, "start_line": 1618, "end_line": 1618, "function_name": "dissect_aim_pdu", "code": "dissect_aim_snac(tvb, pinfo, offset, aim_tree, tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-tcp.c", "fix_line": 5569, "start_line": 5569, "end_line": 5569, "function_name": "tcp_dissect_pdus", "code": "(*dissect_pdu)(next_tvb, pinfo, tree, dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-aim.c", "fix_line": 1655, "start_line": 1655, "end_line": 1655, "function_name": "dissect_aim", "code": "tcp_dissect_pdus(tvb, pinfo, tree, aim_desegment, 6, get_aim_pdu_len,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "fuzz/fuzzshark.c", "fix_line": 359, "start_line": 359, "end_line": 359, "function_name": "LLVMFuzzerTestOneInput", "code": "epan_dissect_run(edt, WTAP_FILE_TYPE_SUBTYPE_UNKNOWN, &rec, &fdlocal, NULL /* &fuzz_cinfo */);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-full-01_vuln_011/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-full-01_vuln_011", "sanitizer_output": "+ FUZZER=handler_aim\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_aim -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_aim -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: json\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: aim\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 982848296\nINFO: Loaded 1 modules   (420518 inline 8-bit counters): 420518 [0xa9f6a00, 0xaa5d4a6), \nINFO: Loaded 1 PC tables (420518 PCs): 420518 [0xaa5d4a8,0xb0c7f08), \n/out/handler_aim: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n*** buffer overflow detected ***: terminated\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: ABRT on unknown address 0x000000000012 (pc 0x7fe9d7af700b bp 0x7ffc4c453b00 sp 0x7ffc4c453780 T0)\nSCARINESS: 10 (signal)\n    #0 0x7fe9d7af700b in raise (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #1 0x7fe9d7ad6858 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #2 0x7fe9d7b41265  (/lib/x86_64-linux-gnu/libc.so.6+0x8d265) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #3 0x7fe9d7be3cd9 in __fortify_fail (/lib/x86_64-linux-gnu/libc.so.6+0x12fcd9) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #4 0x7fe9d7be2575 in __chk_fail (/lib/x86_64-linux-gnu/libc.so.6+0x12e575) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #5 0x5dbcb23 in memcpy /usr/include/x86_64-linux-gnu/bits/string_fortified.h:34:10\n    #6 0x5dbcb23 in aim_get_buddyname /src/wireshark/epan/dissectors/packet-aim.c:591:3\n    #7 0x5dbcb23 in dissect_aim_chat_outgoing_msg /src/wireshark/epan/dissectors/packet-aim.c:1976:21\n    #8 0x5dbaa2f in dissect_aim_snac /src/wireshark/epan/dissectors/packet-aim.c:809:3\n    #9 0x5dbaa2f in dissect_aim_pdu /src/wireshark/epan/dissectors/packet-aim.c:1618:3\n    #10 0x52ff8af in tcp_dissect_pdus /src/wireshark/epan/dissectors/packet-tcp.c:5569:13\n    #11 0x5db7f4d in dissect_aim /src/wireshark/epan/dissectors/packet-aim.c:1655:2\n    #12 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #13 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #14 0x5b90394 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #15 0x5b90394 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #16 0x544b347 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #17 0x5b8573d in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #18 0x5b8573d in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #19 0x5b81237 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #20 0x5b81237 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #21 0x5b81237 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #22 0x52bddb0 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #23 0x50b47c8 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #24 0x4f674a0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #25 0x4f51ac5 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #26 0x4f5755f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #27 0x4f83452 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #28 0x7fe9d7ad8082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #29 0x4f49cad in _start (/out/handler_aim+0x4f49cad)\n\nDEDUP_TOKEN: raise--abort--\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: ABRT (/lib/x86_64-linux-gnu/libc.so.6+0x4300b) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d) in raise\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x2a,0x1,0x2a,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a,0x2,0x2,0x0,0x0,0xf7,0x0,0xe,0x0,0x5,0x0,0x0,0x0,0x0,0xff,0xfc,0x2a,0x2,0x2,0x24,0x8,0x0,0x0,0x0,0x0,0x0,0xf7,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a,0x2,0x2,0x24,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2a,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x89,0x1f,0x5,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,\n*\\001*\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000(\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\000o\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000*\\002\\002\\000\\000\\367\\000\\016\\000\\005\\000\\000\\000\\000\\377\\374*\\002\\002$\\010\\000\\000\\000\\000\\000\\367\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000*\\002\\002$\\000\\200\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\001*\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\211\\037\\005\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\001*\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\012\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/user/aixcc/dataset/tarballs/wireshark_ws-full-01/pov/wireshark_ws-full-01_vuln_011:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_aim -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}