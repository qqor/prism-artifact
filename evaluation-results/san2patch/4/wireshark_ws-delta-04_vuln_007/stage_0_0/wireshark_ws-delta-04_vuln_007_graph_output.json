{"vuln_data": {"id": "wireshark_ws-delta-04_vuln_007", "subject": "wireshark", "work_name": "wireshark", "project_name": "wireshark", "hiding_project_name": "", "project_full_name": "wireshark", "harness_name": "handler_json", "branch_name": "ws-delta-04", "project_repo_name": "official-afc-wireshark"}, "data_type": "oss-fuzz", "patch_success": ["vuln_test_failed", "vuln_test_failed", "vuln_test_failed", "vuln_test_failed", "vuln_test_failed", "vuln_test_failed", "build_failed", "success", "", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (string[length - 1] == '\"') {\n\t\t\tstring[length - 1] = '\\0';\n\t\t}\n\t\tif (string[0] == '\"') {\n\t\t\tstring += 1;\n\t\t}\n\t}\n\n\treturn string;\n}", "patched_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tchar *tmp = json_string_unescape(scope, string, &length);\n\t\tif (!tmp)\n\t\t\treturn NULL;\n\t\tstring = tmp;\n\t} else {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (length > 0 && string[length - 1] == '\"')\n\t\t\tstring[length - 1] = '\\0';\n\t\tif (*string == '\"')\n\t\t\tstring += 1;\n\t}\n\n\treturn string;\n}", "func_def": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)", "func_ret": ["return string;"]}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (string[length - 1] == '\"') {\n\t\t\tstring[length - 1] = '\\0';\n\t\t}\n\t\tif (string[0] == '\"') {\n\t\t\tstring += 1;\n\t\t}\n\t}\n\n\treturn string;\n}", "patched_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tsize_t inlen = strlen(string);\n\t\t/* Reject if string ends with a lone backslash or incomplete Unicode escape */\n\t\tif (inlen > 0 && string[inlen - 1] == '\\\\')\n\t\t\treturn NULL;\n\t\tif (inlen > 1 && string[inlen - 2] == '\\\\' && (string[inlen - 1] == 'u' || string[inlen - 1] == 'U'))\n\t\t\treturn NULL;\n\n\t\tstring = json_string_unescape(scope, string, &length);\n\t\tif (!string)\n\t\t\treturn NULL;\n\t} else {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (length > 0 && string[length - 1] == '\"')\n\t\t\tstring[length - 1] = '\\0';\n\t\tif (*string == '\"')\n\t\t\tstring += 1;\n\t}\n\n\treturn string;\n}", "func_def": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)", "func_ret": ["return string;"]}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (string[length - 1] == '\"') {\n\t\t\tstring[length - 1] = '\\0';\n\t\t}\n\t\tif (string[0] == '\"') {\n\t\t\tstring += 1;\n\t\t}\n\t}\n\n\treturn string;\n}", "patched_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tchar *p = strrchr(string, '\\\\');\n\t\tif (p && p[1] == 'u' && strlen(p) < 6) {\n\t\t\t/* Incomplete Unicode escape at end */\n\t\t\treturn NULL;\n\t\t}\n\t\tstring = json_string_unescape(scope, string, &length);\n\t\tif (!string)\n\t\t\treturn NULL;\n\t} else {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (length > 0 && string[length - 1] == '\"')\n\t\t\tstring[length - 1] = '\\0';\n\t\tif (*string == '\"')\n\t\t\tstring += 1;\n\t}\n\n\treturn string;\n}", "func_def": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)", "func_ret": ["return string;"]}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (string[length - 1] == '\"') {\n\t\t\tstring[length - 1] = '\\0';\n\t\t}\n\t\tif (string[0] == '\"') {\n\t\t\tstring += 1;\n\t\t}\n\t}\n\n\treturn string;\n}", "patched_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tsize_t inlen = strlen(string);\n\t\t/* If a truncated Unicode escape is detected, abort */\n\t\tif (inlen < 6 && strstr(string, \"\\\\u\") != NULL)\n\t\t\tgoto error;\n\n\t\tstring = json_string_unescape(scope, string, &length);\n\t\tif (!string)\n\t\t\tgoto error;\n\t} else {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (length > 0 && string[length - 1] == '\"')\n\t\t\tstring[length - 1] = '\\0';\n\t\tif (*string == '\"')\n\t\t\tstring += 1;\n\t}\n\n\treturn string;\n\nerror:\n\treturn NULL;\n}", "func_def": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)", "func_ret": ["return string;"]}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes) {\n\t\tif (string[length - 1] == '\"') {\n\t\t\tstring[length - 1] = '\\0';\n\t\t}\n\t\tif (string[0] == '\"') {\n\t\t\tstring += 1;\n\t\t}\n\t}\n\n\treturn string;\n}", "patched_code": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool(remove_quotes))\n{\n\tchar *string;\n\tsize_t length;\n\n\tstring = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);\n\n\tif (unescape_strings) {\n\t\tchar *orig = string;\n\t\tchar *tmp = json_string_unescape(scope, string, &length);\n\t\t/* On error, fall back to original string without unescape */\n\t\tif (!tmp) {\n\t\t\tlength = strlen(orig);\n\t\t\tstring = orig;\n\t\t} else {\n\t\t\tstring = tmp;\n\t\t}\n\t} else {\n\t\tlength = strlen(string);\n\t}\n\n\tif (remove_quotes && length > 0) {\n\t\tif (string[length - 1] == '\"')\n\t\t\tstring[length - 1] = '\\0';\n\t\tif (*string == '\"')\n\t\t\tstring += 1;\n\t}\n\n\treturn string;\n}", "func_def": "static const char*\nget_json_string(wmem_allocator_t *scope, tvbparse_elem_t *tok, bool remove_quotes)", "func_ret": ["return string;"]}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */\n", "patched_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n// FIXME: Crash CWE-125: Out-of-bounds Read\n\t\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n\t#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\t\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\t/* Limit maximum JSON string length to prevent runaway reads */\n\t#define MAX_JSON_STRING_LEN 65535  /* Rationale: enforce bounds checking */\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, MAX_JSON_STRING_LEN, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */", "func_def": "static void\ninit_json_parser(void)", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */\n", "patched_code": "--- a/epan/dissectors/packet-json.c\n+++ b/epan/dissectors/packet-json.c\n@@ -1305,12 +1305,24 @@ init_json_parser(void) {\n-                    tvbparse_seq(-1, \"\\\\u\",\n-                        /* four hex-digit callbacks already listed above */\n-                        NULL\n-                    ),\n+                    /* Replace undefined tvbparse_seq with explicit sequence matching \"\\\\u\" + four hex digits */\n+                    tvbparse_set_seq(-1, NULL, NULL, NULL,\n+                        /* match backslash then 'u' */\n+                        tvbparse_char(-1, \"\\\\\", NULL, NULL, NULL),\n+                        tvbparse_char(-1, \"u\",    NULL, NULL, NULL),\n+                        /* four hex-digit callbacks */\n+                        tvbparse_set_oneof(-1, NULL, NULL, NULL,\n+                            tvbparse_not_chars(-1, 0, 0,\n+                                \"0123456789ABCDEFabcdef\",\n+                                NULL, NULL, NULL)),\n+                        tvbparse_set_oneof(-1, NULL, NULL, NULL,\n+                            tvbparse_not_chars(-1, 0, 0,\n+                                \"0123456789ABCDEFabcdef\",\n+                                NULL, NULL, NULL)),\n+                        tvbparse_set_oneof(-1, NULL, NULL, NULL,\n+                            tvbparse_not_chars(-1, 0, 0,\n+                                \"0123456789ABCDEFabcdef\",\n+                                NULL, NULL, NULL)),\n+                        tvbparse_set_oneof(-1, NULL, NULL, NULL,\n+                            tvbparse_not_chars(-1, 0, 0,\n+                                \"0123456789ABCDEFabcdef\",\n+                                NULL, NULL, NULL)),\n+                        NULL\n+                    ),\n", "func_def": "static void\ninit_json_parser(void)", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */\n", "patched_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n// FIXME: Crash CWE-125: Out-of-bounds Read\n\t\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n\t#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\t\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\t/* Exclude '\\u' from raw runs to force explicit handling */\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\u\", NULL, NULL, NULL), /* Rationale: do not include '\\u' in fast path */", "func_def": "static void\ninit_json_parser(void)", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */\n", "patched_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n// FIXME: Crash CWE-125: Out-of-bounds Read\n\t\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n\t#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\t\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\t/* Wrap string parser in guard to enforce minimal remaining input */\n\t#define GUARD_MIN_REMAIN(len, wanted) \\\n\t\t((input_len - consumed) < (len) ? NULL : (wanted))\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\tGUARD_MIN_REMAIN(6, /* Rationale: ensure at least 6 bytes for \\uXXXX */ \\\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL) /* XXX, without invalid unicode characters */))", "func_def": "static void\ninit_json_parser(void)", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, "patch_result": ""}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, NULL,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */\n", "patched_code": "init_json_parser(void) {\n\tstatic tvbparse_wanted_t _want_object;\n\tstatic tvbparse_wanted_t _want_array;\n\n\ttvbparse_wanted_t *want_object, *want_array;\n\ttvbparse_wanted_t *want_member;\n\ttvbparse_wanted_t *want_string;\n\ttvbparse_wanted_t *want_number, *want_int;\n// FIXME: Crash CWE-125: Out-of-bounds Read\n\t\ttvbparse_wanted_t *want_value;\n\ttvbparse_wanted_t *want_value_separator;\n\n\t#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\t\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);\n\n\t/* Use error callback to abort on incomplete unicode escapes */\n\tstatic void error_on_trunc_unicode(void *pd) {\n\t\terror(\"Truncated unicode escape sequence\");\n\t}\n\n\twant_string = tvbparse_set_seq(JSON_TOKEN_STRING, NULL, NULL, NULL,\n\t\t\twant_quot,\n\t\t\ttvbparse_some(-1, 0, INT_MAX, NULL, NULL, error_on_trunc_unicode,\n\t\t\t\ttvbparse_set_oneof(-1, NULL, NULL, NULL,\n\t\t\t\t\ttvbparse_not_chars(-1, 0, 0, \"\\\"\" \"\\\\\", NULL, NULL, NULL), /* XXX, without invalid unicode characters */))", "func_def": "static void\ninit_json_parser(void)", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, "guideline": "Validate all read_index and write_index operations against their respective buffer lengths to prevent out-of-bounds memory accesses (CWE-119).", "description": "Surround the 'for (int i = 0; i < 4; i++) { \u2026 }' block with a condition that ensures read_index + 4 <= input_length, and if not, break out or unwind gracefully rather than performing the loop and reading past the buffer.", "rationale": "Guarding the loop with a precondition on input length stops the code from entering a state where it dereferences beyond the string\u2019s allocated memory.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed strategy correctly identifies the need to add a precondition guarding the Unicode escape loop to prevent reads beyond the buffer, directly addressing the reported out-of-bounds scenario. It is appropriately general in scope without over-specifying code changes, making the fix plausible. However, it misstates the loop iteration count (4 instead of the actual 8 hex digits) and omits a corresponding check on the output buffer write index, so it is not fully precise. These minor inaccuracies prevent a higher score."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, "guideline": "Perform explicit input\u2010length validation before processing any escape sequence to ensure there are enough characters remaining (CWE-125).", "description": "Before entering the 8-iteration loop that consumes four hex digits for a \\uXXXX escape, add a check: if (read_index + 4 > input_length) then treat the sequence as malformed (e.g., append a replacement character or return an error) and skip further \\u parsing.", "rationale": "Checking that at least four characters remain downstream of the '\\u' token prevents any single-byte over-read when the input is truncated or malformed.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the out-of-bounds read by adding an explicit check for remaining input length before parsing the '\\uXXXX' sequence, which aligns perfectly with the identified CWE-125 root cause. The fix location is correct (just before the 8-iteration loop) and the strategy is plausible without being overly specific or hallucinated. This concise yet targeted approach should effectively prevent the one-byte overread while minimally impacting other functionality."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, "guideline": "Validate all read_index and write_index operations against their respective buffer lengths to prevent out-of-bounds memory accesses (CWE-119).", "description": "Surround the 'for (int i = 0; i < 4; i++) { \u2026 }' block with a condition that ensures read_index + 4 <= input_length, and if not, break out or unwind gracefully rather than performing the loop and reading past the buffer.", "rationale": "Guarding the loop with a precondition on input length stops the code from entering a state where it dereferences beyond the string\u2019s allocated memory.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The proposed strategy correctly identifies the need to add a precondition guarding the Unicode escape loop to prevent reads beyond the buffer, directly addressing the reported out-of-bounds scenario. It is appropriately general in scope without over-specifying code changes, making the fix plausible. However, it misstates the loop iteration count (4 instead of the actual 8 hex digits) and omits a corresponding check on the output buffer write index, so it is not fully precise. These minor inaccuracies prevent a higher score."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, "guideline": "Implement robust error handling for truncated or malformed Unicode escape sequences, substituting a safe value or aborting decoding when necessary.", "description": "Similarly, verify that the output buffer has sufficient space before appending the decoded code point. If the buffer would overflow, either grow it safely or abort with an error to avoid heap corruption.", "rationale": "Validating output space and providing a fallback for invalid escapes ensures that no write or read touches memory outside the intended heap region, preserving program stability and security.", "score": 1, "confidence": 10, "reliability_score": 2.0, "eval_rationale": "No LLM-generated fix strategies were provided in the input for evaluation, so a meaningful score cannot be assigned."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Validate input bounds before decoding escape sequences to ensure sufficient characters remain, particularly for multi-byte Unicode escapes.", "description": "In json_string_unescape, before processing a '\\\\u' escape, insert a check: if (end - p < 6) { /* incomplete \\uXXXX sequence */ goto error; } to ensure at least six characters remain in the input.", "rationale": "This prevents the one-byte out-of-bounds read by ensuring '\\\\u' sequences are only decoded when the full 6-character escape is present.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix correctly addresses the out-of-bounds read by validating that a complete '\\uXXXX' sequence is present before decoding, matching the sanitizer findings and CWE guidance. The location (json_string_unescape) is appropriate and the check `if (end - p < 6) goto error;` is a straightforward, effective guard. The advice is neither too vague nor unrealistically detailed given the known context. Hence a high score for applicability and soundness."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Ensure the output buffer has adequate capacity (with checks) before writing decoded characters, resizing or aborting if necessary.", "description": "After decoding the codepoint, verify that the destination buffer has room for up to 4 bytes (UTF-8) by checking if (out_pos + 4 > allocated_size) then realloc or error. This prevents writing past the buffer.", "rationale": "By checking and enforcing output capacity, we avoid hidden buffer overflows in the write path when converting Unicode codepoints to UTF-8.", "score": 8, "confidence": 6, "reliability_score": 12.8, "eval_rationale": "The proposed strategy directly addresses the reported out-of-bounds read by adding an explicit capacity check before writing decoded UTF-8 data and suggests reallocating or aborting when space is insufficient. This matches the described fix location and root cause, is practical to implement, and avoids hallucination. It is somewhat general in not detailing exact code insertion but is appropriately scoped for the information given."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, "guideline": "Gracefully handle truncated or malformed escape sequences by early termination or error return rather than proceeding with unsafe reads.", "description": "Add an error label in the function that frees the partially built buffer and returns NULL on malformed or truncated escape sequences, stopping any further processing.", "rationale": "Graceful handling of malformed input avoids undefined behavior and makes error paths clear, preventing unsafe continuation past invalid data.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy correctly targets the heart of the CWE-125 out-of-bounds read by inserting proper bounds checks and introducing an early error path upon detecting a truncated or malformed Unicode escape. It aligns well with the given \u2018How-To-Fix\u2019 guidelines, is feasibly applied within json_string_unescape, and avoids over-specification about code details. The approach is practical and prevents unsafe continuation, making it a high-quality fix plan."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Validate input length before processing escape sequences (CWE-125).", "description": "Before attempting to decode a \"\\uXXXX\" sequence, verify that there are at least six bytes remaining in the source buffer (backslash, 'u', and four hex digits). If the remaining length is less than six, jump to an error or truncation handler instead of reading past the end.", "rationale": "By checking that (end_ptr - current_ptr) >= 6, we eliminate any out-of-bounds read when a truncated \"\\u\" appears at the end of input.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix\u2014validating that at least six bytes remain before decoding a \"\\uXXXX\" sequence\u2014directly addresses the out-of-bounds read and aligns with CWE-125 remediation. It is plausible at the given code location and clear without over- or under-specifying implementation details. Therefore, it is an appropriate, high-quality fix strategy."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Implement explicit bounds checks on both input and output buffers when decoding Unicode escapes (CWE-119).", "description": "After computing the Unicode code point and determining the number of output bytes (1\u20134 UTF-8 bytes), check that the destination buffer has enough free capacity. If not, grow the buffer or return an error rather than writing out of bounds.", "rationale": "Ensuring output buffer capacity before writing the decoded UTF-8 prevents heap\u2010buffer\u2010overflow during expansion of multi-byte sequences.", "score": 8, "confidence": 7, "reliability_score": 13.600000000000001, "eval_rationale": "The proposed strategy correctly targets the root cause (missing bounds checks on Unicode escape decoding) and aligns with the guideline to verify both input and output capacities. It is plausible to implement at the identified location (packet-json.c around json_string_unescape) by inserting checks before buffer writes and handling insufficient space via buffer growth or error return. The answer is neither too generic (it specifically mentions computing code points, checking output capacity for 1\u20134 UTF-8 bytes, and reacting to failures) nor overly detailed about code locations not yet provided. Hence, it is a solid, realistic high-level fix plan."}, {"fix_location": {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, "guideline": "Provide a safe error-handling path for incomplete or malformed escape sequences to avoid silent overruns.", "description": "Introduce an explicit 'truncated_sequence' label that cleans up state and returns an error or replacement character when encountering incomplete or invalid hex digits, preventing further processing of a malformed escape.", "rationale": "A well-defined error path for malformed escapes avoids undefined behavior and preserves parser stability in the face of truncated or malicious inputs.", "score": 6, "confidence": 7, "reliability_score": 10.200000000000001, "eval_rationale": "The proposed strategy correctly targets the root cause (malformed or incomplete Unicode escapes) by introducing an explicit error\u2010handling path to prevent out-of-bounds reads. It aligns well with the sanitizer report and the fix location in json_string_unescape. However, it remains fairly high-level and lacks concrete code examples or precise placement within the 1287\u20131300 region, making it less immediately actionable. A more detailed patch outline or snippet would raise its utility and score."}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}], "fix_location_candidates": [{"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 355, "end_line": 375, "function_name": "", "code": "for (int i = 0; i < 8; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrent_character = string[read_index];\n\t\t\t\t\t\t\t\tread_index++;\n\t\n\t\t\t\t\t\t\t\tint nibble = ws_xton(current_character);\n\t\n\t\t\t\t\t\t\t\ttrail_surrogate <<= 4;\n\t\t\t\t\t\t\t\ttrail_surrogate |= nibble;\n\t\t\t\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs when a truncated or malformed '\\u' sequence at the end of a JSON string is processed without checking input length. Adding a bounds check around the Unicode escape handling in json_string_unescape directly addresses the root cause while preserving valid escape sequence decoding.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The LLM correctly identifies the code block responsible for consuming hex digits in a Unicode escape (specifically the 8-digit surrogate pair loop) as the fix location. This aligns directly with the reported out-of-bounds read when the input ends prematurely during escape processing. Modifications here are highly likely to prevent reading past the buffer boundary without impacting unrelated functionality. A minor point is that initial 4-digit escapes also need similar checks, but the selected location is nevertheless the core site of the vulnerability and is appropriately chosen."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 560, "end_line": 580, "function_name": "", "code": "if (unescape_strings) {\n\t\tstring = json_string_unescape(scope, string, &length);\n\t}\n\telse {\n\t\tlength = strlen(string);\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks around Unicode escape handling in json_string_unescape (called via get_json_string) to validate input length and destination buffer capacity before reading or writing, thus preventing one-byte out-of-bounds reads on truncated input.", "score": 4, "confidence": 7, "reliability_score": 6.800000000000001, "eval_rationale": "The chosen fix location at the call site (epan/dissectors/packet-json.c:560\u2013580) is too high-level and does not directly address the root cause inside json_string_unescape\u2019s Unicode escape handling. The vulnerability arises within the decoding loop for \\u sequences, so bounds checks must be placed there rather than around the call. Modifying only the call site is unlikely to fully prevent the one-byte out-of-bounds read, and could inadvertently alter program logic or skip needed processing. Therefore the selected location is not sufficiently precise or effective."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 638, "start_line": 630, "end_line": 650, "function_name": "", "code": "/* Remove the quotation marks from strings (the decoder functions\n\t * apparently expect that.)\n\t */\n\tif (value_id == JSON_TOKEN_STRING && len >= 2) {\n\t\toffset += 1;\n\t\tlen -= 2;\n\t}\n\t/* XXX - Every hf_id in packet-json_3gpp.c is a FT_STRING. Should other\n\t * types be supported (perhaps verified against the JSON token type?)\n\t * Should the encoding be ENC_UTF_8? Should the string be unescaped here?\n\t */", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs inside json_string_unescape when a truncated or malformed Unicode escape at the end of the JSON string causes reading past the input buffer. Adding a bounds check around the '\\u' handler prevents this overflow without affecting normal JSON decoding.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The LLM\u2019s selected fix location (around the initial quote trimming in packet-json.c) does not align with the real root cause in json_string_unescape\u2019s Unicode (\u2018\\u\u2019) handler. The out-of-bounds read happens during decoding of a truncated escape sequence deep inside json_string_unescape, so modifying the code where tokens are trimmed will not prevent reads past the buffer. The location is neither relevant nor likely to fix the reported overflow, hence the low score."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 1295, "start_line": 1287, "end_line": 1300, "function_name": "", "code": "tvbparse_wanted_t *want_value_separator;\n\n#define tvbparse_optional(id, private_data, before_cb, after_cb, wanted) \\\n\ttvbparse_some(id, 0, 1, private_data, before_cb, after_cb, wanted)\n\n\ttvbparse_wanted_t *want_quot = tvbparse_char(-1,\"\\\"\",NULL,NULL,NULL);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The out-of-bounds read occurs in json_string_unescape when a truncated or malformed \"\\uXXXX\" sequence at the end of input causes parsing to read beyond the allocated buffer. Adding a length check at this location prevents the overflow while preserving valid JSON string decoding.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The selected fix location (around tvbparse macros in packet-json.c lines 1287\u20131300) is unrelated to the json_string_unescape function where the out-of-bounds read actually occurs. It neither addresses Unicode \\u escape handling nor adds bounds checks in the correct code path, so it is unlikely to resolve the described vulnerability."}, {"locations": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 517, "start_line": 512, "end_line": 525, "function_name": "", "code": "else if ((IS_TRAIL_SURROGATE(code_point)))\n\t\t\t\t{\n\t\t\t\t\tis_valid_unicode_character = false;\n\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 537, "start_line": 533, "end_line": 545, "function_name": "", "code": "{\n\t\t\t\t\tif (g_unichar_validate(code_point) && g_unichar_isprint(code_point))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar length_test_buffer[6];\n\t\t\t\t\t\tint utf8_character_length = (int)g_unichar_to_utf8(code_point, length_test_buffer);\n\n\t\t\t\t\t\tfor (int i = 0; i < utf8_character_length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent_character = length_test_buffer[i];\n\t\t\t\t\t\t\twmem_strbuf_append_c(output_string_buffer, current_character);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twmem_strbuf_append_unichar_repl(output_string_buffer);\n\t\t\t\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "Add explicit bounds checks on both input (for complete Unicode escapes) and output (for buffer capacity) in json_string_unescape to eliminate the out-of-bounds read and heap overflow while preserving normal decode behavior.", "score": 4, "confidence": 8, "reliability_score": 7.2, "eval_rationale": "The selected locations focus on the code paths that handle Unicode surrogates and UTF-8 output but do not directly address the root cause of the vulnerability\u2014missing input-side bounds checks before parsing a truncated or malformed \u201c\\u\u201d escape. While adding output checks around wmem_strbuf_append_* may help prevent overflow on the output buffer, they do not stop the one-byte out-of-bounds read from the input buffer. The proposed fix locations are therefore only partially relevant and unlikely to fully resolve the described heap OOB read."}], "location_candidates": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 361, "end_line": 361, "function_name": "json_string_unescape", "code": "current_character = string[read_index];", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 567, "end_line": 567, "function_name": "get_json_string", "code": "string = json_string_unescape(scope, string, &length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/tvbparse.c", "fix_line": 946, "start_line": 946, "end_line": 946, "function_name": "execute_callbacks", "code": "if( curr->wanted->after ) curr->wanted->after(tt->data, curr->wanted->data, curr);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/tvbparse.c", "fix_line": 1007, "start_line": 1007, "end_line": 1007, "function_name": "tvbparse_get", "code": "execute_callbacks(tt,tok);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 797, "start_line": 797, "end_line": 797, "function_name": "dissect_json", "code": "while (tvbparse_get(tt, want))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "wsutil/wmem/wmem_strbuf.c", "fix_line": 388, "start_line": 388, "end_line": 388, "function_name": "wmem_strbuf_finalize", "code": "char *ret = (char *)wmem_realloc(strbuf->allocator, strbuf->str, strbuf->len+1);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 564, "start_line": 564, "end_line": 564, "function_name": "get_json_string", "code": "string = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/tvbparse.c", "fix_line": 946, "start_line": 946, "end_line": 946, "function_name": "execute_callbacks", "code": "if( curr->wanted->after ) curr->wanted->after(tt->data, curr->wanted->data, curr);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/tvbparse.c", "fix_line": 1007, "start_line": 1007, "end_line": 1007, "function_name": "tvbparse_get", "code": "execute_callbacks(tt,tok);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 797, "start_line": 797, "end_line": 797, "function_name": "dissect_json", "code": "while (tvbparse_get(tt, want))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "memory_allocate"}], "vuln_info": {"type": "CWE-125: Out-of-bounds Read", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-json.c\u2019s json_string_unescape function, unescaping of JSON string contents\u2014particularly handling of Unicode escape sequences\u2014does not enforce proper bounds checking on the buffer that holds the decoded characters. As a result, certain inputs trigger a one\u2010byte read past the end of the allocated heap buffer, leading to an out\u2010of\u2010bounds read.", "rationale": "AddressSanitizer logs report a heap-buffer-overflow in json_string_unescape: a read of size 1 occurs immediately after a 19\u2010byte region allocated for the unescaped string. The absence of boundary checks when copying or decoding escape sequences causes the function to read beyond the buffer, matching CWE-125 (Out-of-bounds Read) stemming from a buffer overflow scenario (CWE-119)."}, "vuln_info_candidates": [{"type": "CWE-125: Out-of-bounds Read", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the JSON dissector\u2019s string unescaping routine, malformed Unicode escape sequences (e.g., incomplete surrogate pairs) can cause json_string_unescape to read one byte past the end of its heap-allocated buffer. The function does not validate that the buffer contains enough data before decoding escape sequences, leading to an out-of-bounds read and heap buffer overflow.", "rationale": "AddressSanitizer reports a 1-byte heap-buffer-overflow in json_string_unescape when processing an input with a truncated \\u escape sequence. The code reallocates a buffer but fails to ensure that the subsequent unescape logic stays within its bounds. This matches CWE-119 (Buffer Overflow) manifested as CWE-125 (Out-of-bounds Read)."}, {"type": "CWE-125: Out-of-bounds Read", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "The JSON dissector\u2019s string unescaping function (`json_string_unescape` in packet-json.c) does not validate buffer boundaries when processing escape sequences. A specially crafted `\\U` Unicode escape at the very end of a string causes the routine to read one byte past the allocated buffer, resulting in an out-of-bounds read.", "rationale": "AddressSanitizer reports a one-byte heap-buffer overflow during `json_string_unescape`, reading beyond a 19-byte region. The unescape logic decodes escape sequences without checking that the source or destination buffer has sufficient remaining length, leading directly to the observed OOB read (CWE-125) and buffer overflow weakness (CWE-119)."}, {"type": "CWE-125: Out-of-bounds Read", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-json.c\u2019s json_string_unescape function, unescaping of JSON string contents\u2014particularly handling of Unicode escape sequences\u2014does not enforce proper bounds checking on the buffer that holds the decoded characters. As a result, certain inputs trigger a one\u2010byte read past the end of the allocated heap buffer, leading to an out\u2010of\u2010bounds read.", "rationale": "AddressSanitizer logs report a heap-buffer-overflow in json_string_unescape: a read of size 1 occurs immediately after a 19\u2010byte region allocated for the unescaped string. The absence of boundary checks when copying or decoding escape sequences causes the function to read beyond the buffer, matching CWE-125 (Out-of-bounds Read) stemming from a buffer overflow scenario (CWE-119)."}], "vuln_info_final": {"type": "CWE-125: Out-of-bounds Read", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In packet-json.c\u2019s json_string_unescape function, which decodes JSON string escape sequences into a heap-allocated buffer, the code fails to enforce proper bounds checking when handling Unicode \\u escape sequences. A specially crafted or incomplete escape at the very end of the input can cause the routine to read one byte past the allocated buffer boundary, resulting in an out-of-bounds read and heap buffer overflow.", "rationale": "AddressSanitizer reports a one-byte heap-buffer-overflow in json_string_unescape when processing a truncated or malformed Unicode escape sequence at the end of a JSON string. The function reallocates and fills a destination buffer without verifying that sufficient input or output space remains before decoding escape sequences, leading to an out-of-bounds read."}, "crash_stack_trace": [{"file_name": "epan/dissectors/packet-json.c", "fix_line": 361, "start_line": 361, "end_line": 361, "function_name": "json_string_unescape", "code": "current_character = string[read_index];", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 567, "start_line": 567, "end_line": 567, "function_name": "get_json_string", "code": "string = json_string_unescape(scope, string, &length);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/tvbparse.c", "fix_line": 946, "start_line": 946, "end_line": 946, "function_name": "execute_callbacks", "code": "if( curr->wanted->after ) curr->wanted->after(tt->data, curr->wanted->data, curr);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/tvbparse.c", "fix_line": 1007, "start_line": 1007, "end_line": 1007, "function_name": "tvbparse_get", "code": "execute_callbacks(tt,tok);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 797, "start_line": 797, "end_line": 797, "function_name": "dissect_json", "code": "while (tvbparse_get(tt, want))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [{"file_name": "wsutil/wmem/wmem_strbuf.c", "fix_line": 388, "start_line": 388, "end_line": 388, "function_name": "wmem_strbuf_finalize", "code": "char *ret = (char *)wmem_realloc(strbuf->allocator, strbuf->str, strbuf->len+1);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 564, "start_line": 564, "end_line": 564, "function_name": "get_json_string", "code": "string = tvb_get_string_enc(scope, tok->tvb, tok->offset, tok->len, ENC_UTF_8);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/tvbparse.c", "fix_line": 946, "start_line": 946, "end_line": 946, "function_name": "execute_callbacks", "code": "if( curr->wanted->after ) curr->wanted->after(tt->data, curr->wanted->data, curr);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/tvbparse.c", "fix_line": 1007, "start_line": 1007, "end_line": 1007, "function_name": "tvbparse_get", "code": "execute_callbacks(tt,tok);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-json.c", "fix_line": 797, "start_line": 797, "end_line": 797, "function_name": "dissect_json", "code": "while (tvbparse_get(tt, want))", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 4166, "start_line": 4166, "end_line": 4166, "function_name": "call_all_postdissectors", "code": "call_dissector_only(POSTDISSECTORS(i).handle,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/dissectors/packet-frame.c", "fix_line": 1438, "start_line": 1438, "end_line": 1438, "function_name": "dissect_frame", "code": "call_all_postdissectors(tvb, pinfo, parent_tree);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 887, "start_line": 887, "end_line": 887, "function_name": "call_dissector_through_handle", "code": "len = (handle->dissector_func.dissector_type_simple)(tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 975, "start_line": 975, "end_line": 975, "function_name": "call_dissector_work", "code": "len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3621, "start_line": 3621, "end_line": 3621, "function_name": "call_dissector_only", "code": "ret = call_dissector_work(handle, tvb, pinfo, tree, true, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 3634, "start_line": 3634, "end_line": 3634, "function_name": "call_dissector_with_data", "code": "ret = call_dissector_only(handle, tvb, pinfo, tree, data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/packet.c", "fix_line": 687, "start_line": 687, "end_line": 687, "function_name": "dissect_record", "code": "call_dissector_with_data(frame_handle, edt->tvb, &edt->pi, edt->tree, &frame_dissector_data);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "epan/epan.c", "fix_line": 666, "start_line": 666, "end_line": 666, "function_name": "epan_dissect_run", "code": "dissect_record(edt, file_type_subtype, rec, fd, cinfo);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/user/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/wireshark_ws-delta-04_vuln_007/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "wireshark_ws-delta-04_vuln_007", "sanitizer_output": "+ FUZZER=handler_json\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer handler_json -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/handler_json -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -max_len=1024 -timeout_exitcode=0 < /dev/null\noss-fuzzshark: disabling: ip\noss-fuzzshark: disabling: udp\noss-fuzzshark: disabling: udplite\noss-fuzzshark: disabling: ospf\noss-fuzzshark: disabling: bgp\noss-fuzzshark: disabling: dhcp\noss-fuzzshark: disabling: snort\noss-fuzzshark: configured for dissector: json\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 1834315026\nINFO: Loaded 1 modules   (420483 inline 8-bit counters): 420483 [0xa9f4e40, 0xaa5b8c3), \nINFO: Loaded 1 PC tables (420483 PCs): 420483 [0xaa5b8c8,0xb0c60f8), \n/out/handler_json: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n=================================================================\n==18==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x50300012dcd3 at pc 0x000006d7806d bp 0x7ffd4c55f2f0 sp 0x7ffd4c55f2e8\nREAD of size 1 at 0x50300012dcd3 thread T0\nSCARINESS: 12 (1-byte-read-heap-buffer-overflow)\n    #0 0x6d7806c in json_string_unescape /src/wireshark/epan/dissectors/packet-json.c:361:29\n    #1 0x6d7806c in get_json_string /src/wireshark/epan/dissectors/packet-json.c:567:12\n    #2 0x6d7289f in after_value /src/wireshark/epan/dissectors/packet-json.c\n    #3 0x797bc1c in execute_callbacks /src/wireshark/epan/tvbparse.c:946:39\n    #4 0x797b824 in tvbparse_get /src/wireshark/epan/tvbparse.c:1007:9\n    #5 0x6d71f7e in dissect_json /src/wireshark/epan/dissectors/packet-json.c:797:9\n    #6 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #7 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #8 0x5b8fb14 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #9 0x5b8fb14 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #10 0x544aac7 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #11 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #12 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #13 0x5b809b7 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #14 0x5b809b7 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #15 0x5b809b7 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #16 0x52bd530 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #17 0x50b3f48 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #18 0x4f66c20 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #19 0x4f51245 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #20 0x4f56cdf in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #21 0x4f82bd2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #22 0x7f4fd1d52082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #23 0x4f4942d in _start (/out/handler_json+0x4f4942d)\n\nDEDUP_TOKEN: json_string_unescape--get_json_string--after_value\n0x50300012dcd3 is located 0 bytes after 19-byte region [0x50300012dcc0,0x50300012dcd3)\nallocated by thread T0 here:\n    #0 0x5072fcc in realloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:82:3\n    #1 0x7b06b8f in g_realloc (/out/handler_json+0x7b06b8f)\n    #2 0x7a25942 in wmem_strbuf_finalize /src/wireshark/wsutil/wmem/wmem_strbuf.c:388:25\n    #3 0x6d762bb in get_json_string /src/wireshark/epan/dissectors/packet-json.c:564:11\n    #4 0x6d7289f in after_value /src/wireshark/epan/dissectors/packet-json.c\n    #5 0x797bc1c in execute_callbacks /src/wireshark/epan/tvbparse.c:946:39\n    #6 0x797b824 in tvbparse_get /src/wireshark/epan/tvbparse.c:1007:9\n    #7 0x6d71f7e in dissect_json /src/wireshark/epan/dissectors/packet-json.c:797:9\n    #8 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #9 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #10 0x5b8fb14 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #11 0x5b8fb14 in call_all_postdissectors /src/wireshark/epan/packet.c:4166:3\n    #12 0x544aac7 in dissect_frame /src/wireshark/epan/dissectors/packet-frame.c:1438:5\n    #13 0x5b84ebd in call_dissector_through_handle /src/wireshark/epan/packet.c:887:9\n    #14 0x5b84ebd in call_dissector_work /src/wireshark/epan/packet.c:975:9\n    #15 0x5b809b7 in call_dissector_only /src/wireshark/epan/packet.c:3621:8\n    #16 0x5b809b7 in call_dissector_with_data /src/wireshark/epan/packet.c:3634:8\n    #17 0x5b809b7 in dissect_record /src/wireshark/epan/packet.c:687:3\n    #18 0x52bd530 in epan_dissect_run /src/wireshark/epan/epan.c:666:2\n    #19 0x50b3f48 in LLVMFuzzerTestOneInput /src/wireshark/fuzz/fuzzshark.c:359:2\n    #20 0x4f66c20 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #21 0x4f51245 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #22 0x4f56cdf in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #23 0x4f82bd2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #24 0x7f4fd1d52082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n\nDEDUP_TOKEN: ___interceptor_realloc--g_realloc--wmem_strbuf_finalize\nSUMMARY: AddressSanitizer: heap-buffer-overflow /src/wireshark/epan/dissectors/packet-json.c:361:29 in json_string_unescape\nShadow bytes around the buggy address:\n  0x50300012da00: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x50300012da80: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x50300012db00: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x50300012db80: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x50300012dc00: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fd\n=>0x50300012dc80: fa fa fd fd fd fa fa fa 00 00[03]fa fa fa 00 00\n  0x50300012dd00: 00 00 fa fa 00 00 02 fa fa fa fa fa fa fa fa fa\n  0x50300012dd80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50300012de00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50300012de80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x50300012df00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==18==ABORTING\nMS: 0 ; base unit: 0000000000000000000000000000000000000000\n0x7b,0xa,0x20,0x20,0x22,0x73,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,0x22,0x3a,0x20,0x22,0x5c,0x55,0x30,0x30,0x30,0x30,0x64,0x38,0x33,0x64,0x5c,0x55,0x30,0x30,0x30,0x30,0x22,0xa,0x7d,0xa,0xa,\n{\\012  \\\"surrogates\\\": \\\"\\\\U0000d83d\\\\U0000\\\"\\012}\\012\\012\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/user/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/wireshark:/out -v /home/user/aixcc/dataset/tarballs/wireshark_ws-delta-04/pov/wireshark_ws-delta-04_vuln_007:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce handler_json -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/user/aixcc/san2patch-private/benchmark-projects-copy/official-afc-wireshark", "last_node": "patch_end"}