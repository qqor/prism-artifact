diff --git a/src/cmspack.c b/src/cmspack.c
index 3e9d23f..f1317ae 100644
--- a/src/cmspack.c
+++ b/src/cmspack.c
@@ -1517,28 +1517,18 @@ cmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info,
     }
     else {
 
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
-
+        {
+            /* Dynamically compute available double components and avoid OOB read */
+            cmsUInt32Number count = Stride / sizeof(cmsFloat64Number);
+            if (count < 3) {
+                cmsSignalError(ContextID, cmsERROR_RANGE, "UnrollXYZDoubleToFloat: partial data, missing components");
+            }
+            wIn[0] = (cmsFloat32Number) ((count > 0 ? Pt[0] : 0.0) / 100.0);
+            wIn[1] = (cmsFloat32Number) ((count > 1 ? (Pt[1] + 128) : 128) / 255.0);
+            wIn[2] = (cmsFloat32Number) ((count > 2 ? (Pt[2] + 128) : 128) / 255.0);
+        }
         accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
         return accum;
-    }
-}
-
-// 1.15 fixed point, that means maximum value is MAX_ENCODEABLE_XYZ (0xFFFF)
-static
-cmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,
-                                       cmsFloat32Number wIn[],
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        Stride /= PixelSize(info->InputFormat);
-
         wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);
         wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);
         wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
