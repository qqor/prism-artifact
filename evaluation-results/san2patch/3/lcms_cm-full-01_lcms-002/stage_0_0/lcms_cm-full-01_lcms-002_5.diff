diff --git a/src/cmspack.c b/src/cmspack.c
index 3e9d23f..68b0745 100644
--- a/src/cmspack.c
+++ b/src/cmspack.c
@@ -1517,28 +1517,17 @@ cmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info,
     }
     else {
 
+        /* Validate that Stride has enough bytes for three double components to prevent OOB read */
+        if (Stride < 3 * sizeof(cmsFloat64Number)) {
+            cmsSignalError(ContextID, cmsERROR_RANGE, "UnrollXYZDoubleToFloat: insufficient data, prevented out-of-bounds read");
+            return accum;
+        }
         wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
+        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // from -128..+127 to 0..1
         wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
 
         accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
         return accum;
-    }
-}
-
-// 1.15 fixed point, that means maximum value is MAX_ENCODEABLE_XYZ (0xFFFF)
-static
-cmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,
-                                       cmsFloat32Number wIn[],
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        Stride /= PixelSize(info->InputFormat);
-
         wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);
         wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);
         wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
