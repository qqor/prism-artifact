diff --git a/src/cmspack.c b/src/cmspack.c
index 3e9d23f..51a8ae5 100644
--- a/src/cmspack.c
+++ b/src/cmspack.c
@@ -1517,28 +1517,21 @@ cmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info,
     }
     else {
 
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
-        wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
+        /* Per-channel boundary check in a loop to prevent OOB reads */
+        for (cmsUInt32Number i = 0; i < 3; i++) {
+            if ((cmsUInt8Number*)(Pt + i + 1) <= accum + Stride) {
+                switch (i) {
+                    case 0: wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0); break;
+                    case 1: wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0); break;
+                    case 2: wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0); break;
+                }
+            } else {
+                wIn[i] = 0.0f; // default on missing data
+            }
+        }
 
         accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
         return accum;
-    }
-}
-
-// 1.15 fixed point, that means maximum value is MAX_ENCODEABLE_XYZ (0xFFFF)
-static
-cmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,
-                                       cmsFloat32Number wIn[],
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        Stride /= PixelSize(info->InputFormat);
-
         wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);
         wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);
         wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
