diff --git a/src/cmspack.c b/src/cmspack.c
index 3e9d23f..90df30d 100644
--- a/src/cmspack.c
+++ b/src/cmspack.c
@@ -1517,28 +1517,20 @@ cmsUInt8Number* UnrollLabFloatToFloat(_cmsTRANSFORM* info,
     }
     else {
 
-        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);            // from 0..100 to 0..1
-        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);    // form -128..+127 to 0..1
+        /* Prevent OOB by checking pointer boundaries */
+        {
+            cmsUInt8Number* end = accum + Stride;
+            if ((cmsUInt8Number*)(Pt + 3) > end) {
+                cmsSignalError(ContextID, cmsERROR_RANGE, "UnrollXYZDoubleToFloat: buffer end exceeded");
+                return accum;
+            }
+        }
+        wIn[0] = (cmsFloat32Number) (Pt[0] / 100.0);
+        wIn[1] = (cmsFloat32Number) ((Pt[1] + 128) / 255.0);
         wIn[2] = (cmsFloat32Number) ((Pt[2] + 128) / 255.0);
 
         accum += sizeof(cmsFloat32Number)*(3 + T_EXTRA(info ->InputFormat));
         return accum;
-    }
-}
-
-// 1.15 fixed point, that means maximum value is MAX_ENCODEABLE_XYZ (0xFFFF)
-static
-cmsUInt8Number* UnrollXYZDoubleToFloat(_cmsTRANSFORM* info,
-                                       cmsFloat32Number wIn[],
-                                       cmsUInt8Number* accum,
-                                       cmsUInt32Number Stride)
-{
-    cmsFloat64Number* Pt = (cmsFloat64Number*) accum;
-
-    if (T_PLANAR(info -> InputFormat)) {
-
-        Stride /= PixelSize(info->InputFormat);
-
         wIn[0] = (cmsFloat32Number) (Pt[0] / MAX_ENCODEABLE_XYZ);
         wIn[1] = (cmsFloat32Number) (Pt[Stride] / MAX_ENCODEABLE_XYZ);
         wIn[2] = (cmsFloat32Number) (Pt[Stride*2] / MAX_ENCODEABLE_XYZ);
