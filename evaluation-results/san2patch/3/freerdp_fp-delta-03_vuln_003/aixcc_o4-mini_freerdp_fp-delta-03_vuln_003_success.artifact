{"vuln_data": {"id": "freerdp_fp-delta-03_vuln_003", "subject": "freerdp", "work_name": "freerdp", "project_name": "freerdp", "hiding_project_name": "", "project_full_name": "freerdp", "harness_name": "TestFuzzCodecs", "branch_name": "fp-delta-03", "project_repo_name": "official-afc-freerdp"}, "data_type": "oss-fuzz", "patch_success": ["vuln_test_failed", "build_failed", "build_failed", "success", ""], "ret_code": false, "err_msg": "", "genpatch_candidate": [{"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t/* Data messages:\n\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tif (!ok)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, "patch_result": "vuln_test_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ switch (blockType)\n \t\tcase WBT_METADATA:\n-\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n-\t\t\t                         &context->expectedDataBlockType);\n-\t\t\tif (!ok)\n-\t\t\t{\n-\t\t\t\tWLog_ERR(TAG, \"Metadata processing failed\");\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t\t/* Explicit boundary check */\n-\t\t\tif (message->metadata.pixelIndex + message->metadata.runLengthFactor > context->pixelCount)\n-\t\t\t{\n-\t\t\t\tWLog_ERR(TAG, \"Invalid metadata run: index=%u length=%u count=%u\",\n-\t\t\t\t         message->metadata.pixelIndex, message->metadata.runLengthFactor,\n-\t\t\t\t         context->pixelCount);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n+\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n+\t\t\t                         &context->expectedDataBlockType);\n+\t\t\tif (!ok)\n+\t\t\t{\n+\t\t\t\tWLog_ERR(TAG, \"Metadata processing failed\");\n+\t\t\t\treturn FALSE;\n+\t\t\t}\n+\t\t\t/* Explicit boundary check */\n+\t\t\tif (message->message_data.metadata.pixelIndex + message->message_data.metadata.runLengthFactor > context->pixel_count)\n+\t\t\t{\n+\t\t\t\tWLog_ERR(TAG, \"Invalid metadata run: index=%u length=%u count=%u\",\n+\t\t\t\t         message->message_data.metadata.pixelIndex,\n+\t\t\t\t         message->message_data.metadata.runLengthFactor,\n+\t\t\t\t         context->pixel_count);\n+\t\t\t\treturn FALSE;\n+\t\t\t}\n", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "--- a/libfreerdp/codec/rfx.c\n+++ b/libfreerdp/codec/rfx.c\n@@ switch (blockType)\n-           case WBT_METADATA:\n-           {\n-               UINT32 idx, len;\n-               ok = rfx_process_message_metadata(context, message, subStream,\n-                                                &context->expectedDataBlockType);\n-               if (!ok)\n-                   return FALSE;\n-               idx = message->metadata.pixelIndex;\n-               len = message->metadata.runLengthFactor;\n-               /* Prevent overflow and ensure within pixel buffer */\n-               if (idx > context->pixelCount || len > context->pixelCount || idx + len > context->pixelCount)\n-               {\n-                   WLog_ERR(TAG, \"Out-of-bounds metadata run: index=%u length=%u count=%u\",\n-                            idx, len, context->pixelCount);\n-                   return FALSE;\n-               }\n-           }\n-               break;\n+           case WBT_METADATA:\n+           {\n+               UINT32 idx, len;\n+               ok = rfx_process_message_metadata(context, message, subStream,\n+                                                &context->expectedDataBlockType);\n+               if (!ok)\n+                   return FALSE;\n+               /* Access the anonymous union named 'message', then metadata */\n+               idx = message->message.metadata.pixelIndex;\n+               len = message->message.metadata.runLengthFactor;\n+               /* Prevent overflow and ensure within the received pixel data buffer */\n+               if (idx >= context->pixelDataCount || len > context->pixelDataCount ||\n+                   idx + len > context->pixelDataCount)\n+               {\n+                   WLog_ERR(TAG,\n+                            \"Out-of-bounds metadata run: index=%u length=%u count=%u\",\n+                            idx, len, context->pixelDataCount);\n+                   return FALSE;\n+               }\n+           }\n+               break;", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, "patch_result": "build_failed"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t/* Data messages:\n\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n\t\t\tcase WBT_METADATA:\n\t\t\t{\n\t\t\t\tsize_t avail = Stream_GetRemainingLength(subStream);\n\t\t\t\t/* Ensure stream has enough data for at least two UINT32 values */\n\t\t\t\tif (avail < 8)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Insufficient metadata length: %zu bytes\", avail);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tif (!ok)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, "patch_result": "success"}, {"fix_strategy": {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_METADATA:\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "patched_code": "switch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t/* Data messages:\n\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n// FIXME: Crash CWE-787: Out-of-bounds Write\n \n\t\t\tcase WBT_METADATA:\n\t\t\t\t/* Process metadata and silently drop invalid runs */\n\t\t\t\tok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tif (!ok)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tif (message->metadata.pixelIndex + message->metadata.runLengthFactor > context->pixelCount)\n\t\t\t\t{\n\t\t\t\t\tWLog_WARN(TAG, \"Dropping out-of-bounds metadata run: index=%u length=%u count=%u\",\n\t\t\t\t\t          message->metadata.pixelIndex, message->metadata.runLengthFactor,\n\t\t\t\t\t          context->pixelCount);\n\t\t\t\t\tok = FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}", "func_def": "static INLINE void rfx_profiler_print(RFX_CONTEXT* WINPR_RESTRICT context)", "func_ret": ["return;", "return NULL;", "return NULL;", "return tile;", "return winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);", "return rfx_context_new_ex(encoder, 0);", "return NULL;", "return context;", "return;", "return message->tiles[index];", "return &message->rects[index];", "return &message->rects[index];", "return context->pixel_format;", "return context->palette;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return rc;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return message->quantVals;", "return cnv.ppc;", "return message->numTiles;", "return message->rects;", "return message->numRects;", "return;", "return FALSE;", "return TRUE;", "return 19ull + tile->YLen + tile->CbLen + tile->CrLen;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return region16_intersect_rect(region, region, &mainRect);", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return TRUE;", "return rfx_allocate_tiles(message, alloc, TRUE);", "return NULL;", "return message;", "return NULL;", "return TRUE;", "return FALSE;", "return TRUE;", "return TRUE;", "return TRUE;", "return NULL;", "return messages;", "return NULL;", "return NULL;", "return &messages->list[idx];", "return;", "return msg;", "return NULL;", "return NULL;", "return rfx_message_list_new(context, list, *numMessages);", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return TRUE;", "return FALSE;", "return ret;", "return TRUE;", "return context->mode;", "return context->frameIdx;", "return message->frameIdx;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return FALSE;", "return (used == blockLen);", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return FALSE;", "return TRUE;", "return \"PROGRESSIVE_WBT_SYNC\";", "return \"PROGRESSIVE_WBT_FRAME_BEGIN\";", "return \"PROGRESSIVE_WBT_FRAME_END\";", "return \"PROGRESSIVE_WBT_CONTEXT\";", "return \"PROGRESSIVE_WBT_REGION\";", "return \"PROGRESSIVE_WBT_TILE_SIMPLE\";", "return \"PROGRESSIVE_WBT_TILE_FIRST\";", "return \"PROGRESSIVE_WBT_TILE_UPGRADE\";", "return \"PROGRESSIVE_WBT_UNKNOWN\";", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return FALSE;", "return TRUE;"]}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, "patch_result": ""}], "fix_strategy": {"fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "patch_result": "", "fix_strategy_final": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}, "guideline": "Reject or sanitize any run metadata that would cause pixelIndex + runLengthFactor to exceed the allocated pixelCount.", "description": "Alternatively, sanitize malformed runs by clamping the runLengthFactor:\n\n    if (pixelIndex < pixelCount && pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        WLog_WARN(TAG, \"Clamping runLengthFactor to %u to prevent overflow\", runLengthFactor);\n    }\n\nThen proceed with the write; this avoids aborting the entire frame decode.", "rationale": "Clamping preserves as much decoded data as possible while guaranteeing no overflow; it also logs a warning so malformed messages are flagged without dropping the entire session.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing boundary checks on pixelIndex + runLengthFactor\u2014by clamping runLengthFactor when it would overflow the pixel buffer. It aligns well with the sanitizer report, preserves most decoded data, and logs a warning for malformed input without dropping the frame. The strategy is neither too vague nor unrealistically specific and is applicable at the correct location in rfx_process_message_metadata. A small deduction is applied only because the exact patch context (line numbers) isn\u2019t fully detailed, but overall this is a sound and practical remediation."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}, "guideline": "Validate pixelIndex and runLengthFactor against pixelCount before writing", "description": "Insert a boundary check immediately after reading pixelIndex and runLengthFactor inside rfx_process_message_metadata. For example:\n\n    /* after decoding pixelIndex and runLengthFactor */\n    if (pixelIndex >= pixelCount || pixelIndex + runLengthFactor > pixelCount) {\n        WLog_WARN(TAG, \"Invalid run: index %u, length %u, buffer size %u\", pixelIndex, runLengthFactor, pixelCount);\n        continue;  /* skip this run to avoid out-of-bounds write */\n    }\n", "rationale": "Prevents writes past the end of the pixel buffer by ensuring both start and end indices are within bounds, directly addressing CWE-787.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix directly addresses the root cause by validating both the start and end of the pixel run against the buffer size, which aligns precisely with the reported out-of-bounds write in rfx_process_message_metadata. The suggested boundary check is straightforward, applicable at the correct location, and unlikely to impact other logic. It isn\u2019t overly generic\u2014offering a concrete insertion point and code snippet\u2014yet it avoids unrealistic specificity by not depending on unseen code context. This makes it a high-quality, practical remediation."}], "fix_strategy_candidates": [{"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Perform explicit boundary checks on decoded metadata fields to ensure indexes and lengths do not exceed buffer boundaries (CWE-787).", "description": "Immediately after decoding pixelIndex and runLengthFactor in rfx_process_message_metadata, insert code such as: if (pixelIndex < 0 || runLengthFactor < 0 || pixelIndex + runLengthFactor > pixelCount) { WLog_ERR(TAG, \"Invalid metadata run: index=%d length=%d count=%d\", pixelIndex, runLengthFactor, pixelCount); return FALSE; } This ensures no write is attempted outside the pixel buffer.", "rationale": "Directly checking pixelIndex and runLengthFactor against pixelCount before each write eliminates the possibility of an out-of-bounds write at its source, addressing CWE-787.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause by inserting explicit boundary checks on pixelIndex and runLengthFactor before any buffer writes. It aligns precisely with CWE-787 mitigation guidelines and is plausible to implement at the correct location (inside rfx_process_message_metadata). The answer is neither overly generic nor hallucinated, yet it avoids unrealistic specificity about exact line numbers in the decoding logic, making it a solid, actionable fix."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Use safe buffer functions or length-limited operations to prevent buffer overflows (SEI CERT C).", "description": "Replace any direct pointer arithmetic and looped writes over the pixel buffer with a single call to a length-checked copy function, e.g.: memcpy_s(&pixels[pixelIndex], (pixelCount - pixelIndex) * sizeof(uint32_t), decodedPixels, runLengthFactor * sizeof(uint32_t)); if (rc != 0) return FALSE;", "rationale": "Using a safer API like memcpy_s centralizes the bounds check and prevents accidental misuse of raw pointers or loops that might be miscalculated.", "score": 7, "confidence": 7, "reliability_score": 11.900000000000002, "eval_rationale": "The suggested use of memcpy_s to centralize bounds checking directly addresses the out-of-bounds write by ensuring pixelIndex+runLengthFactor can\u2019t exceed pixelCount. This aligns with the CWE-787 root cause and the provided guideline to use safe buffer functions. However, the answer is somewhat generic \u2013 it doesn\u2019t pinpoint the exact insertion point within rfx_process_message_metadata, nor does it mention validating pixelIndex and runLengthFactor separately before the copy. Additionally, memcpy_s may not be available in all codebases, so portability concerns remain. Overall the strategy is sound and plausible but lacks some detail and context."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, "guideline": "Fail fast on invalid input metadata by validating message integrity before processing (defensive programming, CWE-20).", "description": "Pre-validate the entire metadata block before pixel writes: accumulate totalRunLength across all runs and compare to pixelCount. If totalRunLength exceeds pixelCount, abort processing early. This stops any subsequent per-run operations from overflowing.", "rationale": "Failing early on invalid metadata protects downstream logic from operating on corrupted data, reducing attack surface and preventing buffer overflows due to cumulative miscalculations.", "score": 5, "confidence": 8, "reliability_score": 9.0, "eval_rationale": "The proposed strategy correctly identifies the need for early validation (defensive programming, CWE-20) and the idea of summing run lengths against the pixelCount is sound for preventing cumulative overflows. However, it overlooks per-run boundary checks (pixelIndex + runLengthFactor for each run) and does not specify exactly where in rfx_process_message_metadata the validation should be inserted. The fix is plausible but incomplete and too high-level to guarantee elimination of all out-of-bounds cases without additional per-run checks and precise patch location guidance."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}, "guideline": "Perform strict bounds checking on all decoded offsets and lengths before writing to the pixel buffer.", "description": "In rfx_process_message_metadata, immediately before writing each run to the pixel buffer, insert:\n\n    if (pixelIndex >= pixelCount || runLengthFactor > pixelCount - pixelIndex) {\n        WLog_WARN(TAG, \"Invalid run: index=%u length=%u exceeds buffer size=%u\", pixelIndex, runLengthFactor, pixelCount);\n        return ERROR_RFX_DECODE;\n    }\n\nThis check guarantees that pixelIndex + runLengthFactor never exceeds pixelCount.", "rationale": "By checking pixelIndex and runLengthFactor against pixelCount immediately before each write, we eliminate the possibility of writing past the end of the buffer, directly addressing CWE-787.", "score": 8, "confidence": 8, "reliability_score": 14.4, "eval_rationale": "The proposed fix directly addresses the root cause (missing bounds checks) by validating both pixelIndex and runLengthFactor against pixelCount before each write, which is exactly what the vulnerability requires (CWE-787). The strategy is plausible and implements a clear guard (with logging and an error return) without over\u2010specializing to code that isn\u2019t shown yet. It neither hallucinates unrealistic details nor remains too vague. A slightly higher score is held back only because the exact insertion point within rfx_process_message_metadata isn\u2019t pinpointed, but the overall approach is sound and ready for implementation."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}, "guideline": "Reject or sanitize any run metadata that would cause pixelIndex + runLengthFactor to exceed the allocated pixelCount.", "description": "Alternatively, sanitize malformed runs by clamping the runLengthFactor:\n\n    if (pixelIndex < pixelCount && pixelIndex + runLengthFactor > pixelCount) {\n        runLengthFactor = pixelCount - pixelIndex;\n        WLog_WARN(TAG, \"Clamping runLengthFactor to %u to prevent overflow\", runLengthFactor);\n    }\n\nThen proceed with the write; this avoids aborting the entire frame decode.", "rationale": "Clamping preserves as much decoded data as possible while guaranteeing no overflow; it also logs a warning so malformed messages are flagged without dropping the entire session.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed fix directly addresses the root cause\u2014missing boundary checks on pixelIndex + runLengthFactor\u2014by clamping runLengthFactor when it would overflow the pixel buffer. It aligns well with the sanitizer report, preserves most decoded data, and logs a warning for malformed input without dropping the frame. The strategy is neither too vague nor unrealistically specific and is applicable at the correct location in rfx_process_message_metadata. A small deduction is applied only because the exact patch context (line numbers) isn\u2019t fully detailed, but overall this is a sound and practical remediation."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}, "guideline": "Implement fail-safe error handling: if invalid metadata is detected, abort processing to avoid memory corruption.", "description": "Before the main run\u2010decoding loop, perform a validation pass over all runs in the metadata block:\n\n    for (i = 0; i < runCount; i++) {\n        if (runs[i].index >= pixelCount || runs[i].length > pixelCount - runs[i].index) {\n            WLog_ERR(TAG, \"Metadata validation failed at run %d: index=%u length=%u > %u\", i, runs[i].index, runs[i].length, pixelCount);\n            return ERROR_RFX_DECODE;\n        }\n    }\n\nThis ensures no out\u2010of\u2010bounds runs are ever processed.", "rationale": "A preliminary validation pass enforces data integrity for the entire message, catching corrupt or malicious metadata up front and preventing any unsafe memory accesses.", "score": 9, "confidence": 8, "reliability_score": 16.2, "eval_rationale": "The proposed strategy directly addresses the identified root cause (missing boundary checks in rfx_process_message_metadata) with a clear validation loop that prevents out\u2010of\u2010bounds writes and aborts on error. It is pragmatic and likely to be effective without over- or under-detailing the implementation location. It aligns well with the sanitizer findings and cleanly integrates fail\u2010safe error handling. Hence a high score is warranted."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}, "guideline": "Validate pixelIndex and runLengthFactor against pixelCount before writing", "description": "Insert a boundary check immediately after reading pixelIndex and runLengthFactor inside rfx_process_message_metadata. For example:\n\n    /* after decoding pixelIndex and runLengthFactor */\n    if (pixelIndex >= pixelCount || pixelIndex + runLengthFactor > pixelCount) {\n        WLog_WARN(TAG, \"Invalid run: index %u, length %u, buffer size %u\", pixelIndex, runLengthFactor, pixelCount);\n        continue;  /* skip this run to avoid out-of-bounds write */\n    }\n", "rationale": "Prevents writes past the end of the pixel buffer by ensuring both start and end indices are within bounds, directly addressing CWE-787.", "score": 9, "confidence": 7, "reliability_score": 15.3, "eval_rationale": "The proposed fix directly addresses the root cause by validating both the start and end of the pixel run against the buffer size, which aligns precisely with the reported out-of-bounds write in rfx_process_message_metadata. The suggested boundary check is straightforward, applicable at the correct location, and unlikely to impact other logic. It isn\u2019t overly generic\u2014offering a concrete insertion point and code snippet\u2014yet it avoids unrealistic specificity by not depending on unseen code context. This makes it a high-quality, practical remediation."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}, "guideline": "Reject or skip runs with invalid metadata to prevent OOB writes", "description": "Place this check just before any write to the pixel buffer (e.g., memcpy or direct assignment) so that no write can occur if the run would exceed the buffer.", "rationale": "Skipping invalid runs avoids memory corruption from malformed or malicious metadata without disrupting other decoding steps.", "score": 7, "confidence": 8, "reliability_score": 12.6, "eval_rationale": "The suggested strategy\u2014validating run offsets and lengths against the remaining pixel buffer and skipping invalid runs\u2014is well aligned with the root cause (missing boundary checks leading to OOB writes). It correctly targets the write location and prevents out-of-bounds writes without changing core decoding logic. However, the response remains somewhat high-level and lacks concrete code insertion points or example checks, making it less actionable than a fully detailed patch. Thus, it earns a solid but not perfect score."}, {"fix_location": {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}, "guideline": "Use defensive programming to handle corrupt or malicious messages gracefully", "description": "Leaves existing processing logic intact for valid runs, while safely skipping only those runs whose metadata would overflow the buffer.", "rationale": "Graceful handling of bad data reduces crash risk and preserves decoder behavior for all well-formed messages.", "score": 0.1, "confidence": 0.1, "reliability_score": 0.101, "eval_rationale": ""}], "fix_location": {"locations": [], "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": ""}, "guideline": "", "description": "", "rationale": "", "score": 0.0, "confidence": 0.0, "reliability_score": 0.0, "eval_rationale": "", "fix_location_final": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}], "fix_location_candidates": [{"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 720, "end_line": 750, "function_name": "", "code": "if (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\t*(UINT64*)metadataBlock = metadataData;\n\treturn TRUE;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability arises because pixelIndex + runLengthFactor is never checked against pixelCount, allowing a crafted message to overflow the pixel buffer. Inserting a boundary check around the core write loop in rfx_process_message_metadata (around line 734) ensures that invalid metadata cannot trigger an out-of-bounds write, eliminating the CWE-787 buffer overflow without impacting other functionality.", "score": 2, "confidence": 9, "reliability_score": 3.8, "eval_rationale": "The suggested fix location (around the magic number check and metadataBlock assignment at lines 720\u2013750) is unrelated to the actual out-of-bounds write. The vulnerability stems from unchecked pixelIndex + runLengthFactor in the core write loop of rfx_process_message_metadata, but the LLM pointed to the wrong function area and did not address the run-length decoding logic. Therefore, the selected location is unlikely to resolve the overflow and does not align with the root cause."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1310, "end_line": 1330, "function_name": "", "code": "ok = rfx_process_message_metadata(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The rfx_process_message_metadata path in rfx.c does not validate decoded pixel run offsets and lengths against the allocated pixel buffer. Inserting boundary checks around line 1320 ensures that pixelIndex + runLengthFactor cannot overflow the buffer and eliminates the out-of-bounds write.", "score": 3, "confidence": 8, "reliability_score": 5.4, "eval_rationale": "The LLM pointed to the call site of rfx_process_message_metadata (libfreerdp/codec/rfx.c lines 1310\u20131330), rather than addressing the buffer\u2010boundary checks inside that function where pixelIndex and runLengthFactor are computed and applied. While it identified the correct function, modifying the caller does not prevent out-of-bounds writes within rfx_process_message_metadata itself. This location is unlikely to resolve the true root cause and could disrupt core functionality without fixing the vulnerability."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1822, "start_line": 1800, "end_line": 1840, "function_name": "", "code": "if (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "The vulnerability stems from missing validation of decoded metadata (pixelIndex and runLengthFactor) against the allocated pixelCount. By adding a check just prior to writing into the pixel buffer, we ensure no write occurs beyond the end of the buffer, eliminating the out-of-bounds write without altering other functionality.", "score": 2, "confidence": 7, "reliability_score": 3.4000000000000004, "eval_rationale": "The selected location in libfreerdp/codec/rfx.c (lines 1800\u20131840) is in the tile allocation loop, not in rfx_process_message_metadata where pixelIndex and runLengthFactor are parsed and used. Adding a boundary check here would not intercept the out-of-bounds write, which occurs later when writing into the pixel buffer. The fix site is unrelated to the root cause, so it is unlikely to resolve the vulnerability and could disrupt other encoding functionality."}, {"locations": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 250, "start_line": 230, "end_line": 260, "function_name": "", "code": "else\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "rationale": "In rfx_process_message_metadata, the decoded run offsets and lengths (pixelIndex and runLengthFactor) must be checked against the buffer size (pixelCount) before use. Adding a bounds check around line 250 ensures we never write past the end of the allocated pixel buffer, eliminating the out\u2010of\u2010bounds write without changing other logic.", "score": 2, "confidence": 8, "reliability_score": 3.6, "eval_rationale": "The proposed fix location in rfx.c (lines 230\u2013260) merely sets decoder object function pointers and is unrelated to the pixel buffer processing in rfx_process_message_metadata. This location does not cover the code that uses pixelIndex or runLengthFactor, so adding bounds checks here would not address the out-of-bounds write. The chosen spot is therefore irrelevant and ineffective for resolving the reported buffer overflow."}], "location_candidates": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/codec/test/TestFuzzCodecs.c", "fix_line": 184, "start_line": 184, "end_line": 184, "function_name": "TestFreeRDPCodecRemoteFX", "code": "if (!rfx_process_message(context, Data, (UINT32)Size, 0, 0, dest, FORMAT, (UINT32)stride,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}, {"file_name": "libfreerdp/codec/test/TestFuzzCodecs.c", "fix_line": 460, "start_line": 460, "end_line": 460, "function_name": "LLVMFuzzerTestOneInput", "code": "TestFreeRDPCodecRemoteFX(Data, Size);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": [], "type": "crash"}], "vuln_info": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the rfx_process_message_metadata function of libfreerdp/codec/rfx.c, metadata length and offset fields derived from RemoteFX messages are not validated before being used to write into an internal buffer. When processing malicious or malformed metadata, this can result in writes beyond the buffer\u2019s boundaries, causing an out-of-bounds write and potential memory corruption.", "rationale": "AddressSanitizer reports a wild write in rfx_process_message_metadata, triggered by invalid metadata parameters that cause pixelIndex + runLengthFactor to exceed pixelCount. The lack of boundary checks on these derived values allows data to be written outside the allocated buffer, leading to a classic out-of-bounds write vulnerability (CWE-787)."}, "vuln_info_candidates": [{"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec\u2019s rfx_process_message_metadata function, decoded pixel run lengths are not validated against the remaining buffer size. Specifically, pixelIndex and runLengthFactor are added without ensuring they do not exceed pixelCount, allowing writes past the end of the pixel buffer.", "rationale": "AddressSanitizer detected a wild write in rfx_process_message_metadata when pixelIndex + runLengthFactor exceeded pixelCount, confirming that missing boundary checks on decoded data lead to an out-of-bounds write (CWE-787), a form of buffer overflow (CWE-119)."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX codec\u2019s rfx_process_message_metadata function, the code decodes pixel runs using pixelIndex and runLengthFactor but fails to verify that their sum stays within the allocated pixel buffer (pixelCount). A crafted message can trigger pixelIndex + runLengthFactor to exceed pixelCount, causing the decoder to write past the end of the buffer.", "rationale": "AddressSanitizer reports a SEGV due to a wild write at rfx.c:734 when pixelIndex + runLengthFactor > pixelCount. The absence of a boundary check before writing residual pixel data allows an attacker-supplied length value to drive an out-of-bounds memory write, leading to memory corruption or crash."}, {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the rfx_process_message_metadata function of libfreerdp/codec/rfx.c, metadata length and offset fields derived from RemoteFX messages are not validated before being used to write into an internal buffer. When processing malicious or malformed metadata, this can result in writes beyond the buffer\u2019s boundaries, causing an out-of-bounds write and potential memory corruption.", "rationale": "AddressSanitizer reports a wild write in rfx_process_message_metadata, triggered by invalid metadata parameters that cause pixelIndex + runLengthFactor to exceed pixelCount. The lack of boundary checks on these derived values allows data to be written outside the allocated buffer, leading to a classic out-of-bounds write vulnerability (CWE-787)."}], "vuln_info_final": {"type": "CWE-787: Out-of-bounds Write", "root_cause": "CWE-119: Buffer Overflow", "comprehension": "In the RemoteFX decoder\u2019s rfx_process_message_metadata function (libfreerdp/codec/rfx.c), decoded pixel run offsets (pixelIndex) and lengths (runLengthFactor) derived from message metadata are not validated against the remaining buffer size (pixelCount). A crafted or malformed message can cause pixelIndex + runLengthFactor to exceed the allocated pixel buffer, allowing writes past its end and triggering memory safety violations.", "rationale": "AddressSanitizer reported a wild write in rfx_process_message_metadata when pixelIndex + runLengthFactor exceeded pixelCount, confirming that missing boundary checks on decoded metadata parameters lead to an out-of-bounds write (CWE-787) and buffer overflow (CWE-119), potentially resulting in memory corruption or crashes."}, "crash_stack_trace": [{"file_name": "libfreerdp/codec/rfx.c", "fix_line": 734, "start_line": 734, "end_line": 734, "function_name": "rfx_process_message_metadata", "code": "*(UINT64*)metadataBlock = metadataData;", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/rfx.c", "fix_line": 1320, "start_line": 1320, "end_line": 1320, "function_name": "rfx_process_message", "code": "ok = rfx_process_message_metadata(context, message, subStream,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/test/TestFuzzCodecs.c", "fix_line": 184, "start_line": 184, "end_line": 184, "function_name": "TestFreeRDPCodecRemoteFX", "code": "if (!rfx_process_message(context, Data, (UINT32)Size, 0, 0, dest, FORMAT, (UINT32)stride,", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}, {"file_name": "libfreerdp/codec/test/TestFuzzCodecs.c", "fix_line": 460, "start_line": 460, "end_line": 460, "function_name": "LLVMFuzzerTestOneInput", "code": "TestFreeRDPCodecRemoteFX(Data, Size);", "original_code": "", "patched_code": "", "func_def": "", "func_ret": []}], "memory_allocate_stack_trace": [], "memory_free_stack_trace": [], "mode": "test", "diff_stage_dir": "/home/qqor/aixcc/san2patch-private/benchmarks/final/oss-fuzz/gen_diff_aixcc_o4-mini/freerdp_fp-delta-03_vuln_003/stage_0_0", "experiment_name": "aixcc_o4-mini", "select_method": "sample", "vuln_id": "freerdp_fp-delta-03_vuln_003", "sanitizer_output": "+ FUZZER=TestFuzzCodecs\n+ shift\n+ '[' '!' -v TESTCASE ']'\n+ TESTCASE=/testcase\n+ '[' '!' -f /testcase ']'\n+ export RUN_FUZZER_MODE=interactive\n+ RUN_FUZZER_MODE=interactive\n+ export FUZZING_ENGINE=libfuzzer\n+ FUZZING_ENGINE=libfuzzer\n+ export SKIP_SEED_CORPUS=1\n+ SKIP_SEED_CORPUS=1\n+ run_fuzzer TestFuzzCodecs -runs=100 /testcase\nvm.mmap_rnd_bits = 28\n/out/TestFuzzCodecs -rss_limit_mb=2560 -timeout=25 -runs=100 /testcase -timeout_exitcode=0 < /dev/null\nINFO: Running with entropic power schedule (0xFF, 100).\nINFO: Seed: 2861379149\nINFO: Loaded 1 modules   (20557 inline 8-bit counters): 20557 [0x55878a271be8, 0x55878a276c35), \nINFO: Loaded 1 PC tables (20557 PCs): 20557 [0x55878a276c38,0x55878a2c7108), \n/out/TestFuzzCodecs: Running 1 inputs 100 time(s) each.\nRunning: /testcase\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1326\n[02:02:04:761] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 257 != pixelCount 1536\n[02:02:04:763] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress_residual_data]: pixelIndex 64 + runLengthFactor 193 > pixelCount 105\n[02:02:04:764] [18:00000012] [ERROR][com.freerdp.codec.clear] - [clear_decompress]: clear_decompress_residual_data failed!\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==18==ERROR: AddressSanitizer: SEGV on unknown address 0x7f3f57262e20 (pc 0x558789e54fc5 bp 0x7ffef214fb90 sp 0x7ffef214f960 T0)\n==18==The signal is caused by a WRITE memory access.\nSCARINESS: 30 (wild-addr-write)\n    #0 0x558789e54fc5 in rfx_process_message_metadata /src/FreeRDP/libfreerdp/codec/rfx.c:734:26\n    #1 0x558789e54fc5 in rfx_process_message /src/FreeRDP/libfreerdp/codec/rfx.c:1320:10\n    #2 0x558789e2273d in TestFreeRDPCodecRemoteFX /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:184:7\n    #3 0x558789e2273d in LLVMFuzzerTestOneInput /src/FreeRDP/libfreerdp/codec/test/TestFuzzCodecs.c:460:2\n    #4 0x558789cd90f0 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13\n    #5 0x558789cc4365 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6\n    #6 0x558789cc9dff in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9\n    #7 0x558789cf50a2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10\n    #8 0x7f3f571de082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 5792732f783158c66fb4f3756458ca24e46e827d)\n    #9 0x558789cbc54d in _start (/out/TestFuzzCodecs+0x12a54d)\n\nDEDUP_TOKEN: rfx_process_message_metadata--rfx_process_message--TestFreeRDPCodecRemoteFX\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /src/FreeRDP/libfreerdp/codec/rfx.c:734:26 in rfx_process_message_metadata\n==18==ABORTING\nsubprocess command returned a non-zero exit status: 1\n\nINFO:__main__:Running: docker run --privileged --shm-size=2g --platform linux/amd64 --rm -e HELPER=True -e ARCHITECTURE=x86_64 -v /home/qqor/aixcc/san2patch-private/oss-fuzz-aixcc/build/out/freerdp:/out -v /home/qqor/aixcc/dataset/tarballs/freerdp_fp-delta-03/pov/freerdp_fp-delta-03_vuln_003:/testcase -t ghcr.io/aixcc-finals/base-runner:v1.3.0 reproduce TestFuzzCodecs -runs=100.\n", "package_language": "C", "package_name": "", "package_location": "/home/qqor/aixcc/san2patch-private/benchmark-projects-copy/official-afc-freerdp", "last_node": "patch_end"}