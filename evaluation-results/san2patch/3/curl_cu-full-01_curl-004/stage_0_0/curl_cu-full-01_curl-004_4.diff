diff --git a/lib/mprintf.c b/lib/mprintf.c
index 35e40e302..2bcfc7f60 100644
--- a/lib/mprintf.c
+++ b/lib/mprintf.c
@@ -243,17 +243,21 @@ static int parsefmt(const char *format,
       bool loopit = TRUE;
       fmt++;
       outlen = (size_t)(fmt - start - 1);
-      if(*fmt == '%') {
+      /* Rationale: Branch on overflow to avoid any out-of-bounds access */
+if(*fmt == '%') {
         /* this means a %% that should be output only as %. Create an output
            segment. */
         if(outlen) {
-          optr = &out[ocount++];
-          if(ocount > MAX_SEGMENTS)
+          if(ocount < MAX_SEGMENTS) {
+            optr = &out[ocount++];
+            optr->input = 0;
+            optr->flags = FLAGS_SUBSTR;
+            optr->start = start;
+            optr->outlen = outlen;
+          }
+          else {
             return PFMT_MANYSEGS;
-          optr->input = 0;
-          optr->flags = FLAGS_SUBSTR;
-          optr->start = start;
-          optr->outlen = outlen;
+          }
         }
         start = fmt;
         fmt++;
@@ -1090,10 +1094,25 @@ int curl_mvsnprintf(char *buffer, size_t maxlength, const char *format,
 int curl_msnprintf(char *buffer, size_t maxlength, const char *format, ...)
 {
   int retcode;
+  /* Rationale: validate inputs before formatting */
+  if(!buffer || maxlength == 0 || !format) {
+    return 0;
+  }
+  /* pre-set NUL in case of error */
+  buffer[0] = '\0';
   va_list ap_save; /* argument pointer */
   va_start(ap_save, format);
   retcode = curl_mvsnprintf(buffer, maxlength, format, ap_save);
   va_end(ap_save);
+  /* Rationale: ensure NUL and clamp length */
+  if(retcode < 0) {
+    buffer[0] = '\0';
+    retcode = 0;
+  }
+  else if((size_t)retcode >= maxlength) {
+    buffer[maxlength - 1] = '\0';
+    retcode = (int)maxlength - 1;
+  }
   return retcode;
 }
 
@@ -1102,8 +1121,7 @@ static int alloc_addbyter(unsigned char outc, void *f)
 {
   struct asprintf *infop = f;
   CURLcode result = Curl_dyn_addn(infop->b, &outc, 1);
-  if(result) {
-    infop->merr = result == CURLE_TOO_LARGE ? MERR_TOO_LARGE : MERR_MEM;
+  if(result) {    infop->merr = result == CURLE_TOO_LARGE ? MERR_TOO_LARGE : MERR_MEM;
     return 1 ; /* fail */
   }
   return 0;
