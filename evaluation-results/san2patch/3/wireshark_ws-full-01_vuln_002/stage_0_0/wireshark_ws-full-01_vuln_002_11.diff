diff --git a/epan/dissectors/packet-telnet.c b/epan/dissectors/packet-telnet.c
index 9f003e3e61..9443d22c75 100644
--- a/epan/dissectors/packet-telnet.c
+++ b/epan/dissectors/packet-telnet.c
@@ -2095,8 +2095,26 @@ telnet_sub_option(packet_info *pinfo, proto_tree *option_tree, proto_item *optio
         /* Data is escaped, we have to unescape it. */
         unescaped_tvb = unescape_and_tvbuffify_telnet_option(pinfo, tvb, start_offset, subneg_len);
         (*opt->dissect)(pinfo, opt->name, unescaped_tvb, 0, subneg_len - iac_data, option_tree, option_item);
+        /* Fix CWE-416: Post-dissection duplicate NAWS buffer to avoid use-after-free */
+        if (strcmp(opt->name, "NAWS") == 0) {
+          guint len = subneg_len - iac_data;
+          gchar *raw = tvb_get_raw_bytes_as_stringz(unescaped_tvb, 0, len);
+          gchar *dup = g_memdup(raw, len + 1);
+          g_free(raw);
+          g_free(tb->data);
+          tb->data = dup;
+        }
       } else {
         (*opt->dissect)(pinfo, opt->name, tvb, start_offset, subneg_len, option_tree, option_item);
+        /* Post-dissection duplicate NAWS buffer to avoid use-after-free */
+        if (strcmp(opt->name, "NAWS") == 0) {
+          guint len = subneg_len;
+          gchar *raw = tvb_get_raw_bytes_as_stringz(tvb, start_offset, len);
+          gchar *dup = g_memdup(raw, len + 1);
+          g_free(raw);
+          g_free(tb->data);
+          tb->data = dup;
+        }
       }
     } else {
       /* We don't have a dissector for them; just show them as data. */
