diff --git a/src/fmt.c b/src/fmt.c
index 8164e1ca..78d2d835 100644
--- a/src/fmt.c
+++ b/src/fmt.c
@@ -220,17 +220,26 @@ static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {
   // Reverse a string
   for (i = 0; i < n / 2; i++) {
     char t = buf[s + i];
-    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
+  buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;
   }
   if (val == 0) buf[n++] = '0';  // Handle special case
   return n + s;
 }
 
+/*
+ * Rationale: detect missing null-terminator within 'len' bytes and avoid
+ * any out-of-bounds reads by aborting on unterminated buffers.
+ */
 static size_t scpy(void (*out)(char, void *), void *ptr, char *buf,
                           size_t len) {
-  size_t i = 0;
-  while (i < len && buf[i] != '\0') out(buf[i++], ptr);
-  return i;
+  for (size_t i = 0; i < len; i++) {
+    if (buf[i] == '\0') {
+      return i;
+    }
+    out(buf[i], ptr);
+  }
+  /* Buffer not terminated within len: return zero or could log error */
+  return 0;
 }
 
 size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {
@@ -241,7 +250,6 @@ size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {
   va_end(ap);
   return len;
 }
-
 size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
                    va_list *ap) {
   size_t i = 0, n = 0;
@@ -315,17 +323,18 @@ size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
         for (j = 0; minus && pr < w && j + pr < w; j++)
           n += scpy(out, param, &pad, 1);
       } else if (c == 'e' || c == 'E') {
-		  char tmp[8];
+          char mant[24];
+          char exp[16];
           double d = va_arg(*ap, double);
           int64_t exponent = (int64_t)log10(my_fabs(d));
           double mantissa = d / power(10, exponent);
-          k = mg_dtoa(tmp, 10, mantissa, 8, c == 'e');
-          n += scpy(out, param, tmp, k);
+          k = mg_dtoa(mant, sizeof(mant), mantissa, 8, c == 'e');
+          n += scpy(out, param, mant, k, sizeof(mant));
           out(c, param);
           n++;
-		  k = mg_lld(tmp, exponent, 1, 0);
-          n += scpy(out, param, tmp, k);
-	  } else if (c == '%') {
+          k = mg_lld(exp, exponent, 1, 0);
+          n += scpy(out, param, exp, k, sizeof(exp));
+      } else if (c == '%') {
         out('%', param);
         n++;
       } else {
