diff --git a/parser.c b/parser.c
index 836b4a4f..79fe2799 100644
--- a/parser.c
+++ b/parser.c
@@ -4068,29 +4068,21 @@ xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
 
     quote = CUR;
     if ((quote != '"') && (quote != '\'')) {
-	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
-	return(NULL);
+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
+        return(NULL);
     }
     CUR_PTR++;
 
     length = 0;
-
-    /*
-     * Copy raw content of the entity into a buffer
-     */
     while (1) {
         int c;
-
         if (PARSER_STOPPED(ctxt))
             goto error;
-
         if (CUR_PTR >= ctxt->input->end) {
             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
             goto error;
         }
-
         c = CUR;
-
         if (c == 0) {
             xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
                     "invalid character in entity value\n");
@@ -4100,10 +4092,6 @@ xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
             break;
         NEXTL(1);
         length += 1;
-
-        /*
-         * TODO: Check growth threshold
-         */
         if (ctxt->input->end - CUR_PTR < 10)
             GROW;
     }
@@ -4116,6 +4104,14 @@ xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
             xmlErrMemory(ctxt);
     }
 
+    /* Pre-allocate exact space for raw content */
+    if (xmlSBufGrow(&buf, buf.size + (unsigned)length) < 0) {
+        xmlErrMemory(ctxt);
+        xmlSBufCleanup(&buf, ctxt, "entity length too long");
+        return(NULL);
+    }
+
+    /* Now expand and append PEM expands */
     xmlExpandPEsInEntityValue(ctxt, &buf, start, length, ctxt->inputNr);
 
     NEXTL(1);
@@ -4404,6 +4400,7 @@ xmlExpandEntityInAttValue(xmlParserCtxtPtr ctxt, xmlSBuf *buf,
  *
  * Returns the expanded attribtue value.
  */
+/* Rationale: Estimate a safe buffer size by pre-scanning the input for entity references and growing before expansion. */
 xmlChar *
 xmlExpandEntitiesInAttValue(xmlParserCtxtPtr ctxt, const xmlChar *str,
                             int normalize) {
@@ -4412,8 +4409,20 @@ xmlExpandEntitiesInAttValue(xmlParserCtxtPtr ctxt, const xmlChar *str,
                          XML_MAX_TEXT_LENGTH;
     xmlSBuf buf;
     int inSpace = 1;
+    const xmlChar *p = str;
+    unsigned estimate = 0;
+
+    /* rough estimate: each '&' may expand to maxLength characters */
+    while ((p = xmlStrchr(p, '&')) != NULL) {
+        estimate += maxLength;
+        p++;
+    }
 
     xmlSBufInit(&buf, maxLength);
+    /* grow buffer to accommodate estimated expansion plus input length */
+    if (xmlSBufGrow(&buf, xmlStrlen(str) + estimate) < 0) {
+        return(xmlSBufFinish(&buf, NULL, ctxt, "AttValue length too long"));
+    }
 
     xmlExpandEntityInAttValue(ctxt, &buf, str, NULL, normalize, &inSpace,
                               ctxt->inputNr, /* check */ 0);
