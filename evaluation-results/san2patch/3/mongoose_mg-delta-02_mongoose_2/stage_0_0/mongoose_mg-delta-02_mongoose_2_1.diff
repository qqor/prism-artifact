diff --git a/src/net_builtin.c b/src/net_builtin.c
index 793874f4..edaa586f 100644
--- a/src/net_builtin.c
+++ b/src/net_builtin.c
@@ -357,10 +357,14 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
               &ifp->mac));
     ether_output(ifp, PDIFF(eth, arp + 1));
   } else if (pkt->arp->op == mg_htons(2)) {
+    uint8_t *base = (uint8_t *)pkt;
+    uint8_t *end = base + ifp->rx.len;
+    /* Check ARP header bounds */
+    if ((uint8_t *)(pkt->arp + 1) > end) return;
     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;
     if (pkt->arp->spa == ifp->gw) {
       // Got response for the GW ARP request. Set ifp->gwmac and IP -> READY
-      memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));
+       memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));
       if (ifp->state == MG_TCPIP_STATE_IP) {
         ifp->state = MG_TCPIP_STATE_READY;
         onstatechange(ifp);
@@ -369,6 +373,8 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
       struct mg_connection *c = getpeer(ifp->mgr, pkt, false);
       if (c != NULL && c->is_arplooking) {
         struct connstate *s = (struct connstate *) (c + 1);
+        /* Ensure SHA fits in buffer */
+        if ((uint8_t *)&pkt->arp->sha + sizeof(pkt->arp->sha) > end) return;
         memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));
         MG_DEBUG(("%lu ARP resolved %M -> %M", c->id, mg_print_ip4, c->rem.ip,
                   mg_print_mac, s->mac));
@@ -380,9 +386,14 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
 }
 
 static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
-  // MG_DEBUG(("ICMP %d", (int) len));
+// Rationale: Validate entire ICMP payload is within received buffer before echo reply
   if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {
-    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
+    size_t hdrs_len = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
+    size_t total_needed = hdrs_len + pkt->pay.len;
+    if (ifp->rx.len < total_needed) {
+      return;
+    }
+    size_t hlen = hdrs_len;
     size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;
     if (plen > space) plen = space;
     struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,
