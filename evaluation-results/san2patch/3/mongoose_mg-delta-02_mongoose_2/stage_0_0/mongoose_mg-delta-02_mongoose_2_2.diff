diff --git a/src/net_builtin.c b/src/net_builtin.c
index 793874f4..68bba5cb 100644
--- a/src/net_builtin.c
+++ b/src/net_builtin.c
@@ -356,11 +356,12 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
     MG_DEBUG(("ARP: tell %M we're %M", mg_print_ip4, &arp->tpa, mg_print_mac,
               &ifp->mac));
     ether_output(ifp, PDIFF(eth, arp + 1));
-  } else if (pkt->arp->op == mg_htons(2)) {
+  } else if (pkt->arp->op == mg_htons(2) &&
+    (uint8_t *)(pkt->arp + 1) <= (uint8_t *)pkt + ifp->rx.len) {
     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;
     if (pkt->arp->spa == ifp->gw) {
       // Got response for the GW ARP request. Set ifp->gwmac and IP -> READY
-      memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));
+       memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));
       if (ifp->state == MG_TCPIP_STATE_IP) {
         ifp->state = MG_TCPIP_STATE_READY;
         onstatechange(ifp);
@@ -380,17 +381,24 @@ static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
 }
 
 static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {
-  // MG_DEBUG(("ICMP %d", (int) len));
-  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {
-    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
+// Rationale: Single compound condition to ensure packet is well-formed
+  size_t min_len = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);
+  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip && ifp->rx.len >= min_len) {
+    struct ip *ip_hdr = pkt->ip;
+    struct icmp *icmp_hdr = pkt->icmp;
+    /* Rationale: Ensure ICMP header is within buffer */
+    if ((uint8_t *)(icmp_hdr + 1) > (uint8_t *)pkt + ifp->rx.len) {
+      return;
+    }
+    size_t hlen = min_len;
     size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;
     if (plen > space) plen = space;
-    struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,
-                          sizeof(struct icmp) + plen);
-    struct icmp *icmp = (struct icmp *) (ip + 1);
-    memset(icmp, 0, sizeof(*icmp));        // Set csum to 0
-    memcpy(icmp + 1, pkt->pay.buf, plen);  // Copy RX payload to TX
-    icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);
+    ip_hdr = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,
+                   sizeof(struct icmp) + plen);
+    icmp_hdr = (struct icmp *)(ip_hdr + 1);
+    memset(icmp_hdr, 0, sizeof(*icmp_hdr));        // Set csum to 0
+    memcpy(icmp_hdr + 1, pkt->pay.buf, plen);      // Copy RX payload to TX
+    icmp_hdr->csum = ipcsum(icmp_hdr, sizeof(*icmp_hdr) + plen);
     ether_output(ifp, hlen + plen);
   }
 }
