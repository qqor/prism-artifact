diff --git a/epan/dissectors/packet-gvcp.c b/epan/dissectors/packet-gvcp.c
index d49324a429..9f05e2215d 100644
--- a/epan/dissectors/packet-gvcp.c
+++ b/epan/dissectors/packet-gvcp.c
@@ -971,7 +971,6 @@ void process_register_writes(proto_tree *tree, tvbuff_t *tvb, int offset)
 
 	return;
 }
-
 /*
 Attempts to dissect a bootstrap register
 */
@@ -979,8 +978,14 @@ Attempts to dissect a bootstrap register
 static int dissect_register(uint32_t addr, proto_tree *branch, tvbuff_t *tvb, int offset, int length)
 {
 	uint32_t value = 0;
-	
+#define MAX_REGISTERS 64
+	// Early return on overflow to avoid out-of-bounds write
 	value = tvb_get_letohl(tvb, offset);
+	if (gvcp_register_count >= MAX_REGISTERS) {
+		expert_add_info_format(pinfo, NULL, PI_MALFORMED, PI_ERROR,
+				   "GVCP register index %u out of range, dropping entry", gvcp_register_count);
+		return 0;
+	}
 	gvcp_register_number[gvcp_register_count] = addr;
 	gvcp_register_value[gvcp_register_count++] = value;
 
@@ -991,8 +996,7 @@ static int dissect_register(uint32_t addr, proto_tree *branch, tvbuff_t *tvb, in
 		proto_tree_add_item(branch, hf_gvcp_spec_version_minor, tvb, offset, 4, ENC_BIG_ENDIAN);
 		break;
 
-	case GVCP_DEVICE_MODE:
-		proto_tree_add_item(branch, hf_gvcp_devicemode_endianness, tvb, offset, 4, ENC_BIG_ENDIAN);
+	case GVCP_DEVICE_MODE:		proto_tree_add_item(branch, hf_gvcp_devicemode_endianness, tvb, offset, 4, ENC_BIG_ENDIAN);
 		proto_tree_add_item(branch, hf_gvcp_devicemode_deviceclass, tvb, offset, 4, ENC_BIG_ENDIAN);
 		proto_tree_add_item(branch, hf_gvcp_devicemode_current_link_configuration_v2_0, tvb, offset, 4, ENC_BIG_ENDIAN);
 		proto_tree_add_item(branch, hf_gvcp_devicemode_characterset, tvb, offset, 4, ENC_BIG_ENDIAN);
