diff --git a/src/reformat.c b/src/reformat.c
index f261e07..049c2a9 100644
--- a/src/reformat.c
+++ b/src/reformat.c
@@ -771,26 +771,33 @@ static avifResult avifImageYUVAnyToRGBAnySlow(const avifImage * image,
                     spill_Cb = AVIF_CLAMP(Cb - AVIF_CLAMP(Cb,minCb,maxCb),0.0f,1.0f);
 
                     // now we have generated the spill, get it's neigbors
-                    int adjCol = (i%2) ? -1 : 1;
-                    int adjRow = (j%2) ? -1 : 1;
-                    // check the bounds
-                    if (i + adjCol >= image->width){
+                    // compute offsets for neighboring pixels
+                    int adjCol = (i % 2) ? -1 : 1;
+                    int adjRow = (j % 2) ? -1 : 1;
+                    // clamp to image bounds
+                    if ((int)i + adjCol < 0 || (int)i + adjCol >= (int)image->width) {
                         adjCol = 0;
                     }
-                    if (j + adjRow >= image->height){
+                    if ((int)j + adjRow < 0 || (int)j + adjRow >= (int)image->height) {
                         adjRow = 0;
                     }
                     float pSpillCb = spill_Cb/3;
                     float pSpillCr = spill_Cr/3;
-                    
+                    // apply spill to current and neighboring pixels
                     uspill_image[i][j] -= spill_Cb;
                     vspill_image[i][j] -= spill_Cr;
-                    uspill_image[i+adjCol][j] += pSpillCb;
-                    vspill_image[i+adjCol][j] += pSpillCr;
-                    uspill_image[i][j+adjRow] += pSpillCb;
-                    vspill_image[i][j+adjRow] += pSpillCr;
-                    uspill_image[i+adjCol][j+adjRow] += pSpillCb;
-                    vspill_image[i+adjCol][j+adjRow] += pSpillCr;
+                    if (adjCol != 0) {
+                        uspill_image[i + adjCol][j] += pSpillCb;
+                        vspill_image[i + adjCol][j] += pSpillCr;
+                    }
+                    if (adjRow != 0) {
+                        uspill_image[i][j + adjRow] += pSpillCb;
+                        vspill_image[i][j + adjRow] += pSpillCr;
+                    }
+                    if (adjCol != 0 && adjRow != 0) {
+                        uspill_image[i + adjCol][j + adjRow] += pSpillCb;
+                        vspill_image[i + adjCol][j + adjRow] += pSpillCr;
+                    }
                         
                     total_spill += fabs(spill_Cb);
                     total_spill += fabs(spill_Cr);
@@ -807,14 +814,23 @@ static avifResult avifImageYUVAnyToRGBAnySlow(const avifImage * image,
                         }else{
                             b = -1;
                         }
+                        // apply dampening corrections safely
                         uspill_image[i][j] -= pSpillCb;
-                        vspill_image[i][j] -= pSpillCb;
-                        uspill_image[i+a][j] -= pSpillCb;
-                        vspill_image[i+a][j] -= pSpillCr;
-                        uspill_image[i][j+b] -= pSpillCb;
-                        vspill_image[i][j+b] -= pSpillCr;
-                        uspill_image[i+a][j+b] -= pSpillCb;
-                        vspill_image[i+a][j+b] -= pSpillCr;
+                        vspill_image[i][j] -= pSpillCr; // correct channel
+                        int ia = i + a;
+                        int jb = j + b;
+                        if (ia >= 0 && ia < (int)image->width) {
+                            uspill_image[ia][j] -= pSpillCb;
+                            vspill_image[ia][j] -= pSpillCr;
+                        }
+                        if (jb >= 0 && jb < (int)image->height) {
+                            uspill_image[i][jb] -= pSpillCb;
+                            vspill_image[i][jb] -= pSpillCr;
+                        }
+                        if (ia >= 0 && ia < (int)image->width && jb >= 0 && jb < (int)image->height) {
+                            uspill_image[ia][jb] -= pSpillCb;
+                            vspill_image[ia][jb] -= pSpillCr;
+                        }
                     }   
                 }
             }
